#!/bin/sh

#!/bin/bash -e
#SBATCH -p ei-medium # partition (queue)
#SBATCH -N 1 # number of nodes
#SBATCH -n 1 # number of tasks
#SBATCH --mem 8000 # memory pool for all cores
#SBATCH -t 3-23:59 # time (D-HH:MM)
#SBATCH -o slurm.%N.%j.out # STDOUT
#SBATCH -e slurm.%N.%j.err # STDERR
#SBATCH --mail-type=ALL # notifications for job done & fail
#SBATCH --mail-user=Tarang.Mehta@earlham.ac.uk # send-to address

################################################################################################################

# ATAC-seq pipeline - Part 3
# June 2020: Tarang K. Mehta, Earlham Institute, Norwich, UK

################################################################################################################

# Script usage: ./ATAC_Bioinf_pipeline_v2c.sh

## Place this script and the following files in $WD/$scripts (created in first script)
# 1. As used in './ATAC_Bioinf_pipeline_v2a.sh': a 2-column space-delimited table where col1='R1/R2 filename's col2='desired species renamed filename: species_tissue_experiment e.g. Mz_L_ATAC/gDNA'
# 2. Scripts:
  # ATAC_Bioinf_pipeline_v2c_part2bi.promBED_fromGeneBED.py
  # ATAC_Bioinf_pipeline_v2c_part2biii.promSeqs_fromBED5_stranded.py
  # ATAC_Bioinf_pipeline_v2c_part3a.R
# 3. Run as an sbatch script with 8Gb memory and ~4 days runtime - will spawn off other jobs

## Other Notes:
# Install R-4.0.2 with the required packages:
# "RMySQL","rtracklayer","GenomicFeatures","GLAD","gsl","ensembldb","GenomicRanges","MotIV","motifStack","ATACseqQC","ChIPpeakAnno", "MotifDb", "GenomicAlignments","Rsamtools","BSgenome","Biostrings","ggplot2","DiffBind", "DESeq2", "motifbreakR"

################################################################################################################

# ~ This pipeline is ran for all ATAC narrow peak files generated by 'ATAC_Bioinf_pipeline_v2b.sh', and contains the following components:

# 1. IDR on all pairs of replicates (optional) - The IDR peaks are a subset of the naive overlap peaks that pass a specific IDR threshold of 10%.
# 	1a. IDR of true replicates
# 	1b. Compute Fraction of Reads in Peaks (FRiP) - bedtools and awk
# 2. Peak annotation - ATACseqQC
# 	2a. TSS enrichment
# 	2b. Fraction of reads in annotated regions
# 3. TF footprinting and creation of signal tracks (needs to be ran on shifted BAM)- RGT (HINT-ATAC)
# 4. Peak orthology
#   4a. Generate a presence and absence matrix at gene level for the peaks
#   4b. Start to analyse/subset the main tables, getting the values on
#   4c. Are the peaks preserved - use the alignment. If it's crap then run a local alignment for pairs.
#   4d. Get a paired nt conservation score - run phylop
# 5. Differential analysis of peaks - DiffBind

################################################################################################################

# All variables are added here - there are some in-script and many are hardcoded so they cannot be changed for other species
# NOTE: if you want to run for other species then it will require a lot of amending in script!!

scripts=(/ei/projects/9/9e238063-c905-4076-a975-f7c7f85dbd56/scratch/ATACseq/3.run2) # place all scripts in the topmost directory - create this separately
# WD=(/ei/projects/9/9e238063-c905-4076-a975-f7c7f85dbd56/data/ATACseq/3.run2/$spID) # insert the working directory
email=Tarang.Mehta@earlham.ac.uk # SBATCH out and err send to address

### 1. IDR
idrdir=($scripts/1.IDR) # assign raw reads dir
prefixATAC=($scripts/prefixATAC.txt)
prefixpairs=($idrdir/prefixpairs.txt)
idrpairs=($idrdir/idrpairpaths.txt)
idrpairs2=($idrdir/idrpairpaths2.txt)
idrpairunique=($idrdir/idrpairpathsunique.txt)
idrpair1=($idrdir/idrpairpaths_rep1.txt)
idrpair2=($idrdir/idrpairpaths_rep2.txt)
idrprefix=($idrdir/idrprefix.txt)
idrpair1a=($idrdir/idrpairpaths_rep1unzipped.txt) # unzipped narrow peaks file path for rep1
idrpair2a=($idrdir/idrpairpaths_rep2unzipped.txt) # unzipped narrow peaks file path for rep2
IDR_THRESH=0.1 # currently set at 10%, consider changing to 0.05 (5%)
IDR_THRESH_TRANSFORMED=$(awk -v p=${IDR_THRESH} 'BEGIN{print -log(p)/log(10)}')
npeaks_idr=($idrdir/idr_10thresh_peakcount.txt) # Number of peaks passing IDR thresholds of 10%
npeaks_idrrep1=($idrdir/idr_10thresh_peakcount_rep1.txt) # Number of peaks passing IDR thresholds of 10% for replicate 1
npeaks_idrrep2=($idrdir/idr_10thresh_peakcount_rep2.txt) # Number of peaks passing IDR thresholds of 10% for replicate 2
npeaks_idrrep3=($idrdir/idr_10thresh_peakcount_rep3.txt) # Number of peaks passing IDR thresholds of 10% for both replicates - however, there are duplicate samples with different npeaks
npeaks_idrrep4=($idrdir/idr_10thresh_peakcount_rep4.txt) # Number of peaks passing IDR thresholds of 10% for both replicates - this file has the longest for duplicates
reppeaks=($idrdir/reppeaks.txt)
npeaks=($idrdir/npeaks.txt)
IDRsummary=(IDR_${IDR_THRESH}_outputsummary.txt)

fripprefix=($idrdir/fripprefix.txt)
FRIP=($idrdir/FRiPvalues.txt) # FRiP won't be used as a QC measure, TSS enrichment will be
PASS=0.3 # FRiP values >0.3 deemed as pass
ACCEPTABLE=0.2 # FRiP values >0.2 deemed as acceptable

### 2. Peak annotation - there are several variables in the section that will need amending
annotdir=($scripts/2.Annotation) # assign raw reads dir
mkdir -p $annotdir
cd $annotdir
prefixATAC2=($scripts/prefixATAC2.txt)
atacqcscript=($scripts/ATAC_Bioinf_pipeline_v2c_part3a.R) # ensure it is in scripts folder

pcre=pcre2-10.23 # path to source pcre v2-10.23
r402=~/CISSUPPORT-11716/stagingloader # path to source R-4.0.2

speciesid1=Mz
speciesid2=Pn
speciesid3=Ab
speciesid4=Nb
speciesid5=On
speciesid6=Ac

atacqcscript2=(ATAC_Bioinf_pipeline_v2c_part3b.sh) # not required beforehand - will be created in this script

splitg=($annotdir/splitgenomes.txt)

# genome folders - the variables are obviously hardcoded below, if you want to make generic then create a for loop over species genomes in scripts
genomesdir=(/ei/projects/9/9e238063-c905-4076-a975-f7c7f85dbd56/data/ATACseq/3.run2/genomes)
Mzg=($genomesdir/Mzebra)
Png=($genomesdir/Pnyererei)
Abg=($genomesdir/Aburtoni)
Nbg=($genomesdir/Nbrichardi)
Ong=($genomesdir/Oniloticus)
Acg=($genomesdir/Acalliptera)

# genome fasta - assign genomes here with FA* variables, and a list of paths will be created for while loops (so for adding own or other species, just change or add to variables here)
# NOTE: ensure input FASTAs have only a short headers e.g. >chr1 or >scaffold001 etc.
FAMzg=$Mzg/dna/Maylandia_zebra.M_zebra_UMD2a.dna.primary_assembly.allLG.and.nonchromosomal.fa
FAPng=$Png/dna/Pundamilia_nyererei.PunNye1.0.dna.nonchromosomal.fa
FAAbg=$Abg/dna/Haplochromis_burtoni.AstBur1.0.dna.nonchromosomal.fa
FANbg=$Nbg/dna/Neolamprologus_brichardi.NeoBri1.0.dna.nonchromosomal.fa
FAOng=$Ong/dna/Oreochromis_niloticus.O_niloticus_UMD_NMBU.dna.primary_assembly.allLG.and.nonchromosomal.fa
FAAcg=$Acg/dna/Astatotilapia_calliptera.fAstCal1.2.dna.primary_assembly.allLG.and.nonchromosomal.fa
genfastas=($annotdir/path_genomes.txt)
for gf in "${!FA@}"; do
  # echo "$gf is set to ${!gf}"
  echo "${!gf}" >> $genfastas
done
# chromosome sizes - variables are hardcoded below; a for loop over species genomes in scripts will make this generic
Mzgchr=$Mzg/dna/Maylandia_zebra.M_zebra_UMD2a.dna.primary_assembly.allLG.and.nonchromosomal.fa.chrom.sizes
Pngchr=$Png/dna/Pundamilia_nyererei.PunNye1.0.dna.nonchromosomal.fa.chrom.sizes
Abgchr=$Abg/dna/Haplochromis_burtoni.AstBur1.0.dna.nonchromosomal.fa.chrom.sizes
Nbgchr=$Nbg/dna/Neolamprologus_brichardi.NeoBri1.0.dna.nonchromosomal.fa.chrom.sizes
Ongchr=$Ong/dna/Oreochromis_niloticus.O_niloticus_UMD_NMBU.dna.primary_assembly.allLG.and.nonchromosomal.fa.chrom.sizes
Acgchr=$Acg/dna/Astatotilapia_calliptera.fAstCal1.2.dna.primary_assembly.allLG.and.nonchromosomal.fa.chrom.sizes
source bioawk-1.0
while read -r a; do
  bioawk -c fastx '{ print $name, length($seq) }' < ${a} | awk '{print $1,$2}' OFS="\t" > $(echo "${a}" | sed 's/.fa/.fa.chrom.sizes/g')
done < $genfastas
# annotation files •.gtf - assign annotations here with annot* variables, and a list of paths will be created for while loops (so for adding own or other species, just change or add to variables here)
annotMzg=$Mzg/current_gtf/maylandia_zebra/Maylandia_zebra.M_zebra_UMD2a.101.gtf
annotPng=$Png/current_gtf/pundamilia_nyererei/Pundamilia_nyererei.PunNye1.0.101.gtf
annotAbg=$Abg/current_gtf/haplochromis_burtoni/Haplochromis_burtoni.AstBur1.0.101.gtf
annotNbg=$Nbg/current_gtf/neolamprologus_brichardi/Neolamprologus_brichardi.NeoBri1.0.101.gtf
annotOng=$Ong/current_gtf/oreochromis_niloticus/Oreochromis_niloticus.O_niloticus_UMD_NMBU.101.gtf
annotAcg=$Acg/current_gtf/astatotilapia_calliptera/Astatotilapia_calliptera.fAstCal1.2.101.gtf
antfiles=($annotdir/path_annot.txt)
for af in "${!annot@}"; do
  # echo "$af is set to ${!af}"
  echo "${!af}" >> $antfiles
done
processggenaltsv2=(processggenaltsvpath2.txt)

spnumber=6 # input the total number of species for ceating BS genomes
spnumberarray=$(expr $spnumber - 1)

Mzgannotbed=$Mzg/current_gtf/maylandia_zebra/Maylandia_zebra.M_zebra_UMD2a.101.bed
Pngannotbed=$Png/current_gtf/pundamilia_nyererei/Pundamilia_nyererei.PunNye1.0.101.bed
Abgannotbed=$Abg/current_gtf/haplochromis_burtoni/Haplochromis_burtoni.AstBur1.0.101.bed
Nbgannotbed=$Nbg/current_gtf/neolamprologus_brichardi/Neolamprologus_brichardi.NeoBri1.0.101.bed
Ongannotbed=$Ong/current_gtf/oreochromis_niloticus/Oreochromis_niloticus.O_niloticus_UMD_NMBU.101.bed
Acgannotbed=$Acg/current_gtf/astatotilapia_calliptera/Astatotilapia_calliptera.fAstCal1.2.101.bed

fripprefix2=($annotdir/fripprefix2.txt)

Mzgannotbedtmp=$Mzg/current_gtf/maylandia_zebra/Maylandia_zebra.M_zebra_UMD2a.101.tmp.bed
Pngannotbedtmp=$Png/current_gtf/pundamilia_nyererei/Pundamilia_nyererei.PunNye1.0.101.tmp.bed
Abgannotbedtmp=$Abg/current_gtf/haplochromis_burtoni/Haplochromis_burtoni.AstBur1.0.101.tmp.bed
Nbgannotbedtmp=$Nbg/current_gtf/neolamprologus_brichardi/Neolamprologus_brichardi.NeoBri1.0.101.tmp.bed
Ongannotbedtmp=$Ong/current_gtf/oreochromis_niloticus/Oreochromis_niloticus.O_niloticus_UMD_NMBU.101.tmp.bed
Acgannotbedtmp=$Acg/current_gtf/astatotilapia_calliptera/Astatotilapia_calliptera.fAstCal1.2.101.tmp.bed

Mz5kbpromannottmp=$Mzg/current_gtf/maylandia_zebra/Maylandia_zebra.M_zebra_UMD2a.101.tmp5kb_promoters.stranded.GENEBED.bed
Pn5kbpromannottmp=$Png/current_gtf/pundamilia_nyererei/Pundamilia_nyererei.PunNye1.0.101.tmp5kb_promoters.stranded.GENEBED.bed
Ab5kbpromannottmp=$Abg/current_gtf/haplochromis_burtoni/Haplochromis_burtoni.AstBur1.0.101.tmp5kb_promoters.stranded.GENEBED.bed
Nb5kbpromannottmp=$Nbg/current_gtf/neolamprologus_brichardi/Neolamprologus_brichardi.NeoBri1.0.101.tmp5kb_promoters.stranded.GENEBED.bed
On5kbpromannottmp=$Ong/current_gtf/oreochromis_niloticus/Oreochromis_niloticus.O_niloticus_UMD_NMBU.101.tmp5kb_promoters.stranded.GENEBED.bed
Ac5kbpromannottmp=$Acg/current_gtf/astatotilapia_calliptera/Astatotilapia_calliptera.fAstCal1.2.101.tmp5kb_promoters.stranded.GENEBED.bed

Mz5kbpromannot=$Mzg/current_gtf/maylandia_zebra/Maylandia_zebra.M_zebra_UMD2a.101.5kb_promoters.bed
Pn5kbpromannot=$Png/current_gtf/pundamilia_nyererei/Pundamilia_nyererei.PunNye1.0.101.5kb_promoters.bed
Ab5kbpromannot=$Abg/current_gtf/haplochromis_burtoni/Haplochromis_burtoni.AstBur1.0.101.5kb_promoters.bed
Nb5kbpromannot=$Nbg/current_gtf/neolamprologus_brichardi/Neolamprologus_brichardi.NeoBri1.0.101.5kb_promoters.bed
On5kbpromannot=$Ong/current_gtf/oreochromis_niloticus/Oreochromis_niloticus.O_niloticus_UMD_NMBU.101.5kb_promoters.bed
Ac5kbpromannot=$Acg/current_gtf/astatotilapia_calliptera/Astatotilapia_calliptera.fAstCal1.2.101.5kb_promoters.bed

Mz5kbprom=$Mzg/current_gtf/maylandia_zebra/Maylandia_zebra.M_zebra_UMD2a.101.5kb_promoters.fa
Pn5kbprom=$Png/current_gtf/pundamilia_nyererei/Pundamilia_nyererei.PunNye1.0.101.5kb_promoters.fa
Ab5kbprom=$Abg/current_gtf/haplochromis_burtoni/Haplochromis_burtoni.AstBur1.0.101.5kb_promoters.fa
Nb5kbprom=$Nbg/current_gtf/neolamprologus_brichardi/Neolamprologus_brichardi.NeoBri1.0.101.5kb_promoters.fa
On5kbprom=$Ong/current_gtf/oreochromis_niloticus/Oreochromis_niloticus.O_niloticus_UMD_NMBU.101.5kb_promoters.fa
Ac5kbprom=$Acg/current_gtf/astatotilapia_calliptera/Astatotilapia_calliptera.fAstCal1.2.101.5kb_promoters.fa

friarscript=frinannotatedregions.sh
friarout=fraction_of_reads_in_annotatedregions.txt

### 3. TF footprinting and creation of signal tracks
tffprdir=$scripts/3.TFfprint_SignalTrack
mkdir -p $tffprdir # make the directory here as files will be added
cd $tffprdir
# gene regions •.bed
MzggenGC=$Mzg/current_gtf/maylandia_zebra/Maylandia_zebra.M_zebra_UMD2a.101.generegions_Gencode.bed
PnggenGC=$Png/current_gtf/pundamilia_nyererei/Pundamilia_nyererei.PunNye1.0.101.generegions_Gencode.bed
AbggenGC=$Abg/current_gtf/haplochromis_burtoni/Haplochromis_burtoni.AstBur1.0.101.generegions_Gencode.bed
NbggenGC=$Nbg/current_gtf/neolamprologus_brichardi/Neolamprologus_brichardi.NeoBri1.0.101.generegions_Gencode.bed
OnggenGC=$Ong/current_gtf/oreochromis_niloticus/Oreochromis_niloticus.O_niloticus_UMD_NMBU.101.generegions_Gencode.bed
AcggenGC=$Acg/current_gtf/astatotilapia_calliptera/Astatotilapia_calliptera.fAstCal1.2.101.generegions_Gencode.bed
MzggenRS=$Mzg/current_gtf/maylandia_zebra/Maylandia_zebra.M_zebra_UMD2a.101.generegions_RefSeq.bed
PnggenRS=$Png/current_gtf/pundamilia_nyererei/Pundamilia_nyererei.PunNye1.0.101.generegions_RefSeq.bed
AbggenRS=$Abg/current_gtf/haplochromis_burtoni/Haplochromis_burtoni.AstBur1.0.101.generegions_RefSeq.bed
NbggenRS=$Nbg/current_gtf/neolamprologus_brichardi/Neolamprologus_brichardi.NeoBri1.0.101.generegions_RefSeq.bed
OnggenRS=$Ong/current_gtf/oreochromis_niloticus/Oreochromis_niloticus.O_niloticus_UMD_NMBU.101.generegions_RefSeq.bed
AcggenRS=$Acg/current_gtf/astatotilapia_calliptera/Astatotilapia_calliptera.fAstCal1.2.101.generegions_RefSeq.bed
# assign the species you require for downloading BioMart gene alias annotations here - for my pipeline there are five species (but only four have biomart entries - for other species, check the biomart identifier for the database e.g. mzebra_gene_ensembl, and amend below)
# this will then use the variables below to add to a file 'biomart_sp.txt' - this will then be read, line by line to download and process the biomart databases
sp1=mzebra_gene_ensembl
sp2=pnyererei_gene_ensembl
sp3=hburtoni_gene_ensembl
#sp4=nbrichardi_gene_ensembl
sp5=oniloticus_gene_ensembl
sp6=acalliptera_gene_ensembl
biomartspecies=(biomart_sp.txt)
for var in "${!sp@}"; do
  # echo "$var is set to ${!var}"
  echo "${!var}" >> $biomartspecies
done
splitmeme=$scripts/split_meme.py # ensure split meme python script is in scripts folder (although this is supressed to run here!)
# tab delimited gene alias file - not required for pipeline but good for downstream analyses
Mzggenaltsv=$Mzg/current_gtf/maylandia_zebra/Maylandia_zebra.M_zebra_UMD2a.101.genealias.tsv
Pnggenaltsv=$Png/current_gtf/pundamilia_nyererei/Pundamilia_nyererei.PunNye1.0.101.genealias.tsv
Abggenaltsv=$Abg/current_gtf/haplochromis_burtoni/Haplochromis_burtoni.AstBur1.0.101.genealias.tsv
Nbggenaltsv=$Nbg/current_gtf/neolamprologus_brichardi/Neolamprologus_brichardi.NeoBri1.0.101.genealias.tsv
Onggenaltsv=$Ong/current_gtf/oreochromis_niloticus/Oreochromis_niloticus.O_niloticus_UMD_NMBU.101.genealias.tsv
Acggenaltsv=$Acg/current_gtf/astatotilapia_calliptera/Astatotilapia_calliptera.fAstCal1.2.101.genealias.tsv
# gene alias files *.txt
Mzggenal=$Mzg/current_gtf/maylandia_zebra/Maylandia_zebra.M_zebra_UMD2a.101.genealias.txt
Pnggenal=$Png/current_gtf/pundamilia_nyererei/Pundamilia_nyererei.PunNye1.0.101.genealias.txt
Abggenal=$Abg/current_gtf/haplochromis_burtoni/Haplochromis_burtoni.AstBur1.0.101.genealias.txt
Nbggenal=$Nbg/current_gtf/neolamprologus_brichardi/Neolamprologus_brichardi.NeoBri1.0.101.genealias.txt
Onggenal=$Ong/current_gtf/oreochromis_niloticus/Oreochromis_niloticus.O_niloticus_UMD_NMBU.101.genealias.txt
Acggenal=$Acg/current_gtf/astatotilapia_calliptera/Astatotilapia_calliptera.fAstCal1.2.101.genealias.txt
Usr='mehtat'
export PATH="$PATH:/hpc-home/mehtat/.local/bin/" # this is to run RGT (supress here and footprinting script in part D if not required)
processggenaltsv=(processggenaltsvpath.txt)
biomartfiles=(biomartfilepaths.txt)
removesp=(neolamprologus_brichardi)
genalpaths=(genealiaspaths.txt)
rgtdatapath=(~/rgtdata) # insert path to RGT data folder for where RGT installed
# NOTE: Many of the variables below are hardcoded into "${!Dfpsp}"'_TFfp.sh' script below - if changed here then ALSO change in the script
rgtidsp1='[MzebraUMD2a]'
rgtidsp2='[PunNye1.0]'
rgtidsp3='[AstBur1.0]'
rgtidsp4='[NeoBri1.0]'
rgtidsp5='[OniloticusUMD]'
rgtidsp6='[fAstCal1.2]'
rgtidsp1a='MzebraUMD2a'
rgtidsp2a='PunNye1.0'
rgtidsp3a='AstBur1.0'
rgtidsp4a='NeoBri1.0'
rgtidsp5a='OniloticusUMD'
rgtidsp6a='fAstCal1.2'
fpsp1=Mz
fpsp2=Pn
fpsp3=Ab
fpsp4=Nb
fpsp5=On
fpsp6=Ac
e=1 # amend this for subtraction from number of files for array (as array starts from 0) default=1
pwmsp1=mz
pwmsp2=pn
pwmsp3=ab
pwmsp4=nb
pwmsp5=on
pwmsp6=ac
j=9 # this is the preceding JOBID number (change this if required e.g. more or less than five species analysed, otherwise JOBIDs will be 'off' - will also then need to change within sbatch while loop and other proceeding JOBIDs)
k=15 # this is the preceding JOBID number - work out by j + [sp_number e.g. 6] (change this if required e.g. more or less than five species analysed, otherwise JOBIDs will be 'off' - will also then need to change within sbatch while loop and other proceeding JOBIDs)

genomesdir=(/ei/projects/9/9e238063-c905-4076-a975-f7c7f85dbd56/data/ATACseq/3.run2/genomes)
mzeb=($genomesdir/Mzebra)
mzebgenome=$mzeb/dna/Maylandia_zebra.M_zebra_UMD2a.dna.primary_assembly.allLG.and.nonchromosomal.fa
pnye=($genomesdir/Pnyererei)
pnyegenome=$pnye/dna/Pundamilia_nyererei.PunNye1.0.dna.nonchromosomal.fa
abur=($genomesdir/Aburtoni)
aburgenome=$abur/dna/Haplochromis_burtoni.AstBur1.0.dna.nonchromosomal.fa
nbri=($genomesdir/Nbrichardi)
nbrigenome=$nbri/dna/Neolamprologus_brichardi.NeoBri1.0.dna.nonchromosomal.fa
onil=($genomesdir/Oniloticus)
onilgenome=$onil/dna/Oreochromis_niloticus.O_niloticus_UMD_NMBU.dna.primary_assembly.allLG.and.nonchromosomal.fa
acal=($genomesdir/Acalliptera)
acalgenome=$acal/dna/Astatotilapia_calliptera.fAstCal1.2.dna.primary_assembly.allLG.and.nonchromosomal.fa

Mzgenomechr=$mzeb/dna/Maylandia_zebra.M_zebra_UMD2a.dna.primary_assembly.allLG.and.nonchromosomal.fa.chrom.sizes
Pngenomechr=$pnye/dna/Pundamilia_nyererei.PunNye1.0.dna.nonchromosomal.fa.chrom.sizes
Abgenomechr=$abur/dna/Haplochromis_burtoni.AstBur1.0.dna.nonchromosomal.fa.chrom.sizes
Nbgenomechr=$nbri/dna/Neolamprologus_brichardi.NeoBri1.0.dna.nonchromosomal.fa.chrom.sizes
Ongenomechr=$onil/dna/Oreochromis_niloticus.O_niloticus_UMD_NMBU.dna.primary_assembly.allLG.and.nonchromosomal.fa.chrom.sizes
Acgenomechr=$acal/dna/Astatotilapia_calliptera.fAstCal1.2.dna.primary_assembly.allLG.and.nonchromosomal.fa.chrom.sizes

repdiffmpbs=repdiffmpbs_paths.txt
repdiffread=repdiffread_paths.txt
repdiffcond=repdiffcond_paths.txt
repdiffout=repdiffout_paths.txt

spdiffmpbs=spdiffmpbs_paths.txt
spdiffread=spdiffread_paths.txt
spdiffcond=spdiffcond_paths.txt
spdiffout=spdiffout_paths.txt

### 4a. Peak orthology
peakorth=($scripts/4.Peak_Orth) # assign peak orth dir

### 4b. Phylop of peaks
phylopdir=($scripts/4b.peak_phylop) # assign peak orth dir

### 5. Differential analysis of peaks



################################################################################################################

### 1. Irreproducible Discovery Rate (IDR) on MACS2 narrow peaks and FRiP

## It is worth following the ENCODE project’s “ATAC-seq Data Standards and Prototype Processing Pipeline” for replicated data on MACS2 peak calling:
  # Peak call with MACS2 > narrow peaks file > IDR on true replicates e.g. Ab5_L and Ab6_L: This is the dataset to use
    # IDR is A statistical procedure called the Irreproducible Discovery Rate (IDR) operates on the replicated peak set and compares consistency of ranks of these peaks in individual replicate/pseudoreplicate peak sets.
      # checks the reproducibility information from the duplicates using the IDR statistic
      # The basic idea is that if two replicates measure the same underlying biology, the most significant peaks, which are likely to be genuine signals, are expected to have high consistency between replicates, whereas peaks with low significance, which are more likely to be noise, are expected to have low consistency.
      # If the consistency between a pair of rank lists (peaks) that contains both significant and insignificant findings is plotted, a transition in consistency is expected
      # This consistency transition provides an internal indicator of the change from signal to noise and suggests how many peaks have been reliably detected - red being false, black being true
      # By fitting a bivariate rank distribuion, IDR finds a threshold to separate real peaks from noise
    # install idr locally: https://github.com/kundajelab/idr
      # wget https://github.com/kundajelab/idr/archive/2.0.4.zip
      # unzip 2.0.4.zip
      # cd idr-2.0.4/
      # ml gcc
      # ml zlib
      # python3 setup.py install
    # follow IDR details: https://docs.google.com/document/d/1f0Cm4vRyDQDu0bMehHD7P7KOMxTOP-HiNoIvL1VcBt8/edit#
      # set IDR_THRESH=0.05/0.1 (that is an IDR threshold of either 5% or 10% - maybe run both?)
    # If you have more than 2 true replicates select the longest peak list from all pairs that passes the IDR threshold.

## NOTE:
# 1. run IDR as an array for all replicate pairs
# 2. In cases where there are more than 2 true replicates select the longest peak list from all pairs that passes the IDR threshold.

mkdir -p $idrdir
cd $idrdir

# 1aA. create a 2-column tab delimited file that has all narrowpeak file paths of pairs to compare
# 1aB. split the above file into two files, one for each column
# 1aC. using an array by iterating through each line of the two 1-column files from above, do the following for each pair:
  # 1aCa. create a pooled-replicate narrowPeak file
  # 1aCb. run IDR on each pair and get peaks passing threshold
  # 1aCc. for cases where there are more than 2 true replicates, select the longest peak list from all pairs that passes the IDR threshold.

# =============================
# 1a. IDR of true replicates
# 1aA. Create IDR comparison pairs
# create a 2-column tab delimited file that has all narrowpeak file paths of pairs to compare
# =============================

for a in $(awk '{print $1}' $prefixATAC); do
  for b in $(awk '{print $1}' $prefixATAC); do
    # echo -e "$a\t$b"
    echo -e "$a\t$b" | awk '{if($1 != $2) print $1, $2;}' OFS='\t' | awk -F"_" '{if($2==$4) print $0}' |
    awk '{if (substr($1,1,2)==substr($2,1,2)) {print $0, "YES"} else if (substr($1,1,2)!=substr($2,1,2)) {print $0, "NO"}}' OFS='\t' |
    grep -v 'NO' | cut -f1,2 >> $prefixpairs.temp
  done
done

awk -F'\t' '!seen[$1>$2 ? $1 FS $2 : $2 FS $1]++' $prefixpairs.temp > $prefixpairs # this removes duplicate pairs that are simply in a different order
rm $prefixpairs.temp

# since the Ac embryo samples are uniquely name, manually add them
echo -e '1aAc_3dpf_ATAC\t1bAc_3dpf_ATAC' >> $prefixpairs
echo -e '2aAc_7dpf_ATAC\t2bAc_7dpf_ATAC' >> $prefixpairs
echo -e '3aAc_12dpf_ATAC\t3bAc_12dpf_ATAC' >> $prefixpairs

awk -F'\t' -v wd="$scripts" '{print wd"/"$1"/5.peak_calling/"$1"_peaks.narrowPeak.gz","\t",wd"/"$2"/5.peak_calling/"$2"_peaks.narrowPeak.gz"}' $prefixpairs | sed 's/ //g' > $idrpairs

# =============================
# 1aB. Separate the pairwise comparisons for an array
# split the above file into two files, one for each column
# =============================
#
cut -f1 $idrpairs > $idrpair1
cut -f2 $idrpairs > $idrpair2
paircount=$(wc -l $idrpairs | awk -F' ' '{print $1}') # assign variable for total number of pairs
IDRarray=0-$(expr $paircount - 1) # number of pairs for the array starting from 0
#
# =============================
# 1aC. Run the IDR analyses by iterating in an array
# 1aCa. unzip files and create a pooled-replicate narrowPeak file
# 1aCb. Perform IDR analysis.
  # Generate a plot and IDR output with additional columns including IDR scores.
# 1aCc. Get peaks passing IDR threshold of 10%
#
cat $idrpair1 $idrpair2 | sort -u > $idrpairunique
# unzip the narrow peak files
while IFS= read -r i; do
  gunzip $i
done < $idrpairunique
#
#
sed 's/.gz//g' $idrpair1 > $idrpair1a
sed 's/.gz//g' $idrpair2 > $idrpair2a
# =============================
sed 's/.gz//g' $idrpairs > $idrpairs2 # now the the peak files are unzipped, change the paths
cat $idrpair1a $idrpair2a | sort -u > $reppeaks

while read -r r1 r2; do
  # echo "rep1 is $r1, rep2 is $r2"
  if test -f "$r1" && test -f "$r2"; then
    echo "$r1 and $r2 EXISTS"
    #
    echo '#!/bin/bash -e' > 1a.IDR_${IDR_THRESH}.sh
    echo '#SBATCH -p ei-medium # partition (queue)' >> 1a.IDR_${IDR_THRESH}.sh
    echo '#SBATCH -N 1 # number of nodes' >> 1a.IDR_${IDR_THRESH}.sh
    echo '#SBATCH -n 1 # number of tasks' >> 1a.IDR_${IDR_THRESH}.sh
    echo "#SBATCH --array=$IDRarray" >> 1a.IDR_${IDR_THRESH}.sh
    echo '#SBATCH --mem-per-cpu 8000' >> 1a.IDR_${IDR_THRESH}.sh
    echo '#SBATCH -t 0-04:59' >> 1a.IDR_${IDR_THRESH}.sh
    echo '#SBATCH --mail-type=ALL # notifications for job done & fail' >> 1a.IDR_${IDR_THRESH}.sh
    echo "#SBATCH --mail-user=$email # send-to address" >> 1a.IDR_${IDR_THRESH}.sh
    echo '#SBATCH -o slurm.%N.%j.out # STDOUT' >> 1a.IDR_${IDR_THRESH}.sh
    echo '#SBATCH -e slurm.%N.%j.err # STDERR' >> 1a.IDR_${IDR_THRESH}.sh
    printf '\n' >> 1a.IDR_${IDR_THRESH}.sh
    echo '# 1aC. Run the IDR analyses by iterating in an array' >> 1a.IDR_${IDR_THRESH}.sh
    echo '# 1aCa. unzip files and create a pooled-replicate narrowPeak file' >> 1a.IDR_${IDR_THRESH}.sh
    echo "mapfile -t idrrep1 < $idrpair1a" >> 1a.IDR_${IDR_THRESH}.sh
    echo "mapfile -t idrrep2 < $idrpair2a" >> 1a.IDR_${IDR_THRESH}.sh
    echo "awk '{print"' $1"_"$2}'"' $prefixpairs > $idrprefix" >> 1a.IDR_${IDR_THRESH}.sh
    echo "mapfile -t idrprefix < $idrprefix" >> 1a.IDR_${IDR_THRESH}.sh
    printf '\n' >> 1a.IDR_${IDR_THRESH}.sh
    echo 'cat ${idrrep1[${SLURM_ARRAY_TASK_ID}]} ${idrrep2[${SLURM_ARRAY_TASK_ID}]} > ${idrprefix[${SLURM_ARRAY_TASK_ID}]}_peaks.narrowPeak' >> 1a.IDR_${IDR_THRESH}.sh
    echo '# 1aCb. Perform IDR analysis.' >> 1a.IDR_${IDR_THRESH}.sh
    echo '# Generate a plot and IDR output with additional columns including IDR scores.' >> 1a.IDR_${IDR_THRESH}.sh
    echo 'srun idr --samples ${idrrep1[${SLURM_ARRAY_TASK_ID}]} ${idrrep2[${SLURM_ARRAY_TASK_ID}]} --peak-list ${idrprefix[${SLURM_ARRAY_TASK_ID}]}_peaks.narrowPeak --input-file-type narrowPeak --output-file ${idrprefix[${SLURM_ARRAY_TASK_ID}]}.IDR'${IDR_THRESH}'output --rank p.value --soft-idr-threshold '"${IDR_THRESH} --plot --use-best-multisummit-IDR" >> 1a.IDR_${IDR_THRESH}.sh
    echo '# 1aCc. Get peaks passing IDR threshold of 10%' >> 1a.IDR_${IDR_THRESH}.sh
    echo '# IDR QC to report and using the IDR output' >> 1a.IDR_${IDR_THRESH}.sh
    echo '# 1. For each biological replicate pair, filter the IDR peaks based on the ${IDR_THRESH_TRANSFORMED} and sort descending based on signal.value (col7)' >> 1a.IDR_${IDR_THRESH}.sh
    printf '\n' >> 1a.IDR_${IDR_THRESH}.sh
    echo "awk 'BEGIN{OFS="'"\t"} $12>='"'"${IDR_THRESH_TRANSFORMED}"' {print "'$1,$2,$3,$4,$5,$6,$7,$8,$9,$10}'"' "'${idrprefix[${SLURM_ARRAY_TASK_ID}]}.IDR'${IDR_THRESH}'output | sort | uniq | sort -k7,7rn > ${idrprefix[${SLURM_ARRAY_TASK_ID}]}.IDR'${IDR_THRESH}'Transf.narrowPeak' >> 1a.IDR_${IDR_THRESH}.sh
    printf '\n' >> 1a.IDR_${IDR_THRESH}.sh
    echo '# 2. For each biological replicate pair, count the number of lines passing ${IDR_THRESH_TRANSFORMED} - this is where IDR finds the threshold to separate real peaks from noise' >> 1a.IDR_${IDR_THRESH}.sh
    echo 'wc -l ${idrprefix[${SLURM_ARRAY_TASK_ID}]}.IDR'${IDR_THRESH}'Transf.narrowPeak >>'" $npeaks_idr # Number of peaks passing IDR thresholds of 10%" >> 1a.IDR_${IDR_THRESH}.sh
    echo '# 3. For each biological replicate in a pair, assign the wc -l as max_numPeaks_Rep peaks' >> 1a.IDR_${IDR_THRESH}.sh
    echo "awk -F'.' '{print "'$1}'"' $npeaks_idr | awk -F'_' '{print"' $1"_"$2"_"$3" "$4"_"$5"_"$6}'"' | sed 's/ /\t/g' > $npeaks_idr.tmp" >> 1a.IDR_${IDR_THRESH}.sh
    echo "cut -f1,2 $npeaks_idr.tmp > $npeaks_idrrep1" >> 1a.IDR_${IDR_THRESH}.sh
    echo "cut -f1,3 $npeaks_idr.tmp > $npeaks_idrrep2" >> 1a.IDR_${IDR_THRESH}.sh
    echo "cat $npeaks_idrrep1 $npeaks_idrrep2 | sort -k2,2 > $npeaks_idrrep3" >> 1a.IDR_${IDR_THRESH}.sh
    echo "sort -k2,2 -k1,1nr $npeaks_idrrep3 | awk '"'!a[$2] {a[$2] = $1} $1 == a[$2]'"' | sort -u | sort -k2,2 > $npeaks" >> 1a.IDR_${IDR_THRESH}.sh
    echo "rm *tmp*" >> 1a.IDR_${IDR_THRESH}.sh
    #
    #
    echo '#!/bin/bash -e' > 1aB.IDR.sh
    echo '#SBATCH -p ei-short # partition (queue)' >> 1aB.IDR.sh
    echo '#SBATCH -N 1 # number of nodes' >> 1aB.IDR.sh
    echo '#SBATCH -n 1 # number of tasks' >> 1aB.IDR.sh
    echo '#SBATCH --mem-per-cpu 8000' >> 1aB.IDR.sh
    echo '#SBATCH -t 0-00:45' >> 1aB.IDR.sh
    echo '#SBATCH --mail-type=ALL # notifications for job done & fail' >> 1aB.IDR.sh
    echo "#SBATCH --mail-user=$email # send-to address" >> 1aB.IDR.sh
    echo '#SBATCH -o slurm.%N.%j.out # STDOUT' >> 1aB.IDR.sh
    echo '#SBATCH -e slurm.%N.%j.err # STDERR' >> 1aB.IDR.sh
    printf '\n' >> 1aB.IDR.sh
    echo '# Double while read array:' >> 1aB.IDR.sh
    echo '# 1. Read in the peak numbers and narrowPeak files and do an IF statement to match the corresponding files' >> 1aB.IDR.sh
    echo '# 2. sort peaks file based on col7 (signal value - fold-change at peak summit)' >> 1aB.IDR.sh
    echo '# 3. read from file paths, open; read from peaks' >> 1aB.IDR.sh
    echo '# 4. use number in col1 to add T to that line and all preceding lines and add F for all lines thereafter' >> 1aB.IDR.sh
    printf '\n' >> 1aB.IDR.sh
    echo 'while IFS= read -u 3 -r reppeak && IFS= read -u 4 -r npeak; do' >> 1aB.IDR.sh
    echo -e '\t# echo ${npeak}' >> 1aB.IDR.sh
    echo -e '\t# echo ${reppeak}' >> 1aB.IDR.sh
    echo -e '\tpeakline=$(echo ${npeak} | awk -F'"' ' '{print "'$1}'"') # get the total count of IDR passed peaks" >> 1aB.IDR.sh
    echo -e '\tpeakprefix=$(echo ${npeak} | awk -F'"' ' '{print "'$2}'"') # get the file prefix this corresponds to" >> 1aB.IDR.sh
    echo -e '\t# echo $peakline' >> 1aB.IDR.sh
    echo -e '\t# echo $peakprefix' >> 1aB.IDR.sh
    echo -e '\tout=$(echo $(basename ${reppeak}) | sed -e '"'s/.narrowPeak/.final.narrowPeak/') # create an outfile" >> 1aB.IDR.sh
    echo -e '\tinprefix=$(echo $(basename ${reppeak}) | sed -e '"'s/_peaks.narrowPeak//') # get the prefix of the narrow peak in file" >> 1aB.IDR.sh
    echo -e '\t# echo $out' >> 1aB.IDR.sh
    echo -e '\t# echo $inprefix' >> 1aB.IDR.sh
    echo -e '\tif [[ $peakprefix = $inprefix ]]; then # check that the peaks passing IDR and narrowPeak file match' >> 1aB.IDR.sh
    echo -e '\t\techo "peakcount>> $peakprefix = $inprefix <<narrowPeaks_file: npeaks and peaks file ARE matched"' >> 1aB.IDR.sh
    echo -e '\t\tsort -k7,7rn ${reppeak} | awk -v peakline="$peakline" '"'{if(NR>=1 && NR<=peakline)print "'$0,"T";else print $0,"F";}'"' OFS='\t' > "'${out} # check with awk '"'FNR>=103003 && FNR<=103006'" >> 1aB.IDR.sh
    echo -e '\telse' >> 1aB.IDR.sh
    echo -e '\t\techo "peakcount>> $peakprefix != $inprefix <<narrowPeaks_file: npeaks and peaks file NOT matched"' >> 1aB.IDR.sh
    echo -e '\tfi' >> 1aB.IDR.sh
    echo "done 3<$reppeaks 4<$npeaks" >> 1aB.IDR.sh
  else
    echo "$r1 and/or $r2 DOES NOT EXIST"
  fi
done < $idrpairs2

# IDR output
# Broad peak output files are the same except that they do not include the the summit columns (e.g. columns 10, 18, and 22 for samples with 2 replicates)
#
#     1. chrom string
#     Name of the chromosome for common peaks
#
#     2. chromStart int
#     The starting position of the feature in the chromosome or scaffold for common peaks, shifted based on offset. The first base in a chromosome is numbered 0.
#
#     3. chromEnd int
#     The ending position of the feature in the chromosome or scaffold for common peaks. The chromEnd base is not included in the display of the feature.
#
#     4. name string
#     Name given to a region (preferably unique) for common peaks. Use '.' if no name is assigned.
#
#     5. score int
#     Contains the scaled IDR value, min(int(log2(-125IDR), 1000). e.g. peaks with an IDR of 0 have a score of 1000, idr 0.05 have a score of int(-125log2(0.05)) = 540, and idr 1.0 has a score of 0.
#
#     6. strand [+-.] Use '.' if no strand is assigned.
#
#     7. signalValue float - fold-change at peak summit
#     Measurement of enrichment for the region for merged peaks. When a peak list is provided this is the value from the peak list.
#
#     8. p-value float
#     Merged peak p-value. When a peak list is provided this is the value from the peak list.
#
#     9. q-value float
#     Merged peak q-value. When a peak list is provided this is the value from the peak list.
#
#     10. summit int
#     Merged peak summit
#
#     11. localIDR float -log10(Local IDR value)
#
#     12. globalIDR float -log10(Global IDR value)
#
#     13. rep1_chromStart int
#     The starting position of the feature in the chromosome or scaffold for common replicate 1 peaks, shifted based on offset. The first base in a chromosome is numbered 0.
#
#     14. rep1_chromEnd int
#     The ending position of the feature in the chromosome or scaffold for common replicate 1 peaks. The chromEnd base is not included in the display of the feature.
#
#     15. rep1_signalValue float
#     Signal measure from replicate 1. Note that this is determined by the --rank option. e.g. if --rank is set to signal.value, this corresponds to the 7th column of the narrowPeak, whereas if it is set to p.value it corresponds to the 8th column.
#
#     16. rep1_summit int
#     The summit of this peak in replicate 1.
#
# [rep 2 data]
#
# ...
#
# [rep N data]


# The plot (*.IDR${IDR_THRESH}output.png) for each quadrant is described below:
# Upper Left: Replicate 1 peak ranks versus Replicate 2 peak ranks - peaks that do not pass the specified idr threshold are colored red.
# Upper Right: Replicate 1 log10 peak scores versus Replicate 2 log10 peak scores - peaks that do not pass the specified idr threshold are colored red.
# Bottom Row: Peak rank versus IDR scores are plotted in black. The overlayed boxplots display the distribution of idr values in each 5% quantile. The IDR values are thresholded at the optimization precision - 1e-6 by default.

## FINAL PEAK FILES based on IDR QC are *.final.narrowPeak - the last column of T (True) or F (False) indicate peaks passing IDR

## Create a final file with percentage of peaks passing IDR - output: col1-sample; col2-total peaks; col3-peaks passing IDR; col4-peaks failing IDR; col5-percentage of peaks passing IDR
printf "sample\ttotal_peaks\tpeaks_passing_IDR-${IDR_THRESH}\tpeaks_failing_IDR-${IDR_THRESH}\tpercentage_peaks_pass_IDR-${IDR_THRESH}\n" > $IDRsummary
for i in *.final.narrowPeak; do
  total=$(wc -l $i | awk -F' ' '{print $1}')
  pass=$(awk '$11=="T"' $i | wc -l)
  fail=$(awk '$11=="F"' $i | wc -l)
  perc=$(perl -E "say ${pass}/${total}*100") # calculate the percentage passing IDR using perl
  echo -e $i'\t'$total'\t'$pass'\t'$fail'\t'$perc | sed 's|_peaks.final.narrowPeak||g' >> $IDRsummary
done

# =============================

echo '# -- 1a. IDR started -- #'

JOBID1=$( sbatch -W --array=$IDRarray 1a.IDR_${IDR_THRESH}.sh | awk '{print $4}' ) # Run the first job and then store the first job to variable JOBID1 (taken by awk once run)

JOBID2=$( sbatch -W --dependency=afterok:${JOBID1} 1aB.IDR.sh | awk '{print $4}' ) # JOB2 depends on JOB1 completing successfully

# =============================

# 1b. Compute Fraction of Reads in Peaks (FRiP)
# The fraction of reads in called peak regions (FRiP score) should be >0.3, though values greater than 0.2 are acceptable.
# FRiP scores will not be enforced as QC metric. TSS enrichment remains in place as a key signal to noise measure.

# 1bA. Create a 3 column file - col1: variableID; col2: tagAlign input; col3: IDR peak file

echo '#!/bin/bash -e' > 1bA.FRIPawk.sh
echo '#SBATCH -p ei-short # partition (queue)' >> 1bA.FRIPawk.sh
echo '#SBATCH -N 1 # number of nodes' >> 1bA.FRIPawk.sh
echo '#SBATCH -n 1 # number of tasks' >> 1bA.FRIPawk.sh
echo '#SBATCH --mem-per-cpu 4000' >> 1bA.FRIPawk.sh
echo '#SBATCH -t 0-00:15' >> 1bA.FRIPawk.sh
echo '#SBATCH --mail-type=ALL # notifications for job done & fail' >> 1bA.FRIPawk.sh
echo "#SBATCH --mail-user=$email # send-to address" >> 1bA.FRIPawk.sh
echo '#SBATCH -o slurm.%N.%j.out # STDOUT' >> 1bA.FRIPawk.sh
echo '#SBATCH -e slurm.%N.%j.err # STDERR' >> 1bA.FRIPawk.sh
printf '\n' >> 1bA.FRIPawk.sh
echo 'awk -F'"'\t' -v "'wd="'$scripts'" '"'{print "'$1,wd"/"$1"/5.peak_calling/"$1".tn5.tagAlign.gz",$1"_peaks.final.narrowPeak"}'"' OFS='\t' $prefixATAC > $fripprefix" >> 1bA.FRIPawk.sh

echo '# -- 1a. IDR has completed -- #'

echo '# -- 1b. FRiP calculation has started -- #'

JOBID3=$( sbatch -W --dependency=afterok:${JOBID2} 1bA.FRIPawk.sh | awk '{print $4}' ) # JOB3 depends on JOB2 completing successfully

echo '#!/bin/bash -e' > 1bB.FRIPok.sh
echo '#SBATCH -p ei-short # partition (queue)' >> 1bB.FRIPok.sh
echo '#SBATCH -N 1 # number of nodes' >> 1bB.FRIPok.sh
echo '#SBATCH -n 1 # number of tasks' >> 1bB.FRIPok.sh
echo '#SBATCH --mem-per-cpu 1000' >> 1bB.FRIPok.sh
echo '#SBATCH -t 0-00:10' >> 1bB.FRIPok.sh
echo '#SBATCH --mail-type=ALL # notifications for job done & fail' >> 1bB.FRIPok.sh
echo "#SBATCH --mail-user=$email # send-to address" >> 1bB.FRIPok.sh
echo '#SBATCH -o slurm.%N.%j.out # STDOUT' >> 1bB.FRIPok.sh
echo '#SBATCH -e slurm.%N.%j.err # STDERR' >> 1bB.FRIPok.sh
printf '\n' >> 1bB.FRIPok.sh
echo 'FRiP calculation will start now...' >> 1bB.FRIPok.sh

JOBID4=$( sbatch -W --dependency=afterok:${JOBID3} 1bB.FRIPok.sh | awk '{print $4}' ) # JOB4 depends on JOB3 completing successfully

# 1bB. while read over the 3 column file and over each line
ml bedtools/2.25.0

while IFS=$'\t' read -r c1 c2 c3; do
  # assign variable for doing bedtools intersect of tagAlign and IDR
  val1=$(bedtools intersect -a <(zcat -f ${c2}) -b <(cat ${c3}) -wa -u | wc -l)
  # 1bC. For loop over the 3 column file and over each line, assign variables for wc -l over tagAlign file
  val2=$(zcat ${c2} | wc -l)
  # 1bD. For each pair of variables, calculate the FRiP value
  frac=$(bc -l <<< "(${val1}/${val2})")
  printf '%s\t%s\t%f\n' "$c1" "$val1""/""$val2" "$frac" >> $FRIP.temp
done < $fripprefix

while IFS=$'\t' read -r a b c; do
  if ((`bc <<< "${c}>=${PASS}"`));
  then printf '%s\t%s\t%f\t%s\n' "$a" "$b" "$c" "FRiP PASS" >> $FRIP
  elif ((`bc <<< "${c}>=${ACCEPTABLE}"`));
  then printf '%s\t%s\t%f\t%s\n' "$a" "$b" "$c" "FRiP PASS - acceptable" >> $FRIP
  else printf '%s\t%s\t%f\t%s\n' "$a" "$b" "$c" "FRiP FAIL" >> $FRIP
  fi
done < $FRIP.temp
rm $FRIP.temp

# Get IDR stats
echo "IDR stats outputted to: IDRstats.txt"
for i in *ATAC_peaks.final.narrowPeak; do
  sample=$(echo $i | sed 's/_peaks.final.narrowPeak//g')
  total=$(wc -l ${i} | awk '{print $1}')
  true=$(awk '$11=="T"' ${i} | wc -l)
  false=$(awk '$11=="F"' ${i} | wc -l)
  echo -e "$sample\t$total\t$true\t$false" >> IDRstats.txt
done

################################################################################################################

### 2. Annotation:
# 	2a. TSS enrichment - plot
  # The TSS enrichment calculation is a signal to noise calculation.
  # Fragments from the nucleosome-free regions (NFR) (< 100 bp) are expected to be enriched around the transcription start site (TSS) of genes, while fragments from nucleosome-bound regions e.g. mono-, di-, and tri-nucleosomes (~ 200, 400, 600 bp, respectively) are expected to be depleted at TSS with a slight enrichment of flanking regions around TSS. These can be evaluated with the tool ATACseqQC.
  # The reads around a reference set of TSSs are collected to form an aggregate distribution of reads centered on the TSSs and extending to 1000 bp in either direction (for a total of 2000bp).
  # This distribution is then normalized by taking the average read depth in the 100 bps at each of the end flanks of the distribution (for a total of 200bp of averaged data) and calculating a fold change at each position over that average read depth.
  # This means that the flanks should start at 1, and if there is high read signal at transcription start sites (highly open regions of the genome) there should be an increase in signal up to a peak in the middle.
  # We take the signal value at the center of the distribution after this normalization as our TSS enrichment metric.

# 	2b. Fraction of Reads in annotated regions

#### NOTE: This section requires R-4.0.2 with the following packages:
## "RMySQL","rtracklayer","GenomicFeatures","GLAD","gsl","ensembldb","GenomicRanges","MotIV","motifStack","ATACseqQC","ChIPpeakAnno", "MotifDb", "GenomicAlignments","Rsamtools","BSgenome","Biostrings","ggplot2","DiffBind", "DESeq2", "motifbreakR"
## R-4.0.2 copied to home area: cp -r /ei/software/staging/CISSUPPORT-11716 ~/
## Load by: source ~/CISSUPPORT-11716/stagingloader

# mkdir -p $annotdir
cd $annotdir

## 2a. Use ATACseqQC here (ensure input BAM is indexed) TO 1) created a Shifted BAM and 2) run TSS Enrichment (to use as a QC measure)
# For ATACseqQC we need to use BSgenome objects: Since we need to use custom genomes that are different to those available, forge a BSgenome package using bare sequences

## 2aA. Split a genome fasta into multiple .fa files (one for each scaffold)

# Create a file with col1 as species id and col2 as the input genome fasta to create a while loop for the genome split
echo -e "$speciesid1\t$FAMzg" >> $splitg
echo -e "$speciesid2\t$FAPng" >> $splitg
echo -e "$speciesid3\t$FAAbg" >> $splitg
echo -e "$speciesid4\t$FANbg" >> $splitg
echo -e "$speciesid5\t$FAOng" >> $splitg
echo -e "$speciesid6\t$FAAcg" >> $splitg

while read -r i1 i2; do
  mkdir $annotdir/${i1}_splitfasta
  cd $annotdir/${i1}_splitfasta
  awk -F "|" '/^>/ {close(F) ; F = substr($1,2,length($1)-1)".fa"} {print >> F}' $i2
done < $splitg # this while loop will make the species dirs, change into them and split the genome fasta by chr

## 2aB. Prepare the seedfiles to forge a BSgenome data package
cd $annotdir

### Note: These BS GENOME VARIABLES need to remain here (and not at top!)
BSsp1a='Mzeb' # BSgenome package ID part 1
BSsp1b='MetZeb2.0' # BSgenome package ID part 2
BSsp1c='Maylandia zebra' # Species name
BSsp1d='2.0' # Assembly version
BSsp1e='Ensembl' # Genome provider
BSsp1f='Apr. 2018' # Release date
BSsp1g='ftp://ftp.ensembl.org/pub/current_fasta/maylandia_zebra' # Source URL
BSsp1h='Maylandia_zebra' # Species_biocview
BSsp1i=`echo "paste(c($(echo ${speciesid1}_splitfasta/*.fa | sed "s/${speciesid1}_splitfasta\///g" | sed 's/.fa//g' | tr '\n' ' ' | sed 's/^/"/g' | sed 's/$/"/g' | sed 's/ /", "/g' | sed 's|, ""||g')))"` # an R expression for all the sequence names e.g. paste("chr", c(1:20, "X", "M", "Un", paste(c(1:20, "X", "Un"), "_random", sep="")), sep="")
BSsp1j="$annotdir/$speciesid1" # sequences dir

BSsp2a='Pnye' # BSgenome package ID part 1
BSsp2b='PunNye1.0' # BSgenome package ID part 2
BSsp2c='Pundamilia nyererei' # Species name
BSsp2d='1.0' # Assembly version
BSsp2e='Ensembl' # Genome provider
BSsp2f='Dec. 2011' # Release date
BSsp2g='ftp://ftp.ensembl.org/pub/current_fasta/pundamilia_nyererei' # Source URL
BSsp2h='Pundamilia_nyererei' # Species_biocview
BSsp2i=`echo "paste(c($(echo ${speciesid2}_splitfasta/*.fa | sed "s/${speciesid2}_splitfasta\///g" | sed 's/.fa//g' | tr '\n' ' ' | sed 's/^/"/g' | sed 's/$/"/g' | sed 's/ /", "/g' | sed 's|, ""||g')))"` # an R expression for all the sequence names e.g. paste("chr", c(1:20, "X", "M", "Un", paste(c(1:20, "X", "Un"), "_random", sep="")), sep="")
BSsp2j="$annotdir/$speciesid2" # sequences dir

BSsp3a='Abur' # BSgenome package ID part 1
BSsp3b='AstBur1.0' # BSgenome package ID part 2
BSsp3c='Astatotilapia burtoni' # Species name
BSsp3d='1.0' # Assembly version
BSsp3e='Ensembl' # Genome provider
BSsp3f='Dec. 2011' # Release date
BSsp3g='ftp://ftp.ensembl.org/pub/current_fasta/haplochromis_burtoni' # Source URL
BSsp3h='Astatotilapia_burtoni' # Species_biocview
BSsp3i=`echo "paste(c($(echo ${speciesid3}_splitfasta/*.fa | sed "s/${speciesid3}_splitfasta\///g" | sed 's/.fa//g' | tr '\n' ' ' | sed 's/^/"/g' | sed 's/$/"/g' | sed 's/ /", "/g' | sed 's|, ""||g')))"` # an R expression for all the sequence names e.g. paste("chr", c(1:20, "X", "M", "Un", paste(c(1:20, "X", "Un"), "_random", sep="")), sep="")
BSsp3j="$annotdir/$speciesid3" # sequences dir

BSsp4a='Nbri' # BSgenome package ID part 1
BSsp4b='NeoBri1.0' # BSgenome package ID part 2
BSsp4c='Neolamprologus brichardi' # Species name
BSsp4d='1.0' # Assembly version
BSsp4e='Ensembl' # Genome provider
BSsp4f='Dec. 2011' # Release date
BSsp4g='ftp://ftp.ensembl.org/pub/current_fasta/neolamprologus_brichardi' # Source URL
BSsp4h='Neolamprologus_brichardi' # Species_biocview
BSsp4i=`echo "paste(c($(echo ${speciesid4}_splitfasta/*.fa | sed "s/${speciesid4}_splitfasta\///g" | sed 's/.fa//g' | tr '\n' ' ' | sed 's/^/"/g' | sed 's/$/"/g' | sed 's/ /", "/g' | sed 's|, ""||g')))"` # an R expression for all the sequence names e.g. paste("chr", c(1:20, "X", "M", "Un", paste(c(1:20, "X", "Un"), "_random", sep="")), sep="")
BSsp4j="$annotdir/$speciesid4" # sequences dir

BSsp5a='Onil' # BSgenome package ID part 1
BSsp5b='OreNil2.0' # BSgenome package ID part 2
BSsp5c='Oreochromis niloticus' # Species name
BSsp5d='2.0' # Assembly version
BSsp5e='Ensembl' # Genome provider
BSsp5f='Jun. 2018' # Release date
BSsp5g='ftp://ftp.ensembl.org/pub/current_fasta/oreochromis_niloticus' # Source URL
BSsp5h='Oreochromis_niloticus' # Species_biocview
BSsp5i=`echo "paste(c($(echo ${speciesid5}_splitfasta/*.fa | sed "s/${speciesid5}_splitfasta\///g" | sed 's/.fa//g' | tr '\n' ' ' | sed 's/^/"/g' | sed 's/$/"/g' | sed 's/ /", "/g' | sed 's|, ""||g')))"` # an R expression for all the sequence names e.g. paste("chr", c(1:20, "X", "M", "Un", paste(c(1:20, "X", "Un"), "_random", sep="")), sep="")
BSsp5j="$annotdir/$speciesid5" # sequences dir

BSsp6a='Acal' # BSgenome package ID part 1
BSsp6b='fAstCal1.2' # BSgenome package ID part 2
BSsp6c='Astatotilapia calliptera' # Species name
BSsp6d='1.2' # Assembly version
BSsp6e='Ensembl' # Genome provider
BSsp6f='Jul. 2018' # Release date
BSsp6g='ftp://ftp.ensembl.org/pub/current_fasta/astatotilapia_calliptera' # Source URL
BSsp6h='Astatotilapia_calliptera' # Species_biocview
BSsp6i=`echo "paste(c($(echo ${speciesid6}_splitfasta/*.fa | sed "s/${speciesid6}_splitfasta\///g" | sed 's/.fa//g' | tr '\n' ' ' | sed 's/^/"/g' | sed 's/$/"/g' | sed 's/ /", "/g' | sed 's|, ""||g')))"` # an R expression for all the sequence names e.g. paste("chr", c(1:20, "X", "M", "Un", paste(c(1:20, "X", "Un"), "_random", sep="")), sep="")
BSsp6j="$annotdir/$speciesid6" # sequences dir

speciesBSgenome1=BSgenome.Mzeb.Ensembl.MetZeb2.0
speciesBSgenome2=BSgenome.Pnye.Ensembl.PunNye1.0
speciesBSgenome3=BSgenome.Abur.Ensembl.AstBur1.0
speciesBSgenome4=BSgenome.Nbri.Ensembl.NeoBri1.0
speciesBSgenome5=BSgenome.Onil.Ensembl.OreNil2.0
speciesBSgenome6=BSgenome.Acal.Ensembl.fAstCal1.2

speciesBSgenome1a=Mzeb
speciesBSgenome2a=Pnye
speciesBSgenome3a=Abur
speciesBSgenome4a=Nbri
speciesBSgenome5a=Onil
speciesBSgenome6a=Acal

echo "Package: BSgenome.$BSsp1a.$BSsp1e.$BSsp1b" > $BSsp1b.seedfile
echo "Title: Full genome sequences for $BSsp1c (version $BSsp1b)" >> $BSsp1b.seedfile
echo "Description: Full genome sequences for $BSsp1c as provided by $BSsp1e ($BSsp1b, $BSsp1f) and stored in Biostrings objects." >> $BSsp1b.seedfile
echo "Version: $BSsp1d" >> $BSsp1b.seedfile
echo "organism: $BSsp1c" >> $BSsp1b.seedfile
echo "common_name: $BSsp1c" >> $BSsp1b.seedfile
echo "provider: $BSsp1e" >> $BSsp1b.seedfile
echo "provider_version: $BSsp1b" >> $BSsp1b.seedfile
echo "release_date: $BSsp1f" >> $BSsp1b.seedfile
echo "release_name: $BSsp1b" >> $BSsp1b.seedfile
echo "source_url: $BSsp1g" >> $BSsp1b.seedfile
echo "organism_biocview: $BSsp1h" >> $BSsp1b.seedfile
echo "BSgenomeObjname: $BSsp1a" >> $BSsp1b.seedfile
echo "seqnames: $BSsp1i" >> $BSsp1b.seedfile
echo "seqs_srcdir: ${BSsp1j}_splitfasta" >> $BSsp1b.seedfile
echo '#BiocManager::install("BSgenome")' > ${BSsp1a}_forgeBSgenome.R
echo 'library("BSgenome")' >> ${BSsp1a}_forgeBSgenome.R
echo 'forgeBSgenomeDataPkg("'$BSsp1b'.seedfile")' >> ${BSsp1a}_forgeBSgenome.R

echo "Package: BSgenome.$BSsp2a.$BSsp2e.$BSsp2b" > $BSsp2b.seedfile
echo "Title: Full genome sequences for $BSsp2c (version $BSsp2b)" >> $BSsp2b.seedfile
echo "Description: Full genome sequences for $BSsp2c as provided by $BSsp2e ($BSsp2b, $BSsp2f) and stored in Biostrings objects." >> $BSsp2b.seedfile
echo "Version: $BSsp2d" >> $BSsp2b.seedfile
echo "organism: $BSsp2c" >> $BSsp2b.seedfile
echo "common_name: $BSsp2c" >> $BSsp2b.seedfile
echo "provider: $BSsp2e" >> $BSsp2b.seedfile
echo "provider_version: $BSsp2b" >> $BSsp2b.seedfile
echo "release_date: $BSsp2f" >> $BSsp2b.seedfile
echo "release_name: $BSsp2b" >> $BSsp2b.seedfile
echo "source_url: $BSsp2g" >> $BSsp2b.seedfile
echo "organism_biocview: $BSsp2h" >> $BSsp2b.seedfile
echo "BSgenomeObjname: $BSsp2a" >> $BSsp2b.seedfile
echo "seqnames: $BSsp2i" >> $BSsp2b.seedfile
echo "seqs_srcdir: ${BSsp2j}_splitfasta" >> $BSsp2b.seedfile
echo '#BiocManager::install("BSgenome")' > ${BSsp2a}_forgeBSgenome.R
echo 'library("BSgenome")' >> ${BSsp2a}_forgeBSgenome.R
echo 'forgeBSgenomeDataPkg("'$BSsp2b'.seedfile")' >> ${BSsp2a}_forgeBSgenome.R

echo "Package: BSgenome.$BSsp3a.$BSsp3e.$BSsp3b" > $BSsp3b.seedfile
echo "Title: Full genome sequences for $BSsp3c (version $BSsp3b)" >> $BSsp3b.seedfile
echo "Description: Full genome sequences for $BSsp3c as provided by $BSsp3e ($BSsp3b, $BSsp3f) and stored in Biostrings objects." >> $BSsp3b.seedfile
echo "Version: $BSsp3d" >> $BSsp3b.seedfile
echo "organism: $BSsp3c" >> $BSsp3b.seedfile
echo "common_name: $BSsp3c" >> $BSsp3b.seedfile
echo "provider: $BSsp3e" >> $BSsp3b.seedfile
echo "provider_version: $BSsp3b" >> $BSsp3b.seedfile
echo "release_date: $BSsp3f" >> $BSsp3b.seedfile
echo "release_name: $BSsp3b" >> $BSsp3b.seedfile
echo "source_url: $BSsp3g" >> $BSsp3b.seedfile
echo "organism_biocview: $BSsp3h" >> $BSsp3b.seedfile
echo "BSgenomeObjname: $BSsp3a" >> $BSsp3b.seedfile
echo "seqnames: $BSsp3i" >> $BSsp3b.seedfile
echo "seqs_srcdir: ${BSsp3j}_splitfasta" >> $BSsp3b.seedfile
echo '#BiocManager::install("BSgenome")' > ${BSsp3a}_forgeBSgenome.R
echo 'library("BSgenome")' >> ${BSsp3a}_forgeBSgenome.R
echo 'forgeBSgenomeDataPkg("'$BSsp3b'.seedfile")' >> ${BSsp3a}_forgeBSgenome.R

echo "Package: BSgenome.$BSsp4a.$BSsp4e.$BSsp4b" > $BSsp4b.seedfile
echo "Title: Full genome sequences for $BSsp4c (version $BSsp4b)" >> $BSsp4b.seedfile
echo "Description: Full genome sequences for $BSsp4c as provided by $BSsp4e ($BSsp4b, $BSsp4f) and stored in Biostrings objects." >> $BSsp4b.seedfile
echo "Version: $BSsp4d" >> $BSsp4b.seedfile
echo "organism: $BSsp4c" >> $BSsp4b.seedfile
echo "common_name: $BSsp4c" >> $BSsp4b.seedfile
echo "provider: $BSsp4e" >> $BSsp4b.seedfile
echo "provider_version: $BSsp4b" >> $BSsp4b.seedfile
echo "release_date: $BSsp4f" >> $BSsp4b.seedfile
echo "release_name: $BSsp4b" >> $BSsp4b.seedfile
echo "source_url: $BSsp4g" >> $BSsp4b.seedfile
echo "organism_biocview: $BSsp4h" >> $BSsp4b.seedfile
echo "BSgenomeObjname: $BSsp4a" >> $BSsp4b.seedfile
echo "seqnames: $BSsp4i" >> $BSsp4b.seedfile
echo "seqs_srcdir: ${BSsp4j}_splitfasta" >> $BSsp4b.seedfile
echo '#BiocManager::install("BSgenome")' > ${BSsp4a}_forgeBSgenome.R
echo 'library("BSgenome")' >> ${BSsp4a}_forgeBSgenome.R
echo 'forgeBSgenomeDataPkg("'$BSsp4b'.seedfile")' >> ${BSsp4a}_forgeBSgenome.R

echo "Package: BSgenome.$BSsp5a.$BSsp5e.$BSsp5b" > $BSsp5b.seedfile
echo "Title: Full genome sequences for $BSsp5c (version $BSsp5b)" >> $BSsp5b.seedfile
echo "Description: Full genome sequences for $BSsp5c as provided by $BSsp5e ($BSsp5b, $BSsp5f) and stored in Biostrings objects." >> $BSsp5b.seedfile
echo "Version: $BSsp5d" >> $BSsp5b.seedfile
echo "organism: $BSsp5c" >> $BSsp5b.seedfile
echo "common_name: $BSsp5c" >> $BSsp5b.seedfile
echo "provider: $BSsp5e" >> $BSsp5b.seedfile
echo "provider_version: $BSsp5b" >> $BSsp5b.seedfile
echo "release_date: $BSsp5f" >> $BSsp5b.seedfile
echo "release_name: $BSsp5b" >> $BSsp5b.seedfile
echo "source_url: $BSsp5g" >> $BSsp5b.seedfile
echo "organism_biocview: $BSsp5h" >> $BSsp5b.seedfile
echo "BSgenomeObjname: $BSsp5a" >> $BSsp5b.seedfile
echo "seqnames: $BSsp5i" >> $BSsp5b.seedfile
echo "seqs_srcdir: ${BSsp5j}_splitfasta" >> $BSsp5b.seedfile
echo '#BiocManager::install("BSgenome")' > ${BSsp5a}_forgeBSgenome.R
echo 'library("BSgenome")' >> ${BSsp5a}_forgeBSgenome.R
echo 'forgeBSgenomeDataPkg("'$BSsp5b'.seedfile")' >> ${BSsp5a}_forgeBSgenome.R

echo "Package: BSgenome.$BSsp6a.$BSsp6e.$BSsp6b" > $BSsp6b.seedfile
echo "Title: Full genome sequences for $BSsp6c (version $BSsp6b)" >> $BSsp6b.seedfile
echo "Description: Full genome sequences for $BSsp6c as provided by $BSsp6e ($BSsp6b, $BSsp6f) and stored in Biostrings objects." >> $BSsp6b.seedfile
echo "Version: $BSsp6d" >> $BSsp6b.seedfile
echo "organism: $BSsp6c" >> $BSsp6b.seedfile
echo "common_name: $BSsp6c" >> $BSsp6b.seedfile
echo "provider: $BSsp6e" >> $BSsp6b.seedfile
echo "provider_version: $BSsp6b" >> $BSsp6b.seedfile
echo "release_date: $BSsp6f" >> $BSsp6b.seedfile
echo "release_name: $BSsp6b" >> $BSsp6b.seedfile
echo "source_url: $BSsp6g" >> $BSsp6b.seedfile
echo "organism_biocview: $BSsp6h" >> $BSsp6b.seedfile
echo "BSgenomeObjname: $BSsp6a" >> $BSsp6b.seedfile
echo "seqnames: $BSsp6i" >> $BSsp6b.seedfile
echo "seqs_srcdir: ${BSsp6j}_splitfasta" >> $BSsp6b.seedfile
echo '#BiocManager::install("BSgenome")' > ${BSsp6a}_forgeBSgenome.R
echo 'library("BSgenome")' >> ${BSsp6a}_forgeBSgenome.R
echo 'forgeBSgenomeDataPkg("'$BSsp6b'.seedfile")' >> ${BSsp6a}_forgeBSgenome.R

# 2aBa. Forge BS genomes
echo '#!/bin/bash -e' > 2aBa.forgeBSgenomes.sh
echo "#SBATCH -p ei-short # partition (queue)" >> 2aBa.forgeBSgenomes.sh
echo "#SBATCH -N 1 # number of nodes" >> 2aBa.forgeBSgenomes.sh
echo "#SBATCH -n 1 # number of tasks" >> 2aBa.forgeBSgenomes.sh
echo "#SBATCH --array=0-$spnumberarray" >> 2aBa.forgeBSgenomes.sh
echo "#SBATCH --mem-per-cpu 24000" >> 2aBa.forgeBSgenomes.sh
echo "#SBATCH -t 0-00:45" >> 2aBa.forgeBSgenomes.sh
echo "#SBATCH --mail-type=ALL # notifications for job done & fail" >> 2aBa.forgeBSgenomes.sh
echo "#SBATCH --mail-user=Tarang.Mehta@earlham.ac.uk # send-to address" >> 2aBa.forgeBSgenomes.sh
echo "#SBATCH -o slurm.%N.%j.out # STDOUT" >> 2aBa.forgeBSgenomes.sh
echo "#SBATCH -e slurm.%N.%j.err # STDERR" >> 2aBa.forgeBSgenomes.sh
printf '\n' >> 2aBa.forgeBSgenomes.sh
echo "source $pcre" >> 2aBa.forgeBSgenomes.sh
echo "source $r402 # source R-4.0.2" >> 2aBa.forgeBSgenomes.sh
printf '\n' >> 2aBa.forgeBSgenomes.sh
echo "ls -1 *_forgeBSgenome.R > bsgenomes # create a list of all bsgenomes Rscript files" >> 2aBa.forgeBSgenomes.sh
echo 'mapfile -t bsgenomes < bsgenomes # assign as elements to $bsgenomes variable' >> 2aBa.forgeBSgenomes.sh
printf '\n' >> 2aBa.forgeBSgenomes.sh
echo 'Rscript ${bsgenomes[${SLURM_ARRAY_TASK_ID}]} # this will forge the BS genome required to run ATACseqQC' >> 2aBa.forgeBSgenomes.sh

echo '# -- 1b. FRiP calculation has completed -- #'

echo '# -- 2aBa. Peak annotation has started: forging BSgenomes-- #'

JOBID5=$( sbatch -W --dependency=afterok:${JOBID4} 2aBa.forgeBSgenomes.sh | awk '{print $4}' ) # JOB5 depends on JOB4 completing successfully

# 2aBb. Build and install BS genomes

echo "$speciesBSgenome1" > speciesBSgenomeIDs
echo "$speciesBSgenome2" >> speciesBSgenomeIDs
echo "$speciesBSgenome3" >> speciesBSgenomeIDs
echo "$speciesBSgenome4" >> speciesBSgenomeIDs
echo "$speciesBSgenome5" >> speciesBSgenomeIDs
echo "$speciesBSgenome6" >> speciesBSgenomeIDs

echo "${speciesBSgenome1}_${BSsp1d}.tar.gz" > speciesBSgenomeIDs2
echo "${speciesBSgenome2}_${BSsp2d}.tar.gz" >> speciesBSgenomeIDs2
echo "${speciesBSgenome3}_${BSsp3d}.tar.gz" >> speciesBSgenomeIDs2
echo "${speciesBSgenome4}_${BSsp4d}.tar.gz" >> speciesBSgenomeIDs2
echo "${speciesBSgenome5}_${BSsp5d}.tar.gz" >> speciesBSgenomeIDs2
echo "${speciesBSgenome6}_${BSsp6d}.tar.gz" >> speciesBSgenomeIDs2

echo '#!/bin/bash -e' > 2aBb.buildBSgenomes.sh
echo "#SBATCH -p ei-medium # partition (queue)" >> 2aBb.buildBSgenomes.sh
echo "#SBATCH -N 1 # number of nodes" >> 2aBb.buildBSgenomes.sh
echo "#SBATCH -n 1 # number of tasks" >> 2aBb.buildBSgenomes.sh
echo "#SBATCH --array=0-$spnumberarray" >> 2aBb.buildBSgenomes.sh
echo "#SBATCH --mem-per-cpu 24000" >> 2aBb.buildBSgenomes.sh
echo "#SBATCH -t 0-04:59" >> 2aBb.buildBSgenomes.sh
echo "#SBATCH --mail-type=ALL # notifications for job done & fail" >> 2aBb.buildBSgenomes.sh
echo "#SBATCH --mail-user=Tarang.Mehta@earlham.ac.uk # send-to address" >> 2aBb.buildBSgenomes.sh
echo "#SBATCH -o slurm.%N.%j.out # STDOUT" >> 2aBb.buildBSgenomes.sh
echo "#SBATCH -e slurm.%N.%j.err # STDERR" >> 2aBb.buildBSgenomes.sh
printf '\n' >> 2aBb.buildBSgenomes.sh
echo "source $pcre" >> 2aBb.buildBSgenomes.sh
echo "source $r402 # source R-4.0.2" >> 2aBb.buildBSgenomes.sh
printf '\n' >> 2aBb.buildBSgenomes.sh
echo 'mapfile -t bsgenomesIDs < speciesBSgenomeIDs' >> 2aBb.buildBSgenomes.sh
echo 'mapfile -t bsgenomesIDs2 < speciesBSgenomeIDs2' >> 2aBb.buildBSgenomes.sh
printf '\n' >> 2aBb.buildBSgenomes.sh
echo 'R CMD build ${bsgenomesIDs[${SLURM_ARRAY_TASK_ID}]} # this will build the BSgenome' >> 2aBb.buildBSgenomes.sh
echo 'R CMD check ${bsgenomesIDs2[${SLURM_ARRAY_TASK_ID}]} # this will check the package' >> 2aBb.buildBSgenomes.sh
echo 'R CMD INSTALL ${bsgenomesIDs2[${SLURM_ARRAY_TASK_ID}]} # this will install the package for loading' >> 2aBb.buildBSgenomes.sh

echo '# -- 2aBa. Peak annotation has started: forging BSgenomes has completed -- #'

echo '# -- 2aBb. Peak annotation has started: building BSgenomes -- #'

JOBID6=$( sbatch -W --dependency=afterok:${JOBID5} 2aBb.buildBSgenomes.sh | awk '{print $4}' ) # JOB6 depends on JOB5 completing successfully


## 2aBc. Run ATACseqQC: create diagnostic plots of TSS enrichment

# 1. Get total number of samples for each species and assign to variable
sp1count=$(grep -F "$speciesid1" $prefixATAC2 | wc -l )
sp2count=$(grep -F "$speciesid2" $prefixATAC2 | wc -l )
sp3count=$(grep -F "$speciesid3" $prefixATAC2 | wc -l )
sp4count=$(grep -F "$speciesid4" $prefixATAC2 | wc -l )
sp5count=$(grep -F "$speciesid5" $prefixATAC2 | wc -l )
sp6count=$(grep -F "$speciesid6" $prefixATAC2 | wc -l )

# 2. Minus one from the total for each species for the array
sp1numberarray=$(expr $sp1count - 1)
sp2numberarray=$(expr $sp2count - 1)
sp3numberarray=$(expr $sp3count - 1)
sp4numberarray=$(expr $sp4count - 1)
sp5numberarray=$(expr $sp5count - 1)
sp6numberarray=$(expr $sp6count - 1)

# 3. Set up the array to run ATACseqQC on each sample - first prepare species specific sample ID files for iterating in array
# NOTE: The BSgenomes etc. are hardcoded when passing arguments to the Rscript e.g. $annotAcg and $speciesBSgenome6 - if running for other species then ensure to change!!!
grep -F "$speciesid1" $prefixATAC2 | cut -f2 > "$(basename "$prefixATAC2" .txt)_sp1.txt"
grep -F "$speciesid2" $prefixATAC2 | cut -f2 > "$(basename "$prefixATAC2" .txt)_sp2.txt"
grep -F "$speciesid3" $prefixATAC2 | cut -f2 > "$(basename "$prefixATAC2" .txt)_sp3.txt"
grep -F "$speciesid4" $prefixATAC2 | cut -f2 > "$(basename "$prefixATAC2" .txt)_sp4.txt"
grep -F "$speciesid5" $prefixATAC2 | cut -f2 > "$(basename "$prefixATAC2" .txt)_sp5.txt"
grep -F "$speciesid6" $prefixATAC2 | cut -f2 > "$(basename "$prefixATAC2" .txt)_sp6.txt"

echo '#!/bin/bash -e' > ${speciesid1}_$atacqcscript2
echo '#SBATCH -p ei-medium # partition (queue)' >> ${speciesid1}_$atacqcscript2
echo '#SBATCH -N 1 # number of nodes' >> ${speciesid1}_$atacqcscript2
echo '#SBATCH -n 1 # number of tasks' >> ${speciesid1}_$atacqcscript2
echo '#SBATCH --array=0-'"$sp1numberarray" >> ${speciesid1}_$atacqcscript2
echo '#SBATCH --mem-per-cpu 120000' >> ${speciesid1}_$atacqcscript2
echo '#SBATCH -t 0-23:59' >> ${speciesid1}_$atacqcscript2
echo '#SBATCH --mail-type=ALL # notifications for job done & fail' >> ${speciesid1}_$atacqcscript2
echo '#SBATCH --mail-user=Tarang.Mehta@earlham.ac.uk # send-to address' >> ${speciesid1}_$atacqcscript2
echo '#SBATCH -o slurm.%A.%a.out # STDOUT' >> ${speciesid1}_$atacqcscript2
echo '#SBATCH -e slurm.%A.%a.err # STDERR' >> ${speciesid1}_$atacqcscript2
printf '\n' >> ${speciesid1}_$atacqcscript2
echo "source $pcre" >> ${speciesid1}_$atacqcscript2
echo "source $r402 # source R-4.0.2" >> ${speciesid1}_$atacqcscript2
printf '\n' >> ${speciesid1}_$atacqcscript2
echo 'mapfile -t samples < "$(basename "'$prefixATAC2'" .txt)_sp1.txt" # assign as elements to variable' >> ${speciesid1}_$atacqcscript2
printf '\n' >> ${speciesid1}_$atacqcscript2
echo 'mkdir '$annotdir'/${samples[${SLURM_ARRAY_TASK_ID}]}' >> ${speciesid1}_$atacqcscript2
echo 'cd '$annotdir'/${samples[${SLURM_ARRAY_TASK_ID}]}' >> ${speciesid1}_$atacqcscript2
printf '\n' >> ${speciesid1}_$atacqcscript2
echo 'Rscript '$atacqcscript' '$scripts'/${samples[${SLURM_ARRAY_TASK_ID}]}/4.postalign_filt/${samples[${SLURM_ARRAY_TASK_ID}]}.nochrM.nodup.filt.bam '$annotMzg' '$annotdir'/${samples[${SLURM_ARRAY_TASK_ID}]} "${samples[${SLURM_ARRAY_TASK_ID}]}_1_PTscore.tiff" "${samples[${SLURM_ARRAY_TASK_ID}]}_2_NFRscore.tiff" '$speciesBSgenome1' "${samples[${SLURM_ARRAY_TASK_ID}]}_3_TSSscore.txt" "${samples[${SLURM_ARRAY_TASK_ID}]}_4_cumulativepercscore.tiff" "${samples[${SLURM_ARRAY_TASK_ID}]}_5_logtransformedTSSsignalheatmap.tiff" "${samples[${SLURM_ARRAY_TASK_ID}]}_6_rescaledTSSsignal.tiff"' $speciesBSgenome1a >> ${speciesid1}_$atacqcscript2

echo '#!/bin/bash -e' > ${speciesid2}_$atacqcscript2
echo '#SBATCH -p ei-medium # partition (queue)' >> ${speciesid2}_$atacqcscript2
echo '#SBATCH -N 1 # number of nodes' >> ${speciesid2}_$atacqcscript2
echo '#SBATCH -n 1 # number of tasks' >> ${speciesid2}_$atacqcscript2
echo '#SBATCH --array=0-'"$sp2numberarray" >> ${speciesid2}_$atacqcscript2
echo '#SBATCH --mem-per-cpu 120000' >> ${speciesid2}_$atacqcscript2
echo '#SBATCH -t 0-23:59' >> ${speciesid2}_$atacqcscript2
echo '#SBATCH --mail-type=ALL # notifications for job done & fail' >> ${speciesid2}_$atacqcscript2
echo '#SBATCH --mail-user=Tarang.Mehta@earlham.ac.uk # send-to address' >> ${speciesid2}_$atacqcscript2
echo '#SBATCH -o slurm.%A.%a.out # STDOUT' >> ${speciesid2}_$atacqcscript2
echo '#SBATCH -e slurm.%A.%a.err # STDERR' >> ${speciesid2}_$atacqcscript2
printf '\n' >> ${speciesid2}_$atacqcscript2
echo "source $pcre" >> ${speciesid2}_$atacqcscript2
echo "source $r402 # source R-4.0.2" >> ${speciesid2}_$atacqcscript2
printf '\n' >> ${speciesid2}_$atacqcscript2
echo 'mapfile -t samples < "$(basename "'$prefixATAC2'" .txt)_sp2.txt" # assign as elements to variable' >> ${speciesid2}_$atacqcscript2
printf '\n' >> ${speciesid2}_$atacqcscript2
echo 'mkdir '$annotdir'/${samples[${SLURM_ARRAY_TASK_ID}]}' >> ${speciesid2}_$atacqcscript2
echo 'cd '$annotdir'/${samples[${SLURM_ARRAY_TASK_ID}]}' >> ${speciesid2}_$atacqcscript2
printf '\n' >> ${speciesid2}_$atacqcscript2
echo 'Rscript '$atacqcscript' '$scripts'/${samples[${SLURM_ARRAY_TASK_ID}]}/4.postalign_filt/${samples[${SLURM_ARRAY_TASK_ID}]}.nochrM.nodup.filt.bam '$annotPng' '$annotdir'/${samples[${SLURM_ARRAY_TASK_ID}]} "${samples[${SLURM_ARRAY_TASK_ID}]}_1_PTscore.tiff" "${samples[${SLURM_ARRAY_TASK_ID}]}_2_NFRscore.tiff" '$speciesBSgenome2' "${samples[${SLURM_ARRAY_TASK_ID}]}_3_TSSscore.txt" "${samples[${SLURM_ARRAY_TASK_ID}]}_4_cumulativepercscore.tiff" "${samples[${SLURM_ARRAY_TASK_ID}]}_5_logtransformedTSSsignalheatmap.tiff" "${samples[${SLURM_ARRAY_TASK_ID}]}_6_rescaledTSSsignal.tiff"' $speciesBSgenome2a >> ${speciesid2}_$atacqcscript2

echo '#!/bin/bash -e' > ${speciesid3}_$atacqcscript2
echo '#SBATCH -p ei-medium # partition (queue)' >> ${speciesid3}_$atacqcscript2
echo '#SBATCH -N 1 # number of nodes' >> ${speciesid3}_$atacqcscript2
echo '#SBATCH -n 1 # number of tasks' >> ${speciesid3}_$atacqcscript2
echo '#SBATCH --array=0-'"$sp3numberarray" >> ${speciesid3}_$atacqcscript2
echo '#SBATCH --mem-per-cpu 120000' >> ${speciesid3}_$atacqcscript2
echo '#SBATCH -t 0-23:59' >> ${speciesid3}_$atacqcscript2
echo '#SBATCH --mail-type=ALL # notifications for job done & fail' >> ${speciesid3}_$atacqcscript2
echo '#SBATCH --mail-user=Tarang.Mehta@earlham.ac.uk # send-to address' >> ${speciesid3}_$atacqcscript2
echo '#SBATCH -o slurm.%A.%a.out # STDOUT' >> ${speciesid3}_$atacqcscript2
echo '#SBATCH -e slurm.%A.%a.err # STDERR' >> ${speciesid3}_$atacqcscript2
printf '\n' >> ${speciesid3}_$atacqcscript2
echo "source $pcre" >> ${speciesid3}_$atacqcscript2
echo "source $r402 # source R-4.0.2" >> ${speciesid3}_$atacqcscript2
printf '\n' >> ${speciesid3}_$atacqcscript2
echo 'mapfile -t samples < "$(basename "'$prefixATAC2'" .txt)_sp3.txt" # assign as elements to variable' >> ${speciesid3}_$atacqcscript2
printf '\n' >> ${speciesid3}_$atacqcscript2
echo 'mkdir '$annotdir'/${samples[${SLURM_ARRAY_TASK_ID}]}' >> ${speciesid3}_$atacqcscript2
echo 'cd '$annotdir'/${samples[${SLURM_ARRAY_TASK_ID}]}' >> ${speciesid3}_$atacqcscript2
printf '\n' >> ${speciesid3}_$atacqcscript2
echo 'Rscript '$atacqcscript' '$scripts'/${samples[${SLURM_ARRAY_TASK_ID}]}/4.postalign_filt/${samples[${SLURM_ARRAY_TASK_ID}]}.nochrM.nodup.filt.bam '$annotAbg' '$annotdir'/${samples[${SLURM_ARRAY_TASK_ID}]} "${samples[${SLURM_ARRAY_TASK_ID}]}_1_PTscore.tiff" "${samples[${SLURM_ARRAY_TASK_ID}]}_2_NFRscore.tiff" '$speciesBSgenome3' "${samples[${SLURM_ARRAY_TASK_ID}]}_3_TSSscore.txt" "${samples[${SLURM_ARRAY_TASK_ID}]}_4_cumulativepercscore.tiff" "${samples[${SLURM_ARRAY_TASK_ID}]}_5_logtransformedTSSsignalheatmap.tiff" "${samples[${SLURM_ARRAY_TASK_ID}]}_6_rescaledTSSsignal.tiff"' $speciesBSgenome3a >> ${speciesid3}_$atacqcscript2

echo '#!/bin/bash -e' > ${speciesid4}_$atacqcscript2
echo '#SBATCH -p ei-medium # partition (queue)' >> ${speciesid4}_$atacqcscript2
echo '#SBATCH -N 1 # number of nodes' >> ${speciesid4}_$atacqcscript2
echo '#SBATCH -n 1 # number of tasks' >> ${speciesid4}_$atacqcscript2
echo '#SBATCH --array=0-'"$sp4numberarray" >> ${speciesid4}_$atacqcscript2
echo '#SBATCH --mem-per-cpu 120000' >> ${speciesid4}_$atacqcscript2
echo '#SBATCH -t 0-23:59' >> ${speciesid4}_$atacqcscript2
echo '#SBATCH --mail-type=ALL # notifications for job done & fail' >> ${speciesid4}_$atacqcscript2
echo '#SBATCH --mail-user=Tarang.Mehta@earlham.ac.uk # send-to address' >> ${speciesid4}_$atacqcscript2
echo '#SBATCH -o slurm.%A.%a.out # STDOUT' >> ${speciesid4}_$atacqcscript2
echo '#SBATCH -e slurm.%A.%a.err # STDERR' >> ${speciesid4}_$atacqcscript2
printf '\n' >> ${speciesid4}_$atacqcscript2
echo "source $pcre" >> ${speciesid4}_$atacqcscript2
echo "source $r402 # source R-4.0.2" >> ${speciesid4}_$atacqcscript2
printf '\n' >> ${speciesid4}_$atacqcscript2
echo 'mapfile -t samples < "$(basename "'$prefixATAC2'" .txt)_sp4.txt" # assign as elements to variable' >> ${speciesid4}_$atacqcscript2
printf '\n' >> ${speciesid4}_$atacqcscript2
echo 'mkdir '$annotdir'/${samples[${SLURM_ARRAY_TASK_ID}]}' >> ${speciesid4}_$atacqcscript2
echo 'cd '$annotdir'/${samples[${SLURM_ARRAY_TASK_ID}]}' >> ${speciesid4}_$atacqcscript2
printf '\n' >> ${speciesid4}_$atacqcscript2
echo 'Rscript '$atacqcscript' '$scripts'/${samples[${SLURM_ARRAY_TASK_ID}]}/4.postalign_filt/${samples[${SLURM_ARRAY_TASK_ID}]}.nochrM.nodup.filt.bam '$annotNbg' '$annotdir'/${samples[${SLURM_ARRAY_TASK_ID}]} "${samples[${SLURM_ARRAY_TASK_ID}]}_1_PTscore.tiff" "${samples[${SLURM_ARRAY_TASK_ID}]}_2_NFRscore.tiff" '$speciesBSgenome4' "${samples[${SLURM_ARRAY_TASK_ID}]}_3_TSSscore.txt" "${samples[${SLURM_ARRAY_TASK_ID}]}_4_cumulativepercscore.tiff" "${samples[${SLURM_ARRAY_TASK_ID}]}_5_logtransformedTSSsignalheatmap.tiff" "${samples[${SLURM_ARRAY_TASK_ID}]}_6_rescaledTSSsignal.tiff"' $speciesBSgenome4a >> ${speciesid4}_$atacqcscript2

echo '#!/bin/bash -e' > ${speciesid5}_$atacqcscript2
echo '#SBATCH -p ei-medium # partition (queue)' >> ${speciesid5}_$atacqcscript2
echo '#SBATCH -N 1 # number of nodes' >> ${speciesid5}_$atacqcscript2
echo '#SBATCH -n 1 # number of tasks' >> ${speciesid5}_$atacqcscript2
echo '#SBATCH --array=0-'"$sp5numberarray" >> ${speciesid5}_$atacqcscript2
echo '#SBATCH --mem-per-cpu 120000' >> ${speciesid5}_$atacqcscript2
echo '#SBATCH -t 0-23:59' >> ${speciesid5}_$atacqcscript2
echo '#SBATCH --mail-type=ALL # notifications for job done & fail' >> ${speciesid5}_$atacqcscript2
echo '#SBATCH --mail-user=Tarang.Mehta@earlham.ac.uk # send-to address' >> ${speciesid5}_$atacqcscript2
echo '#SBATCH -o slurm.%A.%a.out # STDOUT' >> ${speciesid5}_$atacqcscript2
echo '#SBATCH -e slurm.%A.%a.err # STDERR' >> ${speciesid5}_$atacqcscript2
printf '\n' >> ${speciesid5}_$atacqcscript2
echo "source $pcre" >> ${speciesid5}_$atacqcscript2
echo "source $r402 # source R-4.0.2" >> ${speciesid5}_$atacqcscript2
printf '\n' >> ${speciesid5}_$atacqcscript2
echo 'mapfile -t samples < "$(basename "'$prefixATAC2'" .txt)_sp5.txt" # assign as elements to variable' >> ${speciesid5}_$atacqcscript2
printf '\n' >> ${speciesid5}_$atacqcscript2
echo 'mkdir '$annotdir'/${samples[${SLURM_ARRAY_TASK_ID}]}' >> ${speciesid5}_$atacqcscript2
echo 'cd '$annotdir'/${samples[${SLURM_ARRAY_TASK_ID}]}' >> ${speciesid5}_$atacqcscript2
printf '\n' >> ${speciesid5}_$atacqcscript2
echo 'Rscript '$atacqcscript' '$scripts'/${samples[${SLURM_ARRAY_TASK_ID}]}/4.postalign_filt/${samples[${SLURM_ARRAY_TASK_ID}]}.nochrM.nodup.filt.bam '$annotOng' '$annotdir'/${samples[${SLURM_ARRAY_TASK_ID}]} "${samples[${SLURM_ARRAY_TASK_ID}]}_1_PTscore.tiff" "${samples[${SLURM_ARRAY_TASK_ID}]}_2_NFRscore.tiff" '$speciesBSgenome5' "${samples[${SLURM_ARRAY_TASK_ID}]}_3_TSSscore.txt" "${samples[${SLURM_ARRAY_TASK_ID}]}_4_cumulativepercscore.tiff" "${samples[${SLURM_ARRAY_TASK_ID}]}_5_logtransformedTSSsignalheatmap.tiff" "${samples[${SLURM_ARRAY_TASK_ID}]}_6_rescaledTSSsignal.tiff"' $speciesBSgenome5a >> ${speciesid5}_$atacqcscript2

echo '#!/bin/bash -e' > ${speciesid6}_$atacqcscript2
echo '#SBATCH -p ei-medium # partition (queue)' >> ${speciesid6}_$atacqcscript2
echo '#SBATCH -N 1 # number of nodes' >> ${speciesid6}_$atacqcscript2
echo '#SBATCH -n 1 # number of tasks' >> ${speciesid6}_$atacqcscript2
echo '#SBATCH --array=0-'"$sp6numberarray" >> ${speciesid6}_$atacqcscript2
echo '#SBATCH --mem-per-cpu 120000' >> ${speciesid6}_$atacqcscript2
echo '#SBATCH -t 0-23:59' >> ${speciesid6}_$atacqcscript2
echo '#SBATCH --mail-type=ALL # notifications for job done & fail' >> ${speciesid6}_$atacqcscript2
echo '#SBATCH --mail-user=Tarang.Mehta@earlham.ac.uk # send-to address' >> ${speciesid6}_$atacqcscript2
echo '#SBATCH -o slurm.%A.%a.out # STDOUT' >> ${speciesid6}_$atacqcscript2
echo '#SBATCH -e slurm.%A.%a.err # STDERR' >> ${speciesid6}_$atacqcscript2
printf '\n' >> ${speciesid6}_$atacqcscript2
echo "source $pcre" >> ${speciesid6}_$atacqcscript2
echo "source $r402 # source R-4.0.2" >> ${speciesid6}_$atacqcscript2
printf '\n' >> ${speciesid6}_$atacqcscript2
echo 'mapfile -t samples < "$(basename "'$prefixATAC2'" .txt)_sp6.txt" # assign as elements to variable' >> ${speciesid6}_$atacqcscript2
printf '\n' >> ${speciesid6}_$atacqcscript2
echo 'mkdir '$annotdir'/${samples[${SLURM_ARRAY_TASK_ID}]}' >> ${speciesid6}_$atacqcscript2
echo 'cd '$annotdir'/${samples[${SLURM_ARRAY_TASK_ID}]}' >> ${speciesid6}_$atacqcscript2
printf '\n' >> ${speciesid6}_$atacqcscript2
echo 'Rscript '$atacqcscript' '$scripts'/${samples[${SLURM_ARRAY_TASK_ID}]}/4.postalign_filt/${samples[${SLURM_ARRAY_TASK_ID}]}.nochrM.nodup.filt.bam '$annotAcg' '$annotdir'/${samples[${SLURM_ARRAY_TASK_ID}]} "${samples[${SLURM_ARRAY_TASK_ID}]}_1_PTscore.tiff" "${samples[${SLURM_ARRAY_TASK_ID}]}_2_NFRscore.tiff" '$speciesBSgenome6' "${samples[${SLURM_ARRAY_TASK_ID}]}_3_TSSscore.txt" "${samples[${SLURM_ARRAY_TASK_ID}]}_4_cumulativepercscore.tiff" "${samples[${SLURM_ARRAY_TASK_ID}]}_5_logtransformedTSSsignalheatmap.tiff" "${samples[${SLURM_ARRAY_TASK_ID}]}_6_rescaledTSSsignal.tiff"' $speciesBSgenome6a >> ${speciesid6}_$atacqcscript2

# # This is a while loop for each species that will check species ID etc and run ATACseqQC accordingly - problem with this is that jobs are NOT run in parallel!
# echo '#!/bin/bash -e' > ${speciesid1}_$atacqcscript2
# echo '#SBATCH -p ei-medium # partition (queue)' >> ${speciesid1}_$atacqcscript2
# echo '#SBATCH -N 1 # number of nodes' >> ${speciesid1}_$atacqcscript2
# echo '#SBATCH -n 1 # number of tasks' >> ${speciesid1}_$atacqcscript2
# echo '#SBATCH --mem-per-cpu 120000' >> ${speciesid1}_$atacqcscript2
# echo '#SBATCH -t 4-23:59' >> ${speciesid1}_$atacqcscript2
# echo '#SBATCH --mail-type=ALL # notifications for job done & fail' >> ${speciesid1}_$atacqcscript2
# echo '#SBATCH --mail-user=Tarang.Mehta@earlham.ac.uk # send-to address' >> ${speciesid1}_$atacqcscript2
# echo '#SBATCH -o slurm.%N.%j.out # STDOUT' >> ${speciesid1}_$atacqcscript2
# echo '#SBATCH -e slurm.%N.%j.err # STDERR' >> ${speciesid1}_$atacqcscript2
# printf '\n' >> ${speciesid1}_$atacqcscript2
# echo "source $pcre" >> ${speciesid1}_$atacqcscript2
# echo "source $r402 # source R-4.0.2" >> ${speciesid1}_$atacqcscript2
# printf '\n' >> ${speciesid1}_$atacqcscript2
# echo 'while read i1 i2; do' >> ${speciesid1}_$atacqcscript2
# echo -e '\tif [[ "$i1" == "'$speciesid1'" ]]; then' >> ${speciesid1}_$atacqcscript2
# echo -e '\t\tmkdir '$annotdir'/$i2' >> ${speciesid1}_$atacqcscript2
# echo -e '\t\tcd '$annotdir'/$i2' >> ${speciesid1}_$atacqcscript2
# echo -e '\t\tRscript '$atacqcscript' '$scripts'/${i2}/4.postalign_filt/${i2}.nochrM.nodup.filt.bam '$annotMzg' '$annotdir'/${i2} "${i2}_1_PTscore.tiff" "${i2}_2_NFRscore.tiff" '$speciesBSgenome1' "${i2}_3_TSSscore.txt" "${i2}_4_cumulativepercscore.tiff" "${i2}_5_logtransformedTSSsignalheatmap.tiff" "${i2}_6_rescaledTSSsignal.tiff"' $speciesBSgenome1a >> ${speciesid1}_$atacqcscript2
# echo -e '\tfi' >> ${speciesid1}_$atacqcscript2
# echo "done < $prefixATAC2" >> ${speciesid1}_$atacqcscript2
#
# echo '#!/bin/bash -e' > ${speciesid2}_$atacqcscript2
# echo '#SBATCH -p ei-medium # partition (queue)' >> ${speciesid2}_$atacqcscript2
# echo '#SBATCH -N 1 # number of nodes' >> ${speciesid2}_$atacqcscript2
# echo '#SBATCH -n 1 # number of tasks' >> ${speciesid2}_$atacqcscript2
# echo '#SBATCH --mem-per-cpu 120000' >> ${speciesid2}_$atacqcscript2
# echo '#SBATCH -t 4-23:59' >> ${speciesid2}_$atacqcscript2
# echo '#SBATCH --mail-type=ALL # notifications for job done & fail' >> ${speciesid2}_$atacqcscript2
# echo '#SBATCH --mail-user=Tarang.Mehta@earlham.ac.uk # send-to address' >> ${speciesid2}_$atacqcscript2
# echo '#SBATCH -o slurm.%N.%j.out # STDOUT' >> ${speciesid2}_$atacqcscript2
# echo '#SBATCH -e slurm.%N.%j.err # STDERR' >> ${speciesid2}_$atacqcscript2
# printf '\n' >> ${speciesid2}_$atacqcscript2
# echo "source $pcre" >> ${speciesid2}_$atacqcscript2
# echo "source $r402 # source R-4.0.2" >> ${speciesid2}_$atacqcscript2
# printf '\n' >> ${speciesid2}_$atacqcscript2
# echo 'while read i1 i2; do' >> ${speciesid2}_$atacqcscript2
# echo -e '\tif [[ "$i1" == "'$speciesid2'" ]]; then' >> ${speciesid2}_$atacqcscript2
# echo -e '\t\tmkdir '$annotdir'/$i2' >> ${speciesid2}_$atacqcscript2
# echo -e '\t\tcd '$annotdir'/$i2' >> ${speciesid2}_$atacqcscript2
# echo -e '\t\tRscript '$atacqcscript' '$scripts'/${i2}/4.postalign_filt/${i2}.nochrM.nodup.filt.bam '$annotPng' '$annotdir'/${i2} "${i2}_1_PTscore.tiff" "${i2}_2_NFRscore.tiff" '$speciesBSgenome2' "${i2}_3_TSSscore.txt" "${i2}_4_cumulativepercscore.tiff" "${i2}_5_logtransformedTSSsignalheatmap.tiff" "${i2}_6_rescaledTSSsignal.tiff"' $speciesBSgenome2a >> ${speciesid2}_$atacqcscript2
# echo -e '\tfi' >> ${speciesid2}_$atacqcscript2
# echo "done < $prefixATAC2" >> ${speciesid2}_$atacqcscript2
#
# echo '#!/bin/bash -e' > ${speciesid3}_$atacqcscript2
# echo '#SBATCH -p ei-medium # partition (queue)' >> ${speciesid3}_$atacqcscript2
# echo '#SBATCH -N 1 # number of nodes' >> ${speciesid3}_$atacqcscript2
# echo '#SBATCH -n 1 # number of tasks' >> ${speciesid3}_$atacqcscript2
# echo '#SBATCH --mem-per-cpu 120000' >> ${speciesid3}_$atacqcscript2
# echo '#SBATCH -t 4-23:59' >> ${speciesid3}_$atacqcscript2
# echo '#SBATCH --mail-type=ALL # notifications for job done & fail' >> ${speciesid3}_$atacqcscript2
# echo '#SBATCH --mail-user=Tarang.Mehta@earlham.ac.uk # send-to address' >> ${speciesid3}_$atacqcscript2
# echo '#SBATCH -o slurm.%N.%j.out # STDOUT' >> ${speciesid3}_$atacqcscript2
# echo '#SBATCH -e slurm.%N.%j.err # STDERR' >> ${speciesid3}_$atacqcscript2
# printf '\n' >> ${speciesid3}_$atacqcscript2
# echo "source $pcre" >> ${speciesid3}_$atacqcscript2
# echo "source $r402 # source R-4.0.2" >> ${speciesid3}_$atacqcscript2
# printf '\n' >> ${speciesid3}_$atacqcscript2
# echo 'while read i1 i2; do' >> ${speciesid3}_$atacqcscript2
# echo -e '\tif [[ "$i1" == "'$speciesid3'" ]]; then' >> ${speciesid3}_$atacqcscript2
# echo -e '\t\tmkdir '$annotdir'/$i2' >> ${speciesid3}_$atacqcscript2
# echo -e '\t\tcd '$annotdir'/$i2' >> ${speciesid3}_$atacqcscript2
# echo -e '\t\tRscript '$atacqcscript' '$scripts'/${i2}/4.postalign_filt/${i2}.nochrM.nodup.filt.bam '$annotAbg' '$annotdir'/${i2} "${i2}_1_PTscore.tiff" "${i2}_2_NFRscore.tiff" '$speciesBSgenome3' "${i2}_3_TSSscore.txt" "${i2}_4_cumulativepercscore.tiff" "${i2}_5_logtransformedTSSsignalheatmap.tiff" "${i2}_6_rescaledTSSsignal.tiff"' $speciesBSgenome3a >> ${speciesid3}_$atacqcscript2
# echo -e '\tfi' >> ${speciesid3}_$atacqcscript2
# echo "done < $prefixATAC2" >> ${speciesid3}_$atacqcscript2
#
# echo '#!/bin/bash -e' > ${speciesid4}_$atacqcscript2
# echo '#SBATCH -p ei-medium # partition (queue)' >> ${speciesid4}_$atacqcscript2
# echo '#SBATCH -N 1 # number of nodes' >> ${speciesid4}_$atacqcscript2
# echo '#SBATCH -n 1 # number of tasks' >> ${speciesid4}_$atacqcscript2
# echo '#SBATCH --mem-per-cpu 120000' >> ${speciesid4}_$atacqcscript2
# echo '#SBATCH -t 4-23:59' >> ${speciesid4}_$atacqcscript2
# echo '#SBATCH --mail-type=ALL # notifications for job done & fail' >> ${speciesid4}_$atacqcscript2
# echo '#SBATCH --mail-user=Tarang.Mehta@earlham.ac.uk # send-to address' >> ${speciesid4}_$atacqcscript2
# echo '#SBATCH -o slurm.%N.%j.out # STDOUT' >> ${speciesid4}_$atacqcscript2
# echo '#SBATCH -e slurm.%N.%j.err # STDERR' >> ${speciesid4}_$atacqcscript2
# printf '\n' >> ${speciesid4}_$atacqcscript2
# echo "source $pcre" >> ${speciesid4}_$atacqcscript2
# echo "source $r402 # source R-4.0.2" >> ${speciesid4}_$atacqcscript2
# printf '\n' >> ${speciesid4}_$atacqcscript2
# echo 'while read i1 i2; do' >> ${speciesid4}_$atacqcscript2
# echo -e '\tif [[ "$i1" == "'$speciesid4'" ]]; then' >> ${speciesid4}_$atacqcscript2
# echo -e '\t\tmkdir '$annotdir'/$i2' >> ${speciesid4}_$atacqcscript2
# echo -e '\t\tcd '$annotdir'/$i2' >> ${speciesid4}_$atacqcscript2
# echo -e '\t\tRscript '$atacqcscript' '$scripts'/${i2}/4.postalign_filt/${i2}.nochrM.nodup.filt.bam '$annotNbg' '$annotdir'/${i2} "${i2}_1_PTscore.tiff" "${i2}_2_NFRscore.tiff" '$speciesBSgenome4' "${i2}_3_TSSscore.txt" "${i2}_4_cumulativepercscore.tiff" "${i2}_5_logtransformedTSSsignalheatmap.tiff" "${i2}_6_rescaledTSSsignal.tiff"' $speciesBSgenome4a >> ${speciesid4}_$atacqcscript2
# echo -e '\tfi' >> ${speciesid4}_$atacqcscript2
# echo "done < $prefixATAC2" >> ${speciesid4}_$atacqcscript2
#
# echo '#!/bin/bash -e' > ${speciesid5}_$atacqcscript2
# echo '#SBATCH -p ei-medium # partition (queue)' >> ${speciesid5}_$atacqcscript2
# echo '#SBATCH -N 1 # number of nodes' >> ${speciesid5}_$atacqcscript2
# echo '#SBATCH -n 1 # number of tasks' >> ${speciesid5}_$atacqcscript2
# echo '#SBATCH --mem-per-cpu 120000' >> ${speciesid5}_$atacqcscript2
# echo '#SBATCH -t 4-23:59' >> ${speciesid5}_$atacqcscript2
# echo '#SBATCH --mail-type=ALL # notifications for job done & fail' >> ${speciesid5}_$atacqcscript2
# echo '#SBATCH --mail-user=Tarang.Mehta@earlham.ac.uk # send-to address' >> ${speciesid5}_$atacqcscript2
# echo '#SBATCH -o slurm.%N.%j.out # STDOUT' >> ${speciesid5}_$atacqcscript2
# echo '#SBATCH -e slurm.%N.%j.err # STDERR' >> ${speciesid5}_$atacqcscript2
# printf '\n' >> ${speciesid5}_$atacqcscript2
# echo "source $pcre" >> ${speciesid5}_$atacqcscript2
# echo "source $r402 # source R-4.0.2" >> ${speciesid5}_$atacqcscript2
# printf '\n' >> ${speciesid5}_$atacqcscript2
# echo 'while read i1 i2; do' >> ${speciesid5}_$atacqcscript2
# echo -e '\tif [[ "$i1" == "'$speciesid5'" ]]; then' >> ${speciesid5}_$atacqcscript2
# echo -e '\t\tmkdir '$annotdir'/$i2' >> ${speciesid5}_$atacqcscript2
# echo -e '\t\tcd '$annotdir'/$i2' >> ${speciesid5}_$atacqcscript2
# echo -e '\t\tRscript '$atacqcscript' '$scripts'/${i2}/4.postalign_filt/${i2}.nochrM.nodup.filt.bam '$annotOng' '$annotdir'/${i2} "${i2}_1_PTscore.tiff" "${i2}_2_NFRscore.tiff" '$speciesBSgenome5' "${i2}_3_TSSscore.txt" "${i2}_4_cumulativepercscore.tiff" "${i2}_5_logtransformedTSSsignalheatmap.tiff" "${i2}_6_rescaledTSSsignal.tiff"' $speciesBSgenome5a >> ${speciesid5}_$atacqcscript2
# echo -e '\tfi' >> ${speciesid5}_$atacqcscript2
# echo "done < $prefixATAC2" >> ${speciesid5}_$atacqcscript2
#
# echo '#!/bin/bash -e' > ${speciesid6}_$atacqcscript2
# echo '#SBATCH -p ei-medium # partition (queue)' >> ${speciesid6}_$atacqcscript2
# echo '#SBATCH -N 1 # number of nodes' >> ${speciesid6}_$atacqcscript2
# echo '#SBATCH -n 1 # number of tasks' >> ${speciesid6}_$atacqcscript2
# echo '#SBATCH --mem-per-cpu 120000' >> ${speciesid6}_$atacqcscript2
# echo '#SBATCH -t 4-23:59' >> ${speciesid6}_$atacqcscript2
# echo '#SBATCH --mail-type=ALL # notifications for job done & fail' >> ${speciesid6}_$atacqcscript2
# echo '#SBATCH --mail-user=Tarang.Mehta@earlham.ac.uk # send-to address' >> ${speciesid6}_$atacqcscript2
# echo '#SBATCH -o slurm.%N.%j.out # STDOUT' >> ${speciesid6}_$atacqcscript2
# echo '#SBATCH -e slurm.%N.%j.err # STDERR' >> ${speciesid6}_$atacqcscript2
# printf '\n' >> ${speciesid6}_$atacqcscript2
# echo "source $pcre" >> ${speciesid6}_$atacqcscript2
# echo "source $r402 # source R-4.0.2" >> ${speciesid6}_$atacqcscript2
# printf '\n' >> ${speciesid6}_$atacqcscript2
# echo 'while read i1 i2; do' >> ${speciesid6}_$atacqcscript2
# echo -e '\tif [[ "$i1" == "'$speciesid6'" ]]; then' >> ${speciesid6}_$atacqcscript2
# echo -e '\t\tmkdir '$annotdir'/$i2' >> ${speciesid6}_$atacqcscript2
# echo -e '\t\tcd '$annotdir'/$i2' >> ${speciesid6}_$atacqcscript2
# echo -e '\t\tRscript '$atacqcscript' '$scripts'/${i2}/4.postalign_filt/${i2}.nochrM.nodup.filt.bam '$annotAcg' '$annotdir'/${i2} "${i2}_1_PTscore.tiff" "${i2}_2_NFRscore.tiff" '$speciesBSgenome6' "${i2}_3_TSSscore.txt" "${i2}_4_cumulativepercscore.tiff" "${i2}_5_logtransformedTSSsignalheatmap.tiff" "${i2}_6_rescaledTSSsignal.tiff"' $speciesBSgenome6a >> ${speciesid6}_$atacqcscript2
# echo -e '\tfi' >> ${speciesid6}_$atacqcscript2
# echo "done < $prefixATAC2" >> ${speciesid6}_$atacqcscript2
#
## This is a while loop for all species samples but that will take an eternity!
# echo '#!/bin/bash -e' > $atacqcscript2
# echo '#SBATCH -p ei-medium # partition (queue)' >> $atacqcscript2
# echo '#SBATCH -N 1 # number of nodes' >> $atacqcscript2
# echo '#SBATCH -n 1 # number of tasks' >> $atacqcscript2
# echo '#SBATCH --mem-per-cpu 120000' >> $atacqcscript2
# echo '#SBATCH -t 4-23:59' >> $atacqcscript2
# echo '#SBATCH --mail-type=ALL # notifications for job done & fail' >> $atacqcscript2
# echo '#SBATCH --mail-user=Tarang.Mehta@earlham.ac.uk # send-to address' >> $atacqcscript2
# echo '#SBATCH -o slurm.%N.%j.out # STDOUT' >> $atacqcscript2
# echo '#SBATCH -e slurm.%N.%j.err # STDERR' >> $atacqcscript2
# printf '\n' >> $atacqcscript2
# echo "source $pcre" >> $atacqcscript2
# echo "source $r402 # source R-4.0.2" >> $atacqcscript2
# printf '\n' >> $atacqcscript2
# echo 'while read i1 i2; do' >> $atacqcscript2
# echo -e '\tif [[ "$i1" == "'$speciesid1'" ]]; then' >> $atacqcscript2
# echo -e '\t\tmkdir '$annotdir'/$i2' >> $atacqcscript2
# echo -e '\t\tcd '$annotdir'/$i2' >> $atacqcscript2
# echo -e '\t\tRscript '$atacqcscript' '$scripts'/${i2}/4.postalign_filt/${i2}.nochrM.nodup.filt.bam '$annotMzg' '$annotdir'/${i2} "${i2}_1_PTscore.tiff" "${i2}_2_NFRscore.tiff" '$speciesBSgenome1' "${i2}_3_TSSscore.txt" "${i2}_4_cumulativepercscore.tiff" "${i2}_5_logtransformedTSSsignalheatmap.tiff" "${i2}_6_rescaledTSSsignal.tiff"' $speciesBSgenome1a >> $atacqcscript2
# echo -e '\tfi' >> $atacqcscript2
# echo -e '\tif [[ "$i1" == "'$speciesid2'" ]]; then' >> $atacqcscript2
# echo -e '\t\tmkdir '$annotdir'/$i2' >> $atacqcscript2
# echo -e '\t\tcd '$annotdir'/$i2' >> $atacqcscript2
# echo -e '\t\tRscript '$atacqcscript' '$scripts'/${i2}/4.postalign_filt/${i2}.nochrM.nodup.filt.bam '$annotPng' '$annotdir'/${i2} "${i2}_1_PTscore.tiff" "${i2}_2_NFRscore.tiff" '$speciesBSgenome2' "${i2}_3_TSSscore.txt" "${i2}_4_cumulativepercscore.tiff" "${i2}_5_logtransformedTSSsignalheatmap.tiff" "${i2}_6_rescaledTSSsignal.tiff"' $speciesBSgenome2a >> $atacqcscript2
# echo -e '\tfi' >> $atacqcscript2
# echo -e '\tif [[ "$i1" == "'$speciesid3'" ]]; then' >> $atacqcscript2
# echo -e '\t\tmkdir '$annotdir'/$i2' >> $atacqcscript2
# echo -e '\t\tcd '$annotdir'/$i2' >> $atacqcscript2
# echo -e '\t\tRscript '$atacqcscript' '$scripts'/${i2}/4.postalign_filt/${i2}.nochrM.nodup.filt.bam '$annotAbg' '$annotdir'/${i2} "${i2}_1_PTscore.tiff" "${i2}_2_NFRscore.tiff" '$speciesBSgenome3' "${i2}_3_TSSscore.txt" "${i2}_4_cumulativepercscore.tiff" "${i2}_5_logtransformedTSSsignalheatmap.tiff" "${i2}_6_rescaledTSSsignal.tiff"' $speciesBSgenome3a >> $atacqcscript2
# echo -e '\tfi' >> $atacqcscript2
# echo -e '\tif [[ "$i1" == "'$speciesid4'" ]]; then' >> $atacqcscript2
# echo -e '\t\tmkdir '$annotdir'/$i2' >> $atacqcscript2
# echo -e '\t\tcd '$annotdir'/$i2' >> $atacqcscript2
# echo -e '\t\tRscript '$atacqcscript' '$scripts'/${i2}/4.postalign_filt/${i2}.nochrM.nodup.filt.bam '$annotNbg' '$annotdir'/${i2} "${i2}_1_PTscore.tiff" "${i2}_2_NFRscore.tiff" '$speciesBSgenome4' "${i2}_3_TSSscore.txt" "${i2}_4_cumulativepercscore.tiff" "${i2}_5_logtransformedTSSsignalheatmap.tiff" "${i2}_6_rescaledTSSsignal.tiff"' $speciesBSgenome4a >> $atacqcscript2
# echo -e '\tfi' >> $atacqcscript2
# echo -e '\tif [[ "$i1" == "'$speciesid5'" ]]; then' >> $atacqcscript2
# echo -e '\t\tmkdir '$annotdir'/$i2' >> $atacqcscript2
# echo -e '\t\tcd '$annotdir'/$i2' >> $atacqcscript2
# echo -e '\t\tRscript '$atacqcscript' '$scripts'/${i2}/4.postalign_filt/${i2}.nochrM.nodup.filt.bam '$annotOng' '$annotdir'/${i2} "${i2}_1_PTscore.tiff" "${i2}_2_NFRscore.tiff" '$speciesBSgenome5' "${i2}_3_TSSscore.txt" "${i2}_4_cumulativepercscore.tiff" "${i2}_5_logtransformedTSSsignalheatmap.tiff" "${i2}_6_rescaledTSSsignal.tiff"' $speciesBSgenome5a >> $atacqcscript2
# echo -e '\tfi' >> $atacqcscript2
# echo -e '\tif [[ "$i1" == "'$speciesid6'" ]]; then' >> $atacqcscript2
# echo -e '\t\tmkdir '$annotdir'/$i2' >> $atacqcscript2
# echo -e '\t\tcd '$annotdir'/$i2' >> $atacqcscript2
# echo -e '\t\tRscript '$atacqcscript' '$scripts'/${i2}/4.postalign_filt/${i2}.nochrM.nodup.filt.bam '$annotAcg' '$annotdir'/${i2} "${i2}_1_PTscore.tiff" "${i2}_2_NFRscore.tiff" '$speciesBSgenome6' "${i2}_3_TSSscore.txt" "${i2}_4_cumulativepercscore.tiff" "${i2}_5_logtransformedTSSsignalheatmap.tiff" "${i2}_6_rescaledTSSsignal.tiff"' $speciesBSgenome6a >> $atacqcscript2
# echo -e '\tfi' >> $atacqcscript2
# echo "done < $prefixATAC2" >> $atacqcscript2

# i = args[1] # help="input *.bam file (nochrM-nodup-filtered-sorted; non-shifted!!)"),
# g = args[2] # help="input *.gtf file"),
# s = args[3] # help="path to output shifted and split BAMs - make and name path folder according to sample and tissue"),
# p = args[4] # help="output *.tiff filename for Promoter-Transcript score plot"),
# n = args[5] # help="output *.tiff filename for NFR score plot"),
# b = args[6] # help="BSgenome package dir as built in shell script e.g. BSgenome.Abur.Ensembl.AstBur1.0"),
# t = args[7] # help="output *.txt filename for TSS enrichment score summary"),
# c = args[8] # help="output *.tiff filename for cumulative percentage plot"),
# h = args[9] # help="output *.tiff filename for log-transformed signal around TSSs"),
# r = args[10] # help="output *.tiff filename for rescaled signal around TSSs")
# a = args[11] # help="BSgenome package name e.g. BSgenome.Abur.Ensembl.AstBur1.0 = Abur")


# # mkdir -p $annotdir/Ab5_L
# # Input (-i) will be nodup_filt_bam_index_file=$(echo $bam_file | sed -e 's/.bam/.nodup.filt.bam.bai/' | sed -e 's/3.Mtfilt_fragcnt/4.postalign_filt/g') # index file
# # Rscript $atacqcscript -i Ab5_L_ATAC.nochrM.nodup.filt.sorted.JH425323.1.bam -g $annotAbg -s $annotdir/Ab5_L -p Ab5_L_1_PTscore.tiff -n Ab5_L_2_NFRscore.tiff -b BSgenome.Abur.Ensembl.AstBur1.0 -t Ab5_L_3_TSSscore.txt -c Ab5_L_4_cumulativepercscore.tiff -h Ab5_L_5_logtransformedTSSsignalheatmap.tiff -r Ab5_L_6_rescaledTSSsignal.tiff
#
# ## The following is only for whether the flags are used with the 'optparser' library in $atacqcscript script
# echo '#!/bin/bash -e' > $atacqcscript2
# echo "#SBATCH -p ei-medium # partition (queue)" >> $atacqcscript2
# echo "#SBATCH -N 1 # number of nodes" >> $atacqcscript2
# echo "#SBATCH -n 1 # number of tasks" >> $atacqcscript2
# echo "#SBATCH --mem-per-cpu 60000" >> $atacqcscript2
# echo "#SBATCH -t 1-23:59" >> $atacqcscript2
# echo "#SBATCH --mail-type=ALL # notifications for job done & fail" >> $atacqcscript2
# echo "#SBATCH --mail-user=Tarang.Mehta@earlham.ac.uk # send-to address" >> $atacqcscript2
# echo "#SBATCH -o slurm.%N.%j.out # STDOUT" >> $atacqcscript2
# echo "#SBATCH -e slurm.%N.%j.err # STDERR" >> $atacqcscript2
# printf '\n' >> $atacqcscript2
# echo "source $pcre" >> $atacqcscript2
# echo "source $r402 # source R-4.0.2" >> $atacqcscript2
# printf '\n' >> $atacqcscript2
# echo 'while read -r i1 i2; do' >> $atacqcscript2
# echo -e '\tif [[ "$i1" == "'$speciesid1'" ]]; then' >> $atacqcscript2
# echo -e '\t\tmkdir '$annotdir'/$i2' >> $atacqcscript2
# echo -e '\t\tcd '$annotdir'/$i2' >> $atacqcscript2
# echo -e '\t\tRscript '$atacqcscript' -i '$scripts'/${i2}/4.postalign_filt/${i2}.nochrM.nodup.filt.sorted.bam -g '$annotMzg' -s '$annotdir'/${i2} -p "${i2}_1_PTscore.tiff" -n "${i2}_2_NFRscore.tiff" -b '$speciesBSgenome1' -t "${i2}_3_TSSscore.txt" -c "${i2}_4_cumulativepercscore.tiff" -h "${i2}_5_logtransformedTSSsignalheatmap.tiff" -r "${i2}_6_rescaledTSSsignal.tiff" -a '$speciesBSgenome1a >> $atacqcscript2
# echo -e '\tfi' >> $atacqcscript2
# echo -e '\tif [[ "$i1" == "'$speciesid2'" ]]; then' >> $atacqcscript2
# echo -e '\t\tmkdir '$annotdir'/$i2' >> $atacqcscript2
# echo -e '\t\tcd '$annotdir'/$i2' >> $atacqcscript2
# echo -e '\t\tRscript '$atacqcscript' -i '$scripts'/${i2}/4.postalign_filt/${i2}.nochrM.nodup.filt.sorted.bam -g '$annotPng' -s '$annotdir'/${i2} -p "${i2}_1_PTscore.tiff" -n "${i2}_2_NFRscore.tiff" -b '$speciesBSgenome2' -t "${i2}_3_TSSscore.txt" -c "${i2}_4_cumulativepercscore.tiff" -h "${i2}_5_logtransformedTSSsignalheatmap.tiff" -r "${i2}_6_rescaledTSSsignal.tiff" -a '$speciesBSgenome2a >> $atacqcscript2
# echo -e '\tfi' >> $atacqcscript2
# echo -e '\tif [[ "$i1" == "'$speciesid3'" ]]; then' >> $atacqcscript2
# echo -e '\t\tmkdir '$annotdir'/$i2' >> $atacqcscript2
# echo -e '\t\tcd '$annotdir'/$i2' >> $atacqcscript2
# echo -e '\t\tRscript '$atacqcscript' -i '$scripts'/${i2}/4.postalign_filt/${i2}.nochrM.nodup.filt.sorted.bam -g '$annotAbg' -s '$annotdir'/${i2} -p "${i2}_1_PTscore.tiff" -n "${i2}_2_NFRscore.tiff" -b '$speciesBSgenome3' -t "${i2}_3_TSSscore.txt" -c "${i2}_4_cumulativepercscore.tiff" -h "${i2}_5_logtransformedTSSsignalheatmap.tiff" -r "${i2}_6_rescaledTSSsignal.tiff" -a '$speciesBSgenome3a >> $atacqcscript2
# echo -e '\tfi' >> $atacqcscript2
# echo -e '\tif [[ "$i1" == "'$speciesid4'" ]]; then' >> $atacqcscript2
# echo -e '\t\tmkdir '$annotdir'/$i2' >> $atacqcscript2
# echo -e '\t\tcd '$annotdir'/$i2' >> $atacqcscript2
# echo -e '\t\tRscript '$atacqcscript' -i '$scripts'/${i2}/4.postalign_filt/${i2}.nochrM.nodup.filt.sorted.bam -g '$annotNbg' -s '$annotdir'/${i2} -p "${i2}_1_PTscore.tiff" -n "${i2}_2_NFRscore.tiff" -b '$speciesBSgenome4' -t "${i2}_3_TSSscore.txt" -c "${i2}_4_cumulativepercscore.tiff" -h "${i2}_5_logtransformedTSSsignalheatmap.tiff" -r "${i2}_6_rescaledTSSsignal.tiff" -a '$speciesBSgenome4a >> $atacqcscript2
# echo -e '\tfi' >> $atacqcscript2
# echo -e '\tif [[ "$i1" == "'$speciesid5'" ]]; then' >> $atacqcscript2
# echo -e '\t\tmkdir '$annotdir'/$i2' >> $atacqcscript2
# echo -e '\t\tcd '$annotdir'/$i2' >> $atacqcscript2
# echo -e '\t\tRscript '$atacqcscript' -i '$scripts'/${i2}/4.postalign_filt/${i2}.nochrM.nodup.filt.sorted.bam -g '$annotOng' -s '$annotdir'/${i2} -p "${i2}_1_PTscore.tiff" -n "${i2}_2_NFRscore.tiff" -b '$speciesBSgenome5' -t "${i2}_3_TSSscore.txt" -c "${i2}_4_cumulativepercscore.tiff" -h "${i2}_5_logtransformedTSSsignalheatmap.tiff" -r "${i2}_6_rescaledTSSsignal.tiff" -a '$speciesBSgenome5a >> $atacqcscript2
# echo -e '\tfi' >> $atacqcscript2
# echo -e '\tif [[ "$i1" == "'$speciesid6'" ]]; then' >> $atacqcscript2
# echo -e '\t\tmkdir '$annotdir'/$i2' >> $atacqcscript2
# echo -e '\t\tcd '$annotdir'/$i2' >> $atacqcscript2
# echo -e '\t\tRscript '$atacqcscript' -i '$scripts'/${i2}/4.postalign_filt/${i2}.nochrM.nodup.filt.sorted.bam -g '$annotAcg' -s '$annotdir'/${i2} -p "${i2}_1_PTscore.tiff" -n "${i2}_2_NFRscore.tiff" -b '$speciesBSgenome6' -t "${i2}_3_TSSscore.txt" -c "${i2}_4_cumulativepercscore.tiff" -h "${i2}_5_logtransformedTSSsignalheatmap.tiff" -r "${i2}_6_rescaledTSSsignal.tiff" -a '$speciesBSgenome6a >> $atacqcscript2
# echo -e '\tfi' >> $atacqcscript2
# echo "done < $prefixATAC2" >> $atacqcscript2
#
# # make_option(c("-i", "--input"), action="store", default=NA, type='character',
# #             help="input *.bam file (nochrM-nodup-filtered-sorted; non-shifted!!)"),
# # make_option(c("-g", "--gtf"), action="store", default=NA, type='character',
# #             help="input *.gtf file"),
# # make_option(c("-s", "--shiftbam"), action="store", default=NA, type='character',
# #             help="path to output shifted and split BAMs - make and name path folder according to sample and tissue"),
# # make_option(c("-p", "--ptp"), action="store", default=NA, type='character',
# #             help="output *.tiff filename for Promoter-Transcript score plot"),
# # make_option(c("-n", "--nfrp"), action="store", default=NA, type='character',
# #             help="output *.tiff filename for NFR score plot"),
# # make_option(c("-b", "--bsgenome"), action="store", default=NA, type='character',
# #             help="BSgenome package dir as built in shell script e.g. BSgenome.Abur.Ensembl.AstBur1.0"),
# # make_option(c("-t", "--tssscore"), action="store", default=NA, type='character',
# #             help="output *.txt filename for TSS enrichment score summary"),
# # make_option(c("-c", "--cpp"), action="store", default=NA, type='character',
# #             help="output *.tiff filename for cumulative percentage plot"),
# # make_option(c("-h", "--hmp"), action="store", default=NA, type='character',
# #             help="output *.tiff filename for log-transformed signal around TSSs"),
# # make_option(c("-r", "--rsp"), action="store", default=NA, type='character',
# #             help="output *.tiff filename for rescaled signal around TSSs")

## Above without echo is below:
# while read -r i1 i2; do
#   if [[ "$i1" == "$speciesid1" ]]; then
#     mkdir $annotdir/$i2
#     cd $annotdir/$i2
#     Rscript $atacqcscript -i $scripts/${i2}/4.postalign_filt/${i2}.nochrM.nodup.filt.sorted.bam -g $annotMzg -s $annotdir/${i2} -p "${i2}_1_PTscore.tiff" -n "${i2}_2_NFRscore.tiff" -b $speciesBSgenome1 -t "${i2}_3_TSSscore.txt" -c "${i2}_4_cumulativepercscore.tiff" -h "${i2}_5_logtransformedTSSsignalheatmap.tiff" -r "${i2}_6_rescaledTSSsignal.tiff"
#   fi
#   if [[ "$i1" == "$speciesid2" ]]; then
#     mkdir $annotdir/$i2
#     cd $annotdir/$i2
#     Rscript $atacqcscript -i $scripts/${i2}/4.postalign_filt/${i2}.nochrM.nodup.filt.sorted.bam -g $annotPng -s $annotdir/${i2} -p "${i2}_1_PTscore.tiff" -n "${i2}_2_NFRscore.tiff" -b $speciesBSgenome2 -t "${i2}_3_TSSscore.txt" -c "${i2}_4_cumulativepercscore.tiff" -h "${i2}_5_logtransformedTSSsignalheatmap.tiff" -r "${i2}_6_rescaledTSSsignal.tiff"
#   fi
#   if [[ "$i1" == "$speciesid3" ]]; then
#     mkdir $annotdir/$i2
#     cd $scripts/$i2
#     Rscript $atacqcscript -i $scripts/${i2}/4.postalign_filt/${i2}.nochrM.nodup.filt.sorted.bam -g $annotAbg -s $annotdir/${i2} -p "${i2}_1_PTscore.tiff" -n "${i2}_2_NFRscore.tiff" -b $speciesBSgenome3 -t "${i2}_3_TSSscore.txt" -c "${i2}_4_cumulativepercscore.tiff" -h "${i2}_5_logtransformedTSSsignalheatmap.tiff" -r "${i2}_6_rescaledTSSsignal.tiff"
#   fi
#   if [[ "$i1" == "$speciesid4" ]]; then
#     mkdir $annotdir/$i2
#     cd $annotdir/$i2
#     Rscript $atacqcscript -i $scripts/${i2}/4.postalign_filt/${i2}.nochrM.nodup.filt.sorted.bam -g $annotNbg -s $annotdir/${i2} -p "${i2}_1_PTscore.tiff" -n "${i2}_2_NFRscore.tiff" -b $speciesBSgenome4 -t "${i2}_3_TSSscore.txt" -c "${i2}_4_cumulativepercscore.tiff" -h "${i2}_5_logtransformedTSSsignalheatmap.tiff" -r "${i2}_6_rescaledTSSsignal.tiff"
#   fi
#   if [[ "$i1" == "$speciesid5" ]]; then
#     mkdir $annotdir/$i2
#     cd $scripts/$i2
#     Rscript $atacqcscript -i $scripts/${i2}/4.postalign_filt/${i2}.nochrM.nodup.filt.sorted.bam -g $annotOng -s $annotdir/${i2} -p "${i2}_1_PTscore.tiff" -n "${i2}_2_NFRscore.tiff" -b $speciesBSgenome5 -t "${i2}_3_TSSscore.txt" -c "${i2}_4_cumulativepercscore.tiff" -h "${i2}_5_logtransformedTSSsignalheatmap.tiff" -r "${i2}_6_rescaledTSSsignal.tiff"
#   fi
#   if [[ "$i1" == "$speciesid6" ]]; then
#     mkdir $annotdir/$i2
#     cd $annotdir/$i2
#     Rscript $atacqcscript -i $scripts/${i2}/4.postalign_filt/${i2}.nochrM.nodup.filt.sorted.bam -g $annotAcg -s $annotdir/${i2} -p "${i2}_1_PTscore.tiff" -n "${i2}_2_NFRscore.tiff" -b $speciesBSgenome6 -t "${i2}_3_TSSscore.txt" -c "${i2}_4_cumulativepercscore.tiff" -h "${i2}_5_logtransformedTSSsignalheatmap.tiff" -r "${i2}_6_rescaledTSSsignal.tiff"
#   fi
# done < $prefixATAC2 # this while loop will run ATAC script in each ATAC folder

echo '# -- 2aBb. Peak annotation has started: building BSgenomes has completed -- #'

echo '# -- 2aBc. Peak annotation has started: running ATACseqQC -- #'

# JOBID7=$( sbatch -W --dependency=afterok:${JOBID6} $atacqcscript2 | awk '{print $4}' ) # JOB7 depends on JOB6 completing successfully

# Six jobs for six species - amend the loop and obviously this based on no. of species
JOBID7a=$( sbatch --dependency=afterok:${JOBID6} ${speciesid1}_$atacqcscript2 | awk '{print $4}' ) # JOB7a depends on JOB6 completing successfully
JOBID7b=$( sbatch --dependency=afterok:${JOBID6} ${speciesid2}_$atacqcscript2 | awk '{print $4}' ) # JOB7b depends on JOB6 completing successfully
JOBID7c=$( sbatch --dependency=afterok:${JOBID6} ${speciesid3}_$atacqcscript2 | awk '{print $4}' ) # JOB7c depends on JOB6 completing successfully
JOBID7d=$( sbatch --dependency=afterok:${JOBID6} ${speciesid4}_$atacqcscript2 | awk '{print $4}' ) # JOB7d depends on JOB6 completing successfully
JOBID7e=$( sbatch --dependency=afterok:${JOBID6} ${speciesid5}_$atacqcscript2 | awk '{print $4}' ) # JOB7e depends on JOB6 completing successfully
JOBID7f=$( sbatch -W --dependency=afterok:${JOBID6} ${speciesid6}_$atacqcscript2 | awk '{print $4}' ) # JOB7f depends on JOB6 completing successfully

# Collate images/QC in one folder
mkdir ${annotdir}/QCimages

for i in *_*_ATAC/*.tiff; do
  cp $i ${annotdir}/QCimages
done

for i in $scripts/*_*_ATAC/3.Mtfilt_fragcnt/*.nochrM.fraglength.pdf; do
  cp $i ${annotdir}/QCimages
done

printf 'Sample\tMean\tCutoff\n' > ${annotdir}/QCimages/TSSscore_collated.txt
for i in *_*_ATAC/*_TSSscore.txt; do
  sample=$(cut -f1 $i | tail -1)
  mean=$(cut -f5 $i | tail -1)
  cutoff=$(cut -f8 $i | tail -1)
  echo -e $sample'\t'$mean'\t'$cutoff >> ${annotdir}/QCimages/TSSscore_collated.txt
done

## 2b. Fraction of reads in annotated regions

# Inputs:
# i. TAG-ALIGN file: ${TA_FILE} - For the tag-align files, use the $fripprefix 3 column file - col1: sampleID; col2: tagAlign input; col3: IDR peak file
# ii. Annotation BED file
awk 'OFS="\t" {if ($3=="gene") {print $1,$4-1,$5,$10,$14,$7}}' $annotMzg | tr -d '";' > $Mzgannotbed
awk 'OFS="\t" {if ($3=="gene") {print $1,$4-1,$5,$10,$14,$7}}' $annotPng | tr -d '";' > $Pngannotbed
awk 'OFS="\t" {if ($3=="gene") {print $1,$4-1,$5,$10,$14,$7}}' $annotAbg | tr -d '";' > $Abgannotbed
awk 'OFS="\t" {if ($3=="gene") {print $1,$4-1,$5,$10,$14,$7}}' $annotNbg | tr -d '";' > $Nbgannotbed
awk 'OFS="\t" {if ($3=="gene") {print $1,$4-1,$5,$10,$14,$7}}' $annotOng | tr -d '";' > $Ongannotbed
awk 'OFS="\t" {if ($3=="gene") {print $1,$4-1,$5,$10,$14,$7}}' $annotAcg | tr -d '";' > $Acgannotbed

# iii. Promoter BED file: BED file of promoter regions # need to generate new promoter regions for newer genomes

# Will prepared two scripts to 1) annotate 5kb promoters and 2) extract seqs
# However, there is an error in the first script that is corrected by the second.
# If you need promoter annotations, which are created by the first script, you will need to cap the final promoter on each scaffold based on the scaffold length.
# - ATAC_Bioinf_pipeline_v2c_part2bi.promBED_fromGeneBED.py
# input: .bed file of all genes
# output: 1. .bed of 5kb upstream regions, excluding overlapping promoters, where bidirectional – truncated to half the distance with opposing gene – this contains a known error – if the 5kb region overlaps the non-zero end of a scaffold, it will not be capped.
#         2. a log of genes excluded due to sharing the same start site and strand (relic of the old cichlid assemblies)
#
# - Cap 5kb promoters for scaffold ends
# input: .bed file of preliminary promoters above (that aren't capped at the end of scaffold)
# output: 1. .bed of 5kb upstream regions, excluding overlapping promoters, where bidirectional – truncated to half the distance with opposing gene
#         2. a log of genes excluded due to sharing the same start site and strand (relic of the old cichlid assemblies)
#
# - ATAC_Bioinf_pipeline_v2c_part2biii.promSeqs_fromBED5_stranded.py
# input: .bed produced above, genome fasta
# output: reverse complemented fasta sequences of the regions extracted above, with the last gene on scaffold error corrected for.

awk '{print $1,$2,$3,$4,$6}' OFS='\t' $Mzgannotbed > $Mzgannotbedtmp
awk '{print $1,$2,$3,$4,$6}' OFS='\t' $Pngannotbed | grep -v 'ENSPNYG00000004989' > $Pngannotbedtmp # ENSPNYG00000004970 and ENSPNYG00000004989 overlap the same scaffold, remove the shortest
awk '{print $1,$2,$3,$4,$6}' OFS='\t' $Abgannotbed | grep -v 'ENSHBUG00000015584' > $Abgannotbedtmp
awk '{print $1,$2,$3,$4,$6}' OFS='\t' $Nbgannotbed > $Nbgannotbedtmp
awk '{print $1,$2,$3,$4,$6}' OFS='\t' $Ongannotbed > $Ongannotbedtmp
awk '{print $1,$2,$3,$4,$6}' OFS='\t' $Acgannotbed > $Acgannotbedtmp

# this extracts the 5kb promoter regions (uncorrected for scaffold ends)
python ATAC_Bioinf_pipeline_v2c_part2bi.promBED_fromGeneBED.py $Mzgannotbedtmp
python ATAC_Bioinf_pipeline_v2c_part2bi.promBED_fromGeneBED.py $Pngannotbedtmp
python ATAC_Bioinf_pipeline_v2c_part2bi.promBED_fromGeneBED.py $Abgannotbedtmp
python ATAC_Bioinf_pipeline_v2c_part2bi.promBED_fromGeneBED.py $Nbgannotbedtmp
python ATAC_Bioinf_pipeline_v2c_part2bi.promBED_fromGeneBED.py $Ongannotbedtmp
python ATAC_Bioinf_pipeline_v2c_part2bi.promBED_fromGeneBED.py $Acgannotbedtmp

rm $Mzgannotbedtmp
rm $Pngannotbedtmp
rm $Abgannotbedtmp
rm $Nbgannotbedtmp
rm $Ongannotbedtmp
rm $Acgannotbedtmp

# this corrects the 5kb promoters so that they don't go over the scaffold ends, re-order cols and remove same start and end gene promoters
awk 'BEGIN{OFS="\t"}NR==FNR{a[$1]=$2;next}{if(a[$1]){print $0,a[$1];}else{print $0,"NULL";}}' $Mzgchr $Mz5kbpromannottmp | awk '{if($3 > $7){print $1,$2,$7,$4,$5,$5;}else {print $1,$2,$3,$4,$5,$5;}}' OFS='\t' | awk '{if($2>$3)print $1,$3,$2,$4,$5,$6;else print $1,$2,$3,$4,$5,$6;}' OFS='\t' | awk '{print $1,$2,$3,$5,$6,$4}' OFS='\t' | awk '$2!=$3' > $Mz5kbpromannot
awk 'BEGIN{OFS="\t"}NR==FNR{a[$1]=$2;next}{if(a[$1]){print $0,a[$1];}else{print $0,"NULL";}}' $Pngchr $Pn5kbpromannottmp | awk '{if($3 > $7){print $1,$2,$7,$4,$5,$5;}else {print $1,$2,$3,$4,$5,$5;}}' OFS='\t' | awk '{if($2>$3)print $1,$3,$2,$4,$5,$6;else print $1,$2,$3,$4,$5,$6;}' OFS='\t' | awk '{print $1,$2,$3,$5,$6,$4}' OFS='\t' | awk '$2!=$3' > $Pn5kbpromannot
awk 'BEGIN{OFS="\t"}NR==FNR{a[$1]=$2;next}{if(a[$1]){print $0,a[$1];}else{print $0,"NULL";}}' $Abgchr $Ab5kbpromannottmp | awk '{if($3 > $7){print $1,$2,$7,$4,$5,$5;}else {print $1,$2,$3,$4,$5,$5;}}' OFS='\t' | awk '{if($2>$3)print $1,$3,$2,$4,$5,$6;else print $1,$2,$3,$4,$5,$6;}' OFS='\t' | awk '{print $1,$2,$3,$5,$6,$4}' OFS='\t' | awk '$2!=$3' > $Ab5kbpromannot
awk 'BEGIN{OFS="\t"}NR==FNR{a[$1]=$2;next}{if(a[$1]){print $0,a[$1];}else{print $0,"NULL";}}' $Nbgchr $Nb5kbpromannottmp | awk '{if($3 > $7){print $1,$2,$7,$4,$5,$5;}else {print $1,$2,$3,$4,$5,$5;}}' OFS='\t' | awk '{if($2>$3)print $1,$3,$2,$4,$5,$6;else print $1,$2,$3,$4,$5,$6;}' OFS='\t' | awk '{print $1,$2,$3,$5,$6,$4}' OFS='\t' | awk '$2!=$3' > $Nb5kbpromannot
awk 'BEGIN{OFS="\t"}NR==FNR{a[$1]=$2;next}{if(a[$1]){print $0,a[$1];}else{print $0,"NULL";}}' $Ongchr $On5kbpromannottmp | awk '{if($3 > $7){print $1,$2,$7,$4,$5,$5;}else {print $1,$2,$3,$4,$5,$5;}}' OFS='\t' | awk '{if($2>$3)print $1,$3,$2,$4,$5,$6;else print $1,$2,$3,$4,$5,$6;}' OFS='\t' | awk '{print $1,$2,$3,$5,$6,$4}' OFS='\t' | awk '$2!=$3' > $On5kbpromannot
awk 'BEGIN{OFS="\t"}NR==FNR{a[$1]=$2;next}{if(a[$1]){print $0,a[$1];}else{print $0,"NULL";}}' $Acgchr $Ac5kbpromannottmp | awk '{if($3 > $7){print $1,$2,$7,$4,$5,$5;}else {print $1,$2,$3,$4,$5,$5;}}' OFS='\t' | awk '{if($2>$3)print $1,$3,$2,$4,$5,$6;else print $1,$2,$3,$4,$5,$6;}' OFS='\t' | awk '{print $1,$2,$3,$5,$6,$4}' OFS='\t' | awk '$2!=$3' > $Ac5kbpromannot

rm $Mz5kbpromannottmp
rm $Pn5kbpromannottmp
rm $Ab5kbpromannottmp
rm $Nb5kbpromannottmp
rm $On5kbpromannottmp
rm $Ac5kbpromannottmp

# this pulls out the 5kb promoter sequences
python ATAC_Bioinf_pipeline_v2c_part2biii.promSeqs_fromBED5_stranded.py $FAMzg $Mz5kbpromannot
python ATAC_Bioinf_pipeline_v2c_part2biii.promSeqs_fromBED5_stranded.py $FAPng $Pn5kbpromannot
python ATAC_Bioinf_pipeline_v2c_part2biii.promSeqs_fromBED5_stranded.py $FAAbg $Ab5kbpromannot
python ATAC_Bioinf_pipeline_v2c_part2biii.promSeqs_fromBED5_stranded.py $FANbg $Nb5kbpromannot
python ATAC_Bioinf_pipeline_v2c_part2biii.promSeqs_fromBED5_stranded.py $FAOng $On5kbpromannot
python ATAC_Bioinf_pipeline_v2c_part2biii.promSeqs_fromBED5_stranded.py $FAAcg $Ac5kbpromannot

# For each annotation BED file, run fraction of reads in annotated region - run this as an array where you also output the sample ID
# for this, add the the following to $fripprefix:
  # col1 - species id e.g. Mz, Pn, etc.
  # col2 - sample id
  # col3 - tagalign path
  # remove the last col

awk -F'_' '{print $1}' $fripprefix | sed 's/1a//g' | sed 's/1b//g' | sed 's/2a//g' | sed 's/2b//g' | sed 's/3a//g' | sed 's/3b//g' | sed 's/[0-9]//g' | sed 's/Pnm/Pn/g' > $fripprefix2.tmp1 # strip all other characters to expose only species ID
awk '{print $1,$2}' OFS='\t' $fripprefix > $fripprefix2.tmp2
paste $fripprefix2.tmp1 $fripprefix2.tmp2 > $fripprefix2 # create a new file that has species ID alongside the sample ID
rm $fripprefix2.tmp1 $fripprefix2.tmp2

# iv. Get total number of samples for each species and assign to variable
sp1friarcount=$(grep -F "$speciesid1" $fripprefix2 | wc -l )
sp2friarcount=$(grep -F "$speciesid2" $fripprefix2 | wc -l )
sp3friarcount=$(grep -F "$speciesid3" $fripprefix2 | wc -l )
sp4friarcount=$(grep -F "$speciesid4" $fripprefix2 | wc -l )
sp5friarcount=$(grep -F "$speciesid5" $fripprefix2 | wc -l )
sp6friarcount=$(grep -F "$speciesid6" $fripprefix2 | wc -l )

# v. Minus one from the total for each species for the array
sp1numberfriararray=$(expr $sp1friarcount - 1)
sp2numberfriararray=$(expr $sp2friarcount - 1)
sp3numberfriararray=$(expr $sp3friarcount - 1)
sp4numberfriararray=$(expr $sp4friarcount - 1)
sp5numberfriararray=$(expr $sp5friarcount - 1)
sp6numberfriararray=$(expr $sp6friarcount - 1)

# vi. Set up the array to run friar on each sample - first prepare species specific sample ID files for iterating in array
grep -F "$speciesid1" $fripprefix2 | cut -f2 > "$(basename "$fripprefix2" .txt)_sp1.txt"
grep -F "$speciesid2" $fripprefix2 | cut -f2 > "$(basename "$fripprefix2" .txt)_sp2.txt"
grep -F "$speciesid3" $fripprefix2 | cut -f2 > "$(basename "$fripprefix2" .txt)_sp3.txt"
grep -F "$speciesid4" $fripprefix2 | cut -f2 > "$(basename "$fripprefix2" .txt)_sp4.txt"
grep -F "$speciesid5" $fripprefix2 | cut -f2 > "$(basename "$fripprefix2" .txt)_sp5.txt"
grep -F "$speciesid6" $fripprefix2 | cut -f2 > "$(basename "$fripprefix2" .txt)_sp6.txt"

# vii. run the array for calculating fraction of reads in annotated regions
echo '#!/bin/bash -e' > ${speciesid1}_$friarscript
echo '#SBATCH -p ei-short # partition (queue)' >> ${speciesid1}_$friarscript
echo '#SBATCH -N 1 # number of nodes' >> ${speciesid1}_$friarscript
echo '#SBATCH -n 1 # number of tasks' >> ${speciesid1}_$friarscript
echo '#SBATCH --array=0-'"$sp1numberfriararray" >> ${speciesid1}_$friarscript
echo '#SBATCH --mem-per-cpu 28000' >> ${speciesid1}_$friarscript
echo '#SBATCH -t 0-00:45' >> ${speciesid1}_$friarscript
echo '#SBATCH --mail-type=ALL # notifications for job done & fail' >> ${speciesid1}_$friarscript
echo '#SBATCH --mail-user=Tarang.Mehta@earlham.ac.uk # send-to address' >> ${speciesid1}_$friarscript
echo '#SBATCH -o slurm.%A.%a.out # STDOUT' >> ${speciesid1}_$friarscript
echo '#SBATCH -e slurm.%A.%a.err # STDERR' >> ${speciesid1}_$friarscript
printf '\n' >> ${speciesid1}_$friarscript
echo 'source bedtools-2.26.0' >> ${speciesid1}_$friarscript
printf '\n' >> ${speciesid1}_$friarscript
echo '# output is sample id, gene fraction, promoter fraction' >> ${speciesid1}_$friarscript
printf '\n' >> ${speciesid1}_$friarscript
echo 'mapfile -t samples < "$(basename "'$fripprefix2'" .txt)_sp1.txt" # assign as elements to variable' >> ${speciesid1}_$friarscript
printf '\n' >> ${speciesid1}_$friarscript
echo "cd ${annotdir}/"'${samples[${SLURM_ARRAY_TASK_ID}]}' >> ${speciesid1}_$friarscript
echo 'total=$(zcat '"${scripts}"'/${samples[${SLURM_ARRAY_TASK_ID}]}/5.peak_calling/${samples[${SLURM_ARRAY_TASK_ID}]}.tn5.tagAlign.gz | wc -l)' >> ${speciesid1}_$friarscript
echo 'genefr=$(bedtools sort -i '"$Mzgannotbed"' | bedtools merge -i stdin | bedtools intersect -u -nonamecheck -a '"${scripts}"'/${samples[${SLURM_ARRAY_TASK_ID}]}/5.peak_calling/${samples[${SLURM_ARRAY_TASK_ID}]}.tn5.tagAlign.gz -b stdin | wc -l)' >> ${speciesid1}_$friarscript
echo 'geneperc=$(perl -E "say ${genefr}/${total}*100")' >> ${speciesid1}_$friarscript
echo 'promoterfr=$(bedtools sort -i '"$Mz5kbpromannot"' | bedtools merge -i stdin | bedtools intersect -u -nonamecheck -a '"${scripts}"'/${samples[${SLURM_ARRAY_TASK_ID}]}/5.peak_calling/${samples[${SLURM_ARRAY_TASK_ID}]}.tn5.tagAlign.gz -b stdin | wc -l)' >> ${speciesid1}_$friarscript
echo 'promperc=$(perl -E "say ${promoterfr}/${total}*100")' >> ${speciesid1}_$friarscript
echo 'echo -e ${samples[${SLURM_ARRAY_TASK_ID}]}'"'\t'"'$total'"'\t'"'$genefr'"'\t'"'$geneperc'"'\t'"'$promoterfr'"'\t'"'$promperc > fraction_of_reads_in_annotatedregions.txt' >> ${speciesid1}_$friarscript

echo '#!/bin/bash -e' > ${speciesid2}_$friarscript
echo '#SBATCH -p ei-short # partition (queue)' >> ${speciesid2}_$friarscript
echo '#SBATCH -N 1 # number of nodes' >> ${speciesid2}_$friarscript
echo '#SBATCH -n 1 # number of tasks' >> ${speciesid2}_$friarscript
echo '#SBATCH --array=0-'"$sp2numberfriararray" >> ${speciesid2}_$friarscript
echo '#SBATCH --mem-per-cpu 28000' >> ${speciesid2}_$friarscript
echo '#SBATCH -t 0-00:45' >> ${speciesid2}_$friarscript
echo '#SBATCH --mail-type=ALL # notifications for job done & fail' >> ${speciesid2}_$friarscript
echo '#SBATCH --mail-user=Tarang.Mehta@earlham.ac.uk # send-to address' >> ${speciesid2}_$friarscript
echo '#SBATCH -o slurm.%A.%a.out # STDOUT' >> ${speciesid2}_$friarscript
echo '#SBATCH -e slurm.%A.%a.err # STDERR' >> ${speciesid2}_$friarscript
printf '\n' >> ${speciesid2}_$friarscript
echo 'source bedtools-2.26.0' >> ${speciesid2}_$friarscript
printf '\n' >> ${speciesid2}_$friarscript
echo '# output is sample id, gene fraction, promoter fraction' >> ${speciesid2}_$friarscript
printf '\n' >> ${speciesid2}_$friarscript
echo 'mapfile -t samples < "$(basename "'$fripprefix2'" .txt)_sp2.txt" # assign as elements to variable' >> ${speciesid2}_$friarscript
printf '\n' >> ${speciesid2}_$friarscript
echo "cd ${annotdir}/"'${samples[${SLURM_ARRAY_TASK_ID}]}' >> ${speciesid2}_$friarscript
echo 'total=$(zcat '"${scripts}"'/${samples[${SLURM_ARRAY_TASK_ID}]}/5.peak_calling/${samples[${SLURM_ARRAY_TASK_ID}]}.tn5.tagAlign.gz | wc -l)' >> ${speciesid2}_$friarscript
echo 'genefr=$(bedtools sort -i '"$Pngannotbed"' | bedtools merge -i stdin | bedtools intersect -u -nonamecheck -a '"${scripts}"'/${samples[${SLURM_ARRAY_TASK_ID}]}/5.peak_calling/${samples[${SLURM_ARRAY_TASK_ID}]}.tn5.tagAlign.gz -b stdin | wc -l)' >> ${speciesid2}_$friarscript
echo 'geneperc=$(perl -E "say ${genefr}/${total}*100")' >> ${speciesid2}_$friarscript
echo 'promoterfr=$(bedtools sort -i '"$Pn5kbpromannot"' | bedtools merge -i stdin | bedtools intersect -u -nonamecheck -a '"${scripts}"'/${samples[${SLURM_ARRAY_TASK_ID}]}/5.peak_calling/${samples[${SLURM_ARRAY_TASK_ID}]}.tn5.tagAlign.gz -b stdin | wc -l)' >> ${speciesid2}_$friarscript
echo 'promperc=$(perl -E "say ${promoterfr}/${total}*100")' >> ${speciesid2}_$friarscript
echo 'echo -e ${samples[${SLURM_ARRAY_TASK_ID}]}'"'\t'"'$total'"'\t'"'$genefr'"'\t'"'$geneperc'"'\t'"'$promoterfr'"'\t'"'$promperc > fraction_of_reads_in_annotatedregions.txt' >> ${speciesid2}_$friarscript

echo '#!/bin/bash -e' > ${speciesid3}_$friarscript
echo '#SBATCH -p ei-short # partition (queue)' >> ${speciesid3}_$friarscript
echo '#SBATCH -N 1 # number of nodes' >> ${speciesid3}_$friarscript
echo '#SBATCH -n 1 # number of tasks' >> ${speciesid3}_$friarscript
echo '#SBATCH --array=0-'"$sp3numberfriararray" >> ${speciesid3}_$friarscript
echo '#SBATCH --mem-per-cpu 28000' >> ${speciesid3}_$friarscript
echo '#SBATCH -t 0-00:45' >> ${speciesid3}_$friarscript
echo '#SBATCH --mail-type=ALL # notifications for job done & fail' >> ${speciesid3}_$friarscript
echo '#SBATCH --mail-user=Tarang.Mehta@earlham.ac.uk # send-to address' >> ${speciesid3}_$friarscript
echo '#SBATCH -o slurm.%A.%a.out # STDOUT' >> ${speciesid3}_$friarscript
echo '#SBATCH -e slurm.%A.%a.err # STDERR' >> ${speciesid3}_$friarscript
printf '\n' >> ${speciesid3}_$friarscript
echo 'source bedtools-2.26.0' >> ${speciesid3}_$friarscript
printf '\n' >> ${speciesid3}_$friarscript
echo '# output is sample id, gene fraction, promoter fraction' >> ${speciesid3}_$friarscript
printf '\n' >> ${speciesid3}_$friarscript
echo 'mapfile -t samples < "$(basename "'$fripprefix2'" .txt)_sp3.txt" # assign as elements to variable' >> ${speciesid3}_$friarscript
printf '\n' >> ${speciesid3}_$friarscript
echo "cd ${annotdir}/"'${samples[${SLURM_ARRAY_TASK_ID}]}' >> ${speciesid3}_$friarscript
echo 'total=$(zcat '"${scripts}"'/${samples[${SLURM_ARRAY_TASK_ID}]}/5.peak_calling/${samples[${SLURM_ARRAY_TASK_ID}]}.tn5.tagAlign.gz | wc -l)' >> ${speciesid3}_$friarscript
echo 'genefr=$(bedtools sort -i '"$Abgannotbed"' | bedtools merge -i stdin | bedtools intersect -u -nonamecheck -a '"${scripts}"'/${samples[${SLURM_ARRAY_TASK_ID}]}/5.peak_calling/${samples[${SLURM_ARRAY_TASK_ID}]}.tn5.tagAlign.gz -b stdin | wc -l)' >> ${speciesid3}_$friarscript
echo 'geneperc=$(perl -E "say ${genefr}/${total}*100")' >> ${speciesid3}_$friarscript
echo 'promoterfr=$(bedtools sort -i '"$Ab5kbpromannot"' | bedtools merge -i stdin | bedtools intersect -u -nonamecheck -a '"${scripts}"'/${samples[${SLURM_ARRAY_TASK_ID}]}/5.peak_calling/${samples[${SLURM_ARRAY_TASK_ID}]}.tn5.tagAlign.gz -b stdin | wc -l)' >> ${speciesid3}_$friarscript
echo 'promperc=$(perl -E "say ${promoterfr}/${total}*100")' >> ${speciesid3}_$friarscript
echo 'echo -e ${samples[${SLURM_ARRAY_TASK_ID}]}'"'\t'"'$total'"'\t'"'$genefr'"'\t'"'$geneperc'"'\t'"'$promoterfr'"'\t'"'$promperc > fraction_of_reads_in_annotatedregions.txt' >> ${speciesid3}_$friarscript

echo '#!/bin/bash -e' > ${speciesid4}_$friarscript
echo '#SBATCH -p ei-short # partition (queue)' >> ${speciesid4}_$friarscript
echo '#SBATCH -N 1 # number of nodes' >> ${speciesid4}_$friarscript
echo '#SBATCH -n 1 # number of tasks' >> ${speciesid4}_$friarscript
echo '#SBATCH --array=0-'"$sp4numberfriararray" >> ${speciesid4}_$friarscript
echo '#SBATCH --mem-per-cpu 28000' >> ${speciesid4}_$friarscript
echo '#SBATCH -t 0-00:45' >> ${speciesid4}_$friarscript
echo '#SBATCH --mail-type=ALL # notifications for job done & fail' >> ${speciesid4}_$friarscript
echo '#SBATCH --mail-user=Tarang.Mehta@earlham.ac.uk # send-to address' >> ${speciesid4}_$friarscript
echo '#SBATCH -o slurm.%A.%a.out # STDOUT' >> ${speciesid4}_$friarscript
echo '#SBATCH -e slurm.%A.%a.err # STDERR' >> ${speciesid4}_$friarscript
printf '\n' >> ${speciesid4}_$friarscript
echo 'source bedtools-2.26.0' >> ${speciesid4}_$friarscript
printf '\n' >> ${speciesid4}_$friarscript
echo '# output is sample id, gene fraction, promoter fraction' >> ${speciesid4}_$friarscript
printf '\n' >> ${speciesid4}_$friarscript
echo 'mapfile -t samples < "$(basename "'$fripprefix2'" .txt)_sp4.txt" # assign as elements to variable' >> ${speciesid4}_$friarscript
printf '\n' >> ${speciesid4}_$friarscript
echo "cd ${annotdir}/"'${samples[${SLURM_ARRAY_TASK_ID}]}' >> ${speciesid4}_$friarscript
echo 'total=$(zcat '"${scripts}"'/${samples[${SLURM_ARRAY_TASK_ID}]}/5.peak_calling/${samples[${SLURM_ARRAY_TASK_ID}]}.tn5.tagAlign.gz | wc -l)' >> ${speciesid4}_$friarscript
echo 'genefr=$(bedtools sort -i '"$Nbgannotbed"' | bedtools merge -i stdin | bedtools intersect -u -nonamecheck -a '"${scripts}"'/${samples[${SLURM_ARRAY_TASK_ID}]}/5.peak_calling/${samples[${SLURM_ARRAY_TASK_ID}]}.tn5.tagAlign.gz -b stdin | wc -l)' >> ${speciesid4}_$friarscript
echo 'geneperc=$(perl -E "say ${genefr}/${total}*100")' >> ${speciesid4}_$friarscript
echo 'promoterfr=$(bedtools sort -i '"$Nb5kbpromannot"' | bedtools merge -i stdin | bedtools intersect -u -nonamecheck -a '"${scripts}"'/${samples[${SLURM_ARRAY_TASK_ID}]}/5.peak_calling/${samples[${SLURM_ARRAY_TASK_ID}]}.tn5.tagAlign.gz -b stdin | wc -l)' >> ${speciesid4}_$friarscript
echo 'promperc=$(perl -E "say ${promoterfr}/${total}*100")' >> ${speciesid4}_$friarscript
echo 'echo -e ${samples[${SLURM_ARRAY_TASK_ID}]}'"'\t'"'$total'"'\t'"'$genefr'"'\t'"'$geneperc'"'\t'"'$promoterfr'"'\t'"'$promperc > fraction_of_reads_in_annotatedregions.txt' >> ${speciesid4}_$friarscript

echo '#!/bin/bash -e' > ${speciesid5}_$friarscript
echo '#SBATCH -p ei-short # partition (queue)' >> ${speciesid5}_$friarscript
echo '#SBATCH -N 1 # number of nodes' >> ${speciesid5}_$friarscript
echo '#SBATCH -n 1 # number of tasks' >> ${speciesid5}_$friarscript
echo '#SBATCH --array=0-'"$sp5numberfriararray" >> ${speciesid5}_$friarscript
echo '#SBATCH --mem-per-cpu 28000' >> ${speciesid5}_$friarscript
echo '#SBATCH -t 0-00:45' >> ${speciesid5}_$friarscript
echo '#SBATCH --mail-type=ALL # notifications for job done & fail' >> ${speciesid5}_$friarscript
echo '#SBATCH --mail-user=Tarang.Mehta@earlham.ac.uk # send-to address' >> ${speciesid5}_$friarscript
echo '#SBATCH -o slurm.%A.%a.out # STDOUT' >> ${speciesid5}_$friarscript
echo '#SBATCH -e slurm.%A.%a.err # STDERR' >> ${speciesid5}_$friarscript
printf '\n' >> ${speciesid5}_$friarscript
echo 'source bedtools-2.26.0' >> ${speciesid5}_$friarscript
printf '\n' >> ${speciesid5}_$friarscript
echo '# output is sample id, gene fraction, promoter fraction' >> ${speciesid5}_$friarscript
printf '\n' >> ${speciesid5}_$friarscript
echo 'mapfile -t samples < "$(basename "'$fripprefix2'" .txt)_sp5.txt" # assign as elements to variable' >> ${speciesid5}_$friarscript
printf '\n' >> ${speciesid5}_$friarscript
echo "cd ${annotdir}/"'${samples[${SLURM_ARRAY_TASK_ID}]}' >> ${speciesid5}_$friarscript
echo 'total=$(zcat '"${scripts}"'/${samples[${SLURM_ARRAY_TASK_ID}]}/5.peak_calling/${samples[${SLURM_ARRAY_TASK_ID}]}.tn5.tagAlign.gz | wc -l)' >> ${speciesid5}_$friarscript
echo 'genefr=$(bedtools sort -i '"$Ongannotbed"' | bedtools merge -i stdin | bedtools intersect -u -nonamecheck -a '"${scripts}"'/${samples[${SLURM_ARRAY_TASK_ID}]}/5.peak_calling/${samples[${SLURM_ARRAY_TASK_ID}]}.tn5.tagAlign.gz -b stdin | wc -l)' >> ${speciesid5}_$friarscript
echo 'geneperc=$(perl -E "say ${genefr}/${total}*100")' >> ${speciesid5}_$friarscript
echo 'promoterfr=$(bedtools sort -i '"$On5kbpromannot"' | bedtools merge -i stdin | bedtools intersect -u -nonamecheck -a '"${scripts}"'/${samples[${SLURM_ARRAY_TASK_ID}]}/5.peak_calling/${samples[${SLURM_ARRAY_TASK_ID}]}.tn5.tagAlign.gz -b stdin | wc -l)' >> ${speciesid5}_$friarscript
echo 'promperc=$(perl -E "say ${promoterfr}/${total}*100")' >> ${speciesid5}_$friarscript
echo 'echo -e ${samples[${SLURM_ARRAY_TASK_ID}]}'"'\t'"'$total'"'\t'"'$genefr'"'\t'"'$geneperc'"'\t'"'$promoterfr'"'\t'"'$promperc > fraction_of_reads_in_annotatedregions.txt' >> ${speciesid5}_$friarscript

echo '#!/bin/bash -e' > ${speciesid6}_$friarscript
echo '#SBATCH -p ei-short # partition (queue)' >> ${speciesid6}_$friarscript
echo '#SBATCH -N 1 # number of nodes' >> ${speciesid6}_$friarscript
echo '#SBATCH -n 1 # number of tasks' >> ${speciesid6}_$friarscript
echo '#SBATCH --array=0-'"$sp6numberfriararray" >> ${speciesid6}_$friarscript
echo '#SBATCH --mem-per-cpu 28000' >> ${speciesid6}_$friarscript
echo '#SBATCH -t 0-00:45' >> ${speciesid6}_$friarscript
echo '#SBATCH --mail-type=ALL # notifications for job done & fail' >> ${speciesid6}_$friarscript
echo '#SBATCH --mail-user=Tarang.Mehta@earlham.ac.uk # send-to address' >> ${speciesid6}_$friarscript
echo '#SBATCH -o slurm.%A.%a.out # STDOUT' >> ${speciesid6}_$friarscript
echo '#SBATCH -e slurm.%A.%a.err # STDERR' >> ${speciesid6}_$friarscript
printf '\n' >> ${speciesid6}_$friarscript
echo 'source bedtools-2.26.0' >> ${speciesid6}_$friarscript
printf '\n' >> ${speciesid6}_$friarscript
echo '# output is sample id, gene fraction, promoter fraction' >> ${speciesid6}_$friarscript
printf '\n' >> ${speciesid6}_$friarscript
echo 'mapfile -t samples < "$(basename "'$fripprefix2'" .txt)_sp6.txt" # assign as elements to variable' >> ${speciesid6}_$friarscript
printf '\n' >> ${speciesid6}_$friarscript
echo "cd ${annotdir}/"'${samples[${SLURM_ARRAY_TASK_ID}]}' >> ${speciesid6}_$friarscript
echo 'total=$(zcat '"${scripts}"'/${samples[${SLURM_ARRAY_TASK_ID}]}/5.peak_calling/${samples[${SLURM_ARRAY_TASK_ID}]}.tn5.tagAlign.gz | wc -l)' >> ${speciesid6}_$friarscript
echo 'genefr=$(bedtools sort -i '"$Acgannotbed"' | bedtools merge -i stdin | bedtools intersect -u -nonamecheck -a '"${scripts}"'/${samples[${SLURM_ARRAY_TASK_ID}]}/5.peak_calling/${samples[${SLURM_ARRAY_TASK_ID}]}.tn5.tagAlign.gz -b stdin | wc -l)' >> ${speciesid6}_$friarscript
echo 'geneperc=$(perl -E "say ${genefr}/${total}*100")' >> ${speciesid6}_$friarscript
echo 'promoterfr=$(bedtools sort -i '"$Ac5kbpromannot"' | bedtools merge -i stdin | bedtools intersect -u -nonamecheck -a '"${scripts}"'/${samples[${SLURM_ARRAY_TASK_ID}]}/5.peak_calling/${samples[${SLURM_ARRAY_TASK_ID}]}.tn5.tagAlign.gz -b stdin | wc -l)' >> ${speciesid6}_$friarscript
echo 'promperc=$(perl -E "say ${promoterfr}/${total}*100")' >> ${speciesid6}_$friarscript
echo 'echo -e ${samples[${SLURM_ARRAY_TASK_ID}]}'"'\t'"'$total'"'\t'"'$genefr'"'\t'"'$geneperc'"'\t'"'$promoterfr'"'\t'"'$promperc > fraction_of_reads_in_annotatedregions.txt' >> ${speciesid6}_$friarscript

# ## This is for running as a while loop - lot slower
# echo '#!/bin/bash -e' > $friarscript
# echo "#SBATCH -p ei-medium # partition (queue)" >> $friarscript
# echo "#SBATCH -N 1 # number of nodes" >> $friarscript
# echo "#SBATCH -n 1 # number of tasks" >> $friarscript
# echo "#SBATCH --mem-per-cpu 60000" >> $friarscript
# echo "#SBATCH -t 0-14:59" >> $friarscript
# echo "#SBATCH --mail-type=ALL # notifications for job done & fail" >> $friarscript
# echo "#SBATCH --mail-user=Tarang.Mehta@earlham.ac.uk # send-to address" >> $friarscript
# echo "#SBATCH -o slurm.%N.%j.out # STDOUT" >> $friarscript
# echo "#SBATCH -e slurm.%N.%j.err # STDERR" >> $friarscript
# printf '\n' >> $friarscript
# echo 'source bedtools-2.26.0' >> $friarscript
# printf '\n' >> $friarscript
# echo '# output is sample id, gene fraction, promoter fraction' >> $friarscript
# echo 'while read -r i1 i2 i3; do' >> $friarscript
# echo -e '\tif [[ "$i1" == "'$speciesid1'" ]]; then' >> $friarscript
# echo -e "\t\tcd ${annotdir}/"'$i2' >> $friarscript
# echo -e '\t\tgenefr=$(bedtools sort -i '$Mzgannotbed' | bedtools merge -i stdin | bedtools intersect -u -nonamecheck -a ${i3} -b stdin | wc -l)' >> $friarscript
# echo -e '\t\tpromoterfr=$(bedtools sort -i '$Mz5kbpromannot' | bedtools merge -i stdin | bedtools intersect -u -nonamecheck -a ${i3} -b stdin | wc -l)' >> $friarscript
# echo -e '\t\techo -e $i2'"'\t'"'$genefr'"'\t'"'$promoterfr > '"$friarout" >> $friarscript
# echo -e '\tfi' >> $friarscript
# echo -e '\tif [[ "$i1" == "'$speciesid2'" ]]; then' >> $friarscript
# echo -e "\t\tcd ${annotdir}/"'$i2' >> $friarscript
# echo -e '\t\tgenefr=$(bedtools sort -i '$Pngannotbed' | bedtools merge -i stdin | bedtools intersect -u -nonamecheck -a ${i3} -b stdin | wc -l)' >> $friarscript
# echo -e '\t\tpromoterfr=$(bedtools sort -i '$Pn5kbpromannot' | bedtools merge -i stdin | bedtools intersect -u -nonamecheck -a ${i3} -b stdin | wc -l)' >> $friarscript
# echo -e '\t\techo -e $i2'"'\t'"'$genefr'"'\t'"'$promoterfr > '"$friarout" >> $friarscript
# echo -e '\tfi' >> $friarscript
# echo -e '\tif [[ "$i1" == "'$speciesid3'" ]]; then' >> $friarscript
# echo -e "\t\tcd ${annotdir}/"'$i2' >> $friarscript
# echo -e '\t\tgenefr=$(bedtools sort -i '$Abgannotbed' | bedtools merge -i stdin | bedtools intersect -u -nonamecheck -a ${i3} -b stdin | wc -l)' >> $friarscript
# echo -e '\t\tpromoterfr=$(bedtools sort -i '$Ab5kbpromannot' | bedtools merge -i stdin | bedtools intersect -u -nonamecheck -a ${i3} -b stdin | wc -l)' >> $friarscript
# echo -e '\t\techo -e $i2'"'\t'"'$genefr'"'\t'"'$promoterfr > '"$friarout" >> $friarscript
# echo -e '\tfi' >> $friarscript
# echo -e '\tif [[ "$i1" == "'$speciesid4'" ]]; then' >> $friarscript
# echo -e "\t\tcd ${annotdir}/"'$i2' >> $friarscript
# echo -e '\t\tgenefr=$(bedtools sort -i '$Nbgannotbed' | bedtools merge -i stdin | bedtools intersect -u -nonamecheck -a ${i3} -b stdin | wc -l)' >> $friarscript
# echo -e '\t\tpromoterfr=$(bedtools sort -i '$Nb5kbpromannot' | bedtools merge -i stdin | bedtools intersect -u -nonamecheck -a ${i3} -b stdin | wc -l)' >> $friarscript
# echo -e '\t\techo -e $i2'"'\t'"'$genefr'"'\t'"'$promoterfr > '"$friarout" >> $friarscript
# echo -e '\tfi' >> $friarscript
# echo -e '\tif [[ "$i1" == "'$speciesid5'" ]]; then' >> $friarscript
# echo -e "\t\tcd ${annotdir}/"'$i2' >> $friarscript
# echo -e '\t\tgenefr=$(bedtools sort -i '$Ongannotbed' | bedtools merge -i stdin | bedtools intersect -u -nonamecheck -a ${i3} -b stdin | wc -l)' >> $friarscript
# echo -e '\t\tpromoterfr=$(bedtools sort -i '$On5kbpromannot' | bedtools merge -i stdin | bedtools intersect -u -nonamecheck -a ${i3} -b stdin | wc -l)' >> $friarscript
# echo -e '\t\techo -e $i2'"'\t'"'$genefr'"'\t'"'$promoterfr > '"$friarout" >> $friarscript
# echo -e '\tfi' >> $friarscript
# echo -e '\tif [[ "$i1" == "'$speciesid6'" ]]; then' >> $friarscript
# echo -e "\t\tcd ${annotdir}/"'$i2' >> $friarscript
# echo -e '\t\tgenefr=$(bedtools sort -i '$Acgannotbed' | bedtools merge -i stdin | bedtools intersect -u -nonamecheck -a ${i3} -b stdin | wc -l)' >> $friarscript
# echo -e '\t\tpromoterfr=$(bedtools sort -i '$Ac5kbpromannot' | bedtools merge -i stdin | bedtools intersect -u -nonamecheck -a ${i3} -b stdin | wc -l)' >> $friarscript
# echo -e '\t\techo -e $i2'"'\t'"'$genefr'"'\t'"'$promoterfr > '"$friarout" >> $friarscript
# echo -e '\tfi' >> $friarscript
# echo "done < $fripprefix2" >> $friarscript
#
## This the same while loop as above just no sbatch
# source bedtools-2.26.0
# # output is sample id, gene fraction, promoter fraction
# while read -r i1 i2 i3; do
#   if [[ "$i1" == "$speciesid1" ]]; then
#     cd ${annotdir}/$i2
#     genefr=$(bedtools sort -i $Mzgannotbed | bedtools merge -i stdin | bedtools intersect -u -nonamecheck -a ${i3} -b stdin | wc -l)
#     promoterfr=$(bedtools sort -i $Mz5kbpromannot | bedtools merge -i stdin | bedtools intersect -u -nonamecheck -a ${i3} -b stdin | wc -l)
#     echo -e $i2'\t'$genefr'\t'$promoterfr > $friarout
#   fi
#   if [[ "$i1" == "$speciesid2" ]]; then
#     cd ${annotdir}/$i2
#     genefr=$(bedtools sort -i $Pngannotbed | bedtools merge -i stdin | bedtools intersect -u -nonamecheck -a ${i3} -b stdin | wc -l)
#     promoterfr=$(bedtools sort -i $Pn5kbpromannot | bedtools merge -i stdin | bedtools intersect -u -nonamecheck -a ${i3} -b stdin | wc -l)
#     echo -e $i2'\t'$genefr'\t'$promoterfr > $friarout
#   fi
#   if [[ "$i1" == "$speciesid3" ]]; then
#     cd ${annotdir}/$i2
#     genefr=$(bedtools sort -i $Abgannotbed | bedtools merge -i stdin | bedtools intersect -u -nonamecheck -a ${i3} -b stdin | wc -l)
#     promoterfr=$(bedtools sort -i $Ab5kbpromannot | bedtools merge -i stdin | bedtools intersect -u -nonamecheck -a ${i3} -b stdin | wc -l)
#     echo -e $i2'\t'$genefr'\t'$promoterfr > $friarout
#   fi
#   if [[ "$i1" == "$speciesid4" ]]; then
#     cd ${annotdir}/$i2
#     genefr=$(bedtools sort -i $Nbgannotbed | bedtools merge -i stdin | bedtools intersect -u -nonamecheck -a ${i3} -b stdin | wc -l)
#     promoterfr=$(bedtools sort -i $Nb5kbpromannot | bedtools merge -i stdin | bedtools intersect -u -nonamecheck -a ${i3} -b stdin | wc -l)
#     echo -e $i2'\t'$genefr'\t'$promoterfr > $friarout
#   fi
#   if [[ "$i1" == "$speciesid5" ]]; then
#     cd ${annotdir}/$i2
#     genefr=$(bedtools sort -i $Ongannotbed | bedtools merge -i stdin | bedtools intersect -u -nonamecheck -a ${i3} -b stdin | wc -l)
#     promoterfr=$(bedtools sort -i $On5kbpromannot | bedtools merge -i stdin | bedtools intersect -u -nonamecheck -a ${i3} -b stdin | wc -l)
#     echo -e $i2'\t'$genefr'\t'$promoterfr > $friarout
#   fi
#   if [[ "$i1" == "$speciesid6" ]]; then
#     cd ${annotdir}/$i2
#     genefr=$(bedtools sort -i $Acgannotbed | bedtools merge -i stdin | bedtools intersect -u -nonamecheck -a ${i3} -b stdin | wc -l)
#     promoterfr=$(bedtools sort -i $Ac5kbpromannot | bedtools merge -i stdin | bedtools intersect -u -nonamecheck -a ${i3} -b stdin | wc -l)
#     echo -e $i2'\t'$genefr'\t'$promoterfr > $friarout
#   fi
# done < $fripprefix2

echo '# -- 2aBc. Peak annotation has completed: ATACseqQC completed -- #'

echo '# -- 2b. Fraction of Reads in annotated regions has started -- #'

# JOBID8=$( sbatch -W --dependency=afterok:${JOBID7} $friarscript | awk '{print $4}' ) # JOB8 depends on JOB7 completing successfully

JOBID8a=$( sbatch --dependency=afterok:${JOBID7f} ${speciesid1}_$friarscript | awk '{print $4}' ) # JOB8a depends on JOB7f completing successfully
JOBID8b=$( sbatch --dependency=afterok:${JOBID7f} ${speciesid2}_$friarscript | awk '{print $4}' ) # JOB8b depends on JOB7f completing successfully
JOBID8c=$( sbatch --dependency=afterok:${JOBID7f} ${speciesid3}_$friarscript | awk '{print $4}' ) # JOB8c depends on JOB7f completing successfully
JOBID8d=$( sbatch --dependency=afterok:${JOBID7f} ${speciesid4}_$friarscript | awk '{print $4}' ) # JOB8d depends on JOB7f completing successfully
JOBID8e=$( sbatch --dependency=afterok:${JOBID7f} ${speciesid5}_$friarscript | awk '{print $4}' ) # JOB8e depends on JOB7f completing successfully
JOBID8f=$( sbatch -W --dependency=afterok:${JOBID7f} ${speciesid6}_$friarscript | awk '{print $4}' ) # JOB8f depends on JOB7f completing successfully

# viii. collate all the fraction of reads in annotated regions and move to QC folder
printf 'sample\ttotal_peaks\tgene_fraction\tgene_perc\tpromoter_fraction\tpromoter_perc\n' > ${annotdir}/QCimages/fraction_of_reads_in_annotatedregions_collated.txt
for i in *_*_ATAC/fraction_of_reads_in_annotatedregions.txt; do j=$(cat $i); echo $j | sed 's| |\t|g' >> ${annotdir}/QCimages/fraction_of_reads_in_annotatedregions_collated.txt; done

################################################################################################################

### 3. TF footprinting and creation of signal tracks

# Signal tracks are generated from BAM file (Raw) and bias corrected by HINT-ATAC
# This is rolled in with TF footprinting using HINT-ATAC, see this: https://www.regulatory-genomics.org/hint/tutorial/

# HINT-ATAC installed by installing RGT - Regulatory Genomics Toolbox: https://github.com/CostaLab/reg-gen
# install locally as config files need amending and other files need adding to the installation directory
# source ~/.bash_profile
# source ~/.bashrc
# ml gcc
# ml zlib
# pip install --user cython numpy scipy
# pip install --user RGT --no-binary RGT
# conda install -c bioconda pybigwig
## Local installations of RGT are here:
# /hpc-home/mehtat/.local/bin/bedGraphToBigWig
# /hpc-home/mehtat/.local/bin/bedToBigBed
# /hpc-home/mehtat/.local/bin/bigBedToBed
# /hpc-home/mehtat/.local/bin/bigWigMerge
# /hpc-home/mehtat/.local/bin/rgt-TDF
# /hpc-home/mehtat/.local/bin/rgt-THOR
# /hpc-home/mehtat/.local/bin/rgt-filterVCF
# /hpc-home/mehtat/.local/bin/rgt-hint
# /hpc-home/mehtat/.local/bin/rgt-motifanalysis
# /hpc-home/mehtat/.local/bin/rgt-viz
# /hpc-home/mehtat/.local/bin/wigToBigWig
# /hpc-home/mehtat/.local/lib/python3.7/site-packages/RGT-0.13.0-py3.7.egg-info
# /hpc-home/mehtat/.local/lib/python3.7/site-packages/rgt

# 1. Customise RGT data folder and data.config.user file for own genome files etc.: http://www.regulatory-genomics.org/rgt/rgt-data-folder/

# mkdir -p $tffprdir
cd $tffprdir

# A. For each genome, the following is required:
# Aa. chromosome size files - generated at top

# bioawk -c fastx '{ print $name, length($seq) }' < $AbgFA | awk '{print $1,$2}' OFS="\t" > $Abgchr
# bioawk -c fastx '{ print $name, length($seq) }' < $MzgFA | awk '{print $1,$2}' OFS="\t" > $Mzgchr
# bioawk -c fastx '{ print $name, length($seq) }' < $PngFA | awk '{print $1,$2}' OFS="\t" > $Pngchr
# bioawk -c fastx '{ print $name, length($seq) }' < $NbgFA | awk '{print $1,$2}' OFS="\t" > $Nbgchr
# bioawk -c fastx '{ print $name, length($seq) }' < $OngFA | awk '{print $1,$2}' OFS="\t" > $Ongchr
# bioawk -c fastx '{ print $name, length($seq) }' < $AcgFA | awk '{print $1,$2}' OFS="\t" > $Acgchr

# Ab. Two gene regions file in bed format
## 1. For the genes_Gencode file use ensemblIDS
while read -r b; do
  cat ${b} | awk 'OFS="\t" {if ($3=="gene") {print $1,$4-1,$5,$10,".",$7}}' | tr -d '";' > $(echo "${b}" | sed 's/101.gtf/101.generegions_Gencode.bed/g')
done < $antfiles

# cat $annotAbg | awk 'OFS="\t" {if ($3=="gene") {print $1,$4-1,$5,$10,".",$7}}' | tr -d '";' > $AbggenGC
# cat $annotMzg | awk 'OFS="\t" {if ($3=="gene") {print $1,$4-1,$5,$10,".",$7}}' | tr -d '";' > $MzggenGC
# cat $annotPng | awk 'OFS="\t" {if ($3=="gene") {print $1,$4-1,$5,$10,".",$7}}' | tr -d '";' > $PnggenGC
# cat $annotNbg | awk 'OFS="\t" {if ($3=="gene") {print $1,$4-1,$5,$10,".",$7}}' | tr -d '";' > $NbggenGC
# cat $annotOng | awk 'OFS="\t" {if ($3=="gene") {print $1,$4-1,$5,$10,".",$7}}' | tr -d '";' > $OnggenGC
# cat $annotAcg | awk 'OFS="\t" {if ($3=="gene") {print $1,$4-1,$5,$10,".",$7}}' | tr -d '";' > $AcggenGC

## 2. For the genes_RefSeq file use gene symbol
while read -r b; do
  cat ${b} | awk 'OFS="\t" {if ($3=="gene") {print $1,$4-1,$5,$14,".",$7}}' | tr -d '";' | sed 's/ensembl/NA/g' > $(echo "${b}" | sed 's/101.gtf/101.generegions_RefSeq.bed/g')
done < $antfiles

# cat $annotAbg | awk 'OFS="\t" {if ($3=="gene") {print $1,$4-1,$5,$14,".",$7}}' | tr -d '";' | sed 's/ensembl/NA/g' > $AbggenRS
# cat $annotMzg | awk 'OFS="\t" {if ($3=="gene") {print $1,$4-1,$5,$14,".",$7}}' | tr -d '";' | sed 's/ensembl/NA/g' > $MzggenRS
# cat $annotPng | awk 'OFS="\t" {if ($3=="gene") {print $1,$4-1,$5,$14,".",$7}}' | tr -d '";' | sed 's/ensembl/NA/g' > $PnggenRS
# cat $annotNbg | awk 'OFS="\t" {if ($3=="gene") {print $1,$4-1,$5,$14,".",$7}}' | tr -d '";' | sed 's/ensembl/NA/g' > $NbggenRS
# cat $annotOng | awk 'OFS="\t" {if ($3=="gene") {print $1,$4-1,$5,$14,".",$7}}' | tr -d '";' | sed 's/ensembl/NA/g' > $OnggenRS
# cat $annotAcg | awk 'OFS="\t" {if ($3=="gene") {print $1,$4-1,$5,$14,".",$7}}' | tr -d '";' | sed 's/ensembl/NA/g' > $AcggenRS

# Ac. gene alias file in text format - prepare from the gtf and BioMart

# Ac-1. awk from gtf to create a 2 colum file; col1=ensemblID, col2=gene_symbol (NA if 'ensembl' as symbol)- $file1
printf 'ensembl_gene_id\tensembl_gene_symbol\n' > tmpgenealias_header.txt
while read -r c; do
# for i in "$Mzgannot" "$Pngannot" "$Abgannot" "$Nbgannot" "$Ongannot"; do
  cat ${c} | awk 'OFS="\t" {if ($3=="gene") {print $0}}' |
  awk '{print $10,$14}' OFS='\t' |
  sed 's/"//g' | sed 's/;//g' |
  awk '{$2=tolower($2);print}' OFS='\t' |
  sed 's/ensembl/NA/g' > $(echo "${c}" | sed 's/101.gtf/101.genealias.txt.tmp0/g')
  cat tmpgenealias_header.txt $(echo "${c}" | sed 's/101.gtf/101.genealias.txt.tmp0/g') > $(echo "${c}" | sed 's/101.gtf/101.genealias.txt.tmp1/g')
  rm $(echo "${c}" | sed 's/101.gtf/101.genealias.txt.tmp0/g')
done < $antfiles

# Ac-2. Download the following for each genome from BIOMART (below are the col headers)
  # ensembl_gene_id
  # ensembl_gene_id_version
  # ensembl_transcript_id
  # ensembl_transcript_id_version
  # hgnc_id
  # hgnc_symbol
  # entrezgene_accession
  # refseq_mrna_predicted
  # uniprotswissprot
  # wikigene_name
  # zfin_id_id
  # wikigene_id

# *- Go to here: https://m.ensembl.org/biomart/martview/246998056a05b7c965d983144dd0ddf6
# *-- Select 'Database' of genes and 'Attributes'
# *--- Once selected, click xml, copy and paste onto one line after wget -O result.txt 'http://www.ensembl.org/biomart/martservice?query=[INSERT XML HERE ON ONE LINE]'
# *---- Saved file will be stored as 'result.txt' so rename
# *----- Simply change the genome in '<Dataset name = "hburtoni_gene_ensembl"' to download other sets
  # mzebra_gene_ensembl
  # pnyererei_gene_ensembl
  # hburtoni_gene_ensembl
  # nbrichardi_gene_ensembl - not available
  # oniloticus_gene_ensembl
  # acalliptera_gene_ensembl

echo '#!/bin/bash -e' > 3.2_biomart_dl.sh
echo '#SBATCH -p ei-short # partition (queue)' >> 3.2_biomart_dl.sh
echo '#SBATCH -N 1 # number of nodes' >> 3.2_biomart_dl.sh
echo '#SBATCH -c 1 # number of cores' >> 3.2_biomart_dl.sh
echo '#SBATCH --mem 8000 # memory pool for all cores' >> 3.2_biomart_dl.sh
echo '#SBATCH -t 0-00:45 # time (D-HH:MM)' >> 3.2_biomart_dl.sh
echo '#SBATCH -o slurm.%j.out # STDOUT' >> 3.2_biomart_dl.sh
echo '#SBATCH -e slurm.%j.err # STDERR' >> 3.2_biomart_dl.sh
echo '#SBATCH --mail-type=END,FAIL,TIME_LIMIT_75 # notifications for job done & fail' >> 3.2_biomart_dl.sh
echo '#SBATCH --mail-user=Tarang.Mehta@earlham.ac.uk # send-to addressUSERNAME=mehtat' >> 3.2_biomart_dl.sh
printf '\n' >> 3.2_biomart_dl.sh
echo "# this script will access the software node to download the biomart dbs" >> 3.2_biomart_dl.sh
echo 'source wget-1.14' >> 3.2_biomart_dl.sh
echo "USERNAME=$Usr" >> 3.2_biomart_dl.sh
echo 'HOSTNAME="software"' >> 3.2_biomart_dl.sh
echo "PWD=$(pwd)" >> 3.2_biomart_dl.sh
printf '\n' >> 3.2_biomart_dl.sh
echo 'SCRIPT="cd ${PWD}; sh 3.2_biomart_dl_script.sh"' >> 3.2_biomart_dl.sh
printf '\n' >> 3.2_biomart_dl.sh
echo "cd ${PWD}" > 3.2_biomart_dl_script.sh ## THIS IS PURPOSELY RENAMED DIFFERENTLY!!
echo "while read -r i; do" >> 3.2_biomart_dl_script.sh
echo -e '\twget -O ${i}_biomart1.txt '"'"'http://www.ensembl.org/biomart/martservice?query=<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE Query><Query  virtualSchemaName = "default" formatter = "TSV" header = "0" uniqueRows = "0" count = "" datasetConfigVersion = "0.6" ><Dataset name = "'"'"'${i}'"'"'" interface = "default" ><Attribute name = "ensembl_gene_id" /><Attribute name = "ensembl_gene_id_version" /><Attribute name = "ensembl_transcript_id" /><Attribute name = "ensembl_transcript_id_version" /><Attribute name = "hgnc_id" /></Dataset></Query>'"'" >> 3.2_biomart_dl_script.sh
echo -e '\twget -O ${i}_biomart2.txt '"'"'http://www.ensembl.org/biomart/martservice?query=<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE Query><Query  virtualSchemaName = "default" formatter = "TSV" header = "0" uniqueRows = "0" count = "" datasetConfigVersion = "0.6" ><Dataset name = "'"'"'${i}'"'"'" interface = "default" ><Attribute name = "ensembl_transcript_id" /><Attribute name = "hgnc_symbol" /><Attribute name = "entrezgene_accession" /><Attribute name = "refseq_mrna_predicted" /></Dataset></Query>'"'" >> 3.2_biomart_dl_script.sh
echo -e '\twget -O ${i}_biomart3.txt '"'"'http://www.ensembl.org/biomart/martservice?query=<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE Query><Query  virtualSchemaName = "default" formatter = "TSV" header = "0" uniqueRows = "0" count = "" datasetConfigVersion = "0.6" ><Dataset name = "'"'"'${i}'"'"'" interface = "default" ><Attribute name = "ensembl_transcript_id" /><Attribute name = "uniprotswissprot" /><Attribute name = "wikigene_name" /></Dataset></Query>'"'" >> 3.2_biomart_dl_script.sh
echo -e '\twget -O ${i}_biomart4.txt '"'"'http://www.ensembl.org/biomart/martservice?query=<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE Query><Query  virtualSchemaName = "default" formatter = "TSV" header = "0" uniqueRows = "0" count = "" datasetConfigVersion = "0.6" ><Dataset name = "'"'"'${i}'"'"'" interface = "default" ><Attribute name = "ensembl_transcript_id" /><Attribute name = "zfin_id_id" /><Attribute name = "wikigene_id" /></Dataset></Query>'"'" >> 3.2_biomart_dl_script.sh
echo "done < $biomartspecies" >> 3.2_biomart_dl_script.sh
echo 'exit' >> 3.2_biomart_dl_script.sh
echo 'ssh -o StrictHostKeyChecking=no -l ${USERNAME} ${HOSTNAME} "${SCRIPT}"' >> 3.2_biomart_dl.sh
printf '\n' >> 3.2_biomart_dl.sh
echo "printf 'ensembl_transcript_id\thgnc_symbol\tentrezgene_accession\trefseq_mrna_predicted\tensembl_gene_id\tensembl_gene_id_version\tensembl_transcript_id\tensembl_transcript_id_version\thgnc_id\tensembl_transcript_id\tuniprotswissprot\twikigene_name\tensembl_transcript_id\tzfin_id_id\twikigene_id\n' > "'biomart_headers # NOTE - many of these cols will get removed later' >> 3.2_biomart_dl.sh
echo "while read -r i; do" >> 3.2_biomart_dl.sh
echo -e "\tawk '"'!$5{print $0,"NA";next}1'"' "'${i}_biomart1.txt > ${i}_biomart1a.txt # fill the 5th column with NA if empty' >> 3.2_biomart_dl.sh
echo -e "\tawk '"'!$2{print $0,"NA";next}1'"' "'${i}_biomart2.txt | awk '"'"'!$3{print $0,"NA";next}1'"' | awk '"'!$4{print $0,"NA";next}1'"' > "'${i}_biomart2a.txt # fill the 2nd, 3rd and 4th column with NA if empty' >> 3.2_biomart_dl.sh
echo -e "\tawk '"'!$2{print $0,"NA";next}1'"' "'${i}_biomart3.txt | awk '"'"'!$3{print $0,"NA";next}1'"' > "'${i}_biomart3a.txt # fill the 2nd and 3rd column with NA if empty' >> 3.2_biomart_dl.sh
echo -e "\tawk '"'!$2{print $0,"NA";next}1'"' "'${i}_biomart4.txt | awk '"'"'!$3{print $0,"NA";next}1'"' > "'${i}_biomart4a.txt # fill the 2nd and 3rd column with NA if empty' >> 3.2_biomart_dl.sh
echo -e '\tawk '"'BEGIN{OFS="'"\t"}NR==FNR{a[$3]=$0;next}{if(a[$1]){print $0,a[$1];}else{print $0,"NA","NA","NA","NA","NA";}}'"' "'${i}_biomart1a.txt ${i}_biomart2a.txt > ${i}_biomart1-2a.txt' >> 3.2_biomart_dl.sh
echo -e '\tawk '"'BEGIN{OFS="'"\t"}NR==FNR{a[$1]=$0;next}{if(a[$1]){print $0,a[$1];}else{print $0,"NA","NA","NA";}}'"' "'${i}_biomart3a.txt ${i}_biomart1-2a.txt > ${i}_biomart1-2-3a.txt' >> 3.2_biomart_dl.sh
echo -e '\tawk '"'BEGIN{OFS="'"\t"}NR==FNR{a[$1]=$0;next}{if(a[$1]){print $0,a[$1];}else{print $0,"NA","NA","NA";}}'"' "'${i}_biomart4a.txt ${i}_biomart1-2-3a.txt > ${i}_biomart.tmp.txt' >> 3.2_biomart_dl.sh
echo -e '\tcat biomart_headers ${i}_biomart.tmp.txt | awk '"'{print "'$1,$2,$3,$4,$5,$6,$8,$9,$11,$12,$14,$15}'"' OFS='\t' | awk '{print "'$5,$6,$1,$7,$8,$2,$3,$4,$9,$10,$11,$12}'"' OFS='\t' > "'${i}_biomart.txt' >> 3.2_biomart_dl.sh
echo -e '\trm ${i}_biomart.tmp.txt' >> 3.2_biomart_dl.sh
echo "done < $biomartspecies" >> 3.2_biomart_dl.sh

echo '# -- 2a. Peak annotation has completed -- #'

echo '# -- 2b. Fraction of Reads in annotated regions has completed -- #'

echo '# -- 3a. TF footprinting preparation has started - bioMart alias, annotations and data.config prep -- #'

JOBID9=$( sbatch -W --dependency=afterok:${JOBID8f} 3.2_biomart_dl.sh | awk '{print $4}' ) # JOB9 depends on JOB8 completing successfully


# # while loop original placed in script above, and a while loop version of the longer version below
# while read -r i; do
#   wget -O ${i}_biomart1.txt 'http://www.ensembl.org/biomart/martservice?query=<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE Query><Query  virtualSchemaName = "default" formatter = "TSV" header = "0" uniqueRows = "0" count = "" datasetConfigVersion = "0.6" ><Dataset name = "'${i}'" interface = "default" ><Attribute name = "ensembl_gene_id" /><Attribute name = "ensembl_gene_id_version" /><Attribute name = "ensembl_transcript_id" /><Attribute name = "ensembl_transcript_id_version" /><Attribute name = "hgnc_id" /></Dataset></Query>'
#   awk '!$5{print $0,"NA";next}1' ${i}_biomart1.txt > ${i}_biomart1a.txt # fill the 5th column with NA if empty
#   wget -O ${i}_biomart2.txt 'http://www.ensembl.org/biomart/martservice?query=<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE Query><Query  virtualSchemaName = "default" formatter = "TSV" header = "0" uniqueRows = "0" count = "" datasetConfigVersion = "0.6" ><Dataset name = "'${i}'" interface = "default" ><Attribute name = "ensembl_transcript_id" /><Attribute name = "hgnc_symbol" /><Attribute name = "entrezgene_accession" /><Attribute name = "refseq_mrna_predicted" /></Dataset></Query>'
#   awk '!$2{print $0,"NA";next}1' ${i}_biomart2.txt | awk '!$3{print $0,"NA";next}1' | awk '!$4{print $0,"NA";next}1' > ${i}_biomart2a.txt # fill the 2nd, 3rd and 4th column with NA if empty
#   wget -O ${i}_biomart3.txt 'http://www.ensembl.org/biomart/martservice?query=<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE Query><Query  virtualSchemaName = "default" formatter = "TSV" header = "0" uniqueRows = "0" count = "" datasetConfigVersion = "0.6" ><Dataset name = "'${i}'" interface = "default" ><Attribute name = "ensembl_transcript_id" /><Attribute name = "uniprotswissprot" /><Attribute name = "wikigene_name" /></Dataset></Query>'
#   awk '!$2{print $0,"NA";next}1' ${i}_biomart3.txt | awk '!$3{print $0,"NA";next}1' > ${i}_biomart3a.txt # fill the 2nd and 3rd column with NA if empty
#   wget -O ${i}_biomart4.txt 'http://www.ensembl.org/biomart/martservice?query=<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE Query><Query  virtualSchemaName = "default" formatter = "TSV" header = "0" uniqueRows = "0" count = "" datasetConfigVersion = "0.6" ><Dataset name = "'${i}'" interface = "default" ><Attribute name = "ensembl_transcript_id" /><Attribute name = "zfin_id_id" /><Attribute name = "wikigene_id" /></Dataset></Query>'
#   awk '!$2{print $0,"NA";next}1' ${i}_biomart4.txt | awk '!$3{print $0,"NA";next}1' > ${i}_biomart4a.txt # fill the 2nd and 3rd column with NA if empty
#   awk 'BEGIN{OFS="\t"}NR==FNR{a[$3]=$0;next}{if(a[$1]){print $0,a[$1];}else{print $0,"NA","NA","NA","NA","NA";}}' ${i}_biomart1a.txt ${i}_biomart2a.txt > ${i}_biomart1-2a.txt
#   awk 'BEGIN{OFS="\t"}NR==FNR{a[$1]=$0;next}{if(a[$1]){print $0,a[$1];}else{print $0,"NA","NA","NA";}}' ${i}_biomart3a.txt ${i}_biomart1-2a.txt > ${i}_biomart1-2-3a.txt
#   awk 'BEGIN{OFS="\t"}NR==FNR{a[$1]=$0;next}{if(a[$1]){print $0,a[$1];}else{print $0,"NA","NA","NA";}}' ${i}_biomart4a.txt ${i}_biomart1-2-3a.txt > ${i}_biomart.tmp.txt
#   printf 'ensembl_transcript_id\thgnc_symbol\tentrezgene_accession\trefseq_mrna_predicted\tensembl_gene_id\tensembl_gene_id_version\tensembl_transcript_id\tensembl_transcript_id_version\thgnc_id\tensembl_transcript_id\tuniprotswissprot\twikigene_name\tensembl_transcript_id\tzfin_id_id\twikigene_id\n' > biomart_headers # NOTE - many of these cols will get removed later
#   cat biomart_headers ${i}_biomart.tmp.txt | awk '{print $1,$2,$3,$4,$5,$6,$8,$9,$11,$12,$14,$15}' OFS='\t' | awk '{print $5,$6,$1,$7,$8,$2,$3,$4,$9,$10,$11,$12}' OFS='\t' > ${i}_biomart.txt
#   rm ${i}_biomart.tmp.txt
# done < $biomartspecies

# # Zebra mbuna genes (M_zebra_UMD2a)
# # wget -O mz_biomart.txt 'http://www.ensembl.org/biomart/martservice?query=<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE Query><Query  virtualSchemaName = "default" formatter = "TSV" header = "0" uniqueRows = "0" count = "" datasetConfigVersion = "0.6" ><Dataset name = "mzebra_gene_ensembl" interface = "default" ><Attribute name = "ensembl_gene_id" /><Attribute name = "ensembl_gene_id_version" /><Attribute name = "ensembl_transcript_id" /><Attribute name = "ensembl_transcript_id_version" /><Attribute name = "hgnc_id" /><Attribute name = "hgnc_symbol" /><Attribute name = "entrezgene_accession" /><Attribute name = "refseq_mrna_predicted" /><Attribute name = "uniprotswissprot" /><Attribute name = "wikigene_name" /><Attribute name = "zfin_id_id" /><Attribute name = "wikigene_id" /></Dataset></Query>' # this will not work as biomart cannot process this many attributes
#
# wget -O mz_biomart1.txt 'http://www.ensembl.org/biomart/martservice?query=<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE Query><Query  virtualSchemaName = "default" formatter = "TSV" header = "0" uniqueRows = "0" count = "" datasetConfigVersion = "0.6" ><Dataset name = "mzebra_gene_ensembl" interface = "default" ><Attribute name = "ensembl_gene_id" /><Attribute name = "ensembl_gene_id_version" /><Attribute name = "ensembl_transcript_id" /><Attribute name = "ensembl_transcript_id_version" /><Attribute name = "hgnc_id" /></Dataset></Query>'
# awk '!$5{print $0,"NA";next}1' mz_biomart1.txt > mz_biomart1a.txt # fill the 5th column with NA if empty
#
# wget -O mz_biomart2.txt 'http://www.ensembl.org/biomart/martservice?query=<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE Query><Query  virtualSchemaName = "default" formatter = "TSV" header = "0" uniqueRows = "0" count = "" datasetConfigVersion = "0.6" ><Dataset name = "mzebra_gene_ensembl" interface = "default" ><Attribute name = "ensembl_transcript_id" /><Attribute name = "hgnc_symbol" /><Attribute name = "entrezgene_accession" /><Attribute name = "refseq_mrna_predicted" /></Dataset></Query>'
# awk '!$2{print $0,"NA";next}1' mz_biomart2.txt | awk '!$3{print $0,"NA";next}1' | awk '!$4{print $0,"NA";next}1' > mz_biomart2a.txt # fill the 2nd, 3rd and 4th column with NA if empty
#
# wget -O mz_biomart3.txt 'http://www.ensembl.org/biomart/martservice?query=<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE Query><Query  virtualSchemaName = "default" formatter = "TSV" header = "0" uniqueRows = "0" count = "" datasetConfigVersion = "0.6" ><Dataset name = "mzebra_gene_ensembl" interface = "default" ><Attribute name = "ensembl_transcript_id" /><Attribute name = "uniprotswissprot" /><Attribute name = "wikigene_name" /></Dataset></Query>'
# awk '!$2{print $0,"NA";next}1' mz_biomart3.txt | awk '!$3{print $0,"NA";next}1' > mz_biomart3a.txt # fill the 2nd and 3rd column with NA if empty
#
# wget -O mz_biomart4.txt 'http://www.ensembl.org/biomart/martservice?query=<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE Query><Query  virtualSchemaName = "default" formatter = "TSV" header = "0" uniqueRows = "0" count = "" datasetConfigVersion = "0.6" ><Dataset name = "mzebra_gene_ensembl" interface = "default" ><Attribute name = "ensembl_transcript_id" /><Attribute name = "zfin_id_id" /><Attribute name = "wikigene_id" /></Dataset></Query>'
# awk '!$2{print $0,"NA";next}1' mz_biomart4.txt | awk '!$3{print $0,"NA";next}1' > mz_biomart4a.txt # fill the 2nd and 3rd column with NA if empty
#
# awk 'BEGIN{OFS="\t"}NR==FNR{a[$3]=$0;next}{if(a[$1]){print $0,a[$1];}else{print $0,"NA","NA","NA","NA","NA";}}' mz_biomart1a.txt mz_biomart2a.txt > mz_biomart1-2a.txt
# awk 'BEGIN{OFS="\t"}NR==FNR{a[$1]=$0;next}{if(a[$1]){print $0,a[$1];}else{print $0,"NA","NA","NA";}}' mz_biomart3a.txt mz_biomart1-2a.txt > mz_biomart1-2-3a.txt
# awk 'BEGIN{OFS="\t"}NR==FNR{a[$1]=$0;next}{if(a[$1]){print $0,a[$1];}else{print $0,"NA","NA","NA";}}' mz_biomart4a.txt mz_biomart1-2-3a.txt > mz_biomart.tmp.txt
#
# printf 'ensembl_transcript_id\thgnc_symbol\tentrezgene_accession\trefseq_mrna_predicted\tensembl_gene_id\tensembl_gene_id_version\tensembl_transcript_id\tensembl_transcript_id_version\thgnc_id\tensembl_transcript_id\tuniprotswissprot\twikigene_name\tensembl_transcript_id\tzfin_id_id\twikigene_id\n' > biomart_headers # NOTE - many of these cols will get removed later
# # printf 'ensembl_gene_id\tensembl_gene_id_version\tensembl_transcript_id\tensembl_transcript_id_version\thgnc_id\tensembl_transcript_id\thgnc_symbol\tentrezgene_accession\trefseq_mrna_predicted\tensembl_transcript_id\tuniprotswissprot\twikigene_name\tensembl_transcript_id\tzfin_id_id\twikigene_id\n' > biomart_headers
# cat biomart_headers mz_biomart.tmp.txt | awk '{print $1,$2,$3,$4,$5,$6,$8,$9,$11,$12,$14,$15}' OFS='\t' | awk '{print $5,$6,$1,$7,$8,$2,$3,$4,$9,$10,$11,$12}' OFS='\t' > mz_biomart.txt
#
#
# # Makobe Island cichlid genes (PunNye1.0)
# # wget -O pn_biomart.txt 'http://www.ensembl.org/biomart/martservice?query=<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE Query><Query  virtualSchemaName = "default" formatter = "TSV" header = "0" uniqueRows = "0" count = "" datasetConfigVersion = "0.6" ><Dataset name = "pnyererei_gene_ensembl" interface = "default" ><Attribute name = "ensembl_gene_id" /><Attribute name = "ensembl_gene_id_version" /><Attribute name = "ensembl_transcript_id" /><Attribute name = "ensembl_transcript_id_version" /><Attribute name = "hgnc_id" /><Attribute name = "hgnc_symbol" /><Attribute name = "entrezgene_accession" /><Attribute name = "refseq_mrna_predicted" /><Attribute name = "uniprotswissprot" /><Attribute name = "wikigene_name" /><Attribute name = "zfin_id_id" /><Attribute name = "wikigene_id" /></Dataset></Query>' # this will not work as biomart cannot process this many attributes
#
# wget -O pn_biomart1.txt 'http://www.ensembl.org/biomart/martservice?query=<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE Query><Query  virtualSchemaName = "default" formatter = "TSV" header = "0" uniqueRows = "0" count = "" datasetConfigVersion = "0.6" ><Dataset name = "pnyererei_gene_ensembl" interface = "default" ><Attribute name = "ensembl_gene_id" /><Attribute name = "ensembl_gene_id_version" /><Attribute name = "ensembl_transcript_id" /><Attribute name = "ensembl_transcript_id_version" /><Attribute name = "hgnc_id" /></Dataset></Query>'
# awk '!$5{print $0,"NA";next}1' pn_biomart1.txt > pn_biomart1a.txt # fill the 5th column with NA if empty
#
# wget -O pn_biomart2.txt 'http://www.ensembl.org/biomart/martservice?query=<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE Query><Query  virtualSchemaName = "default" formatter = "TSV" header = "0" uniqueRows = "0" count = "" datasetConfigVersion = "0.6" ><Dataset name = "pnyererei_gene_ensembl" interface = "default" ><Attribute name = "ensembl_transcript_id" /><Attribute name = "hgnc_symbol" /><Attribute name = "entrezgene_accession" /><Attribute name = "refseq_mrna_predicted" /></Dataset></Query>'
# awk '!$2{print $0,"NA";next}1' pn_biomart2.txt | awk '!$3{print $0,"NA";next}1' | awk '!$4{print $0,"NA";next}1' > pn_biomart2a.txt # fill the 2nd, 3rd and 4th column with NA if empty
#
# wget -O pn_biomart3.txt 'http://www.ensembl.org/biomart/martservice?query=<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE Query><Query  virtualSchemaName = "default" formatter = "TSV" header = "0" uniqueRows = "0" count = "" datasetConfigVersion = "0.6" ><Dataset name = "pnyererei_gene_ensembl" interface = "default" ><Attribute name = "ensembl_transcript_id" /><Attribute name = "uniprotswissprot" /><Attribute name = "wikigene_name" /></Dataset></Query>'
# awk '!$2{print $0,"NA";next}1' pn_biomart3.txt | awk '!$3{print $0,"NA";next}1' > pn_biomart3a.txt # fill the 2nd and 3rd column with NA if empty
#
# wget -O pn_biomart4.txt 'http://www.ensembl.org/biomart/martservice?query=<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE Query><Query  virtualSchemaName = "default" formatter = "TSV" header = "0" uniqueRows = "0" count = "" datasetConfigVersion = "0.6" ><Dataset name = "pnyererei_gene_ensembl" interface = "default" ><Attribute name = "ensembl_transcript_id" /><Attribute name = "zfin_id_id" /><Attribute name = "wikigene_id" /></Dataset></Query>'
# awk '!$2{print $0,"NA";next}1' pn_biomart4.txt | awk '!$3{print $0,"NA";next}1' > pn_biomart4a.txt # fill the 2nd and 3rd column with NA if empty
#
# awk 'BEGIN{OFS="\t"}NR==FNR{a[$3]=$0;next}{if(a[$1]){print $0,a[$1];}else{print $0,"NA","NA","NA","NA","NA";}}' pn_biomart1a.txt pn_biomart2a.txt > pn_biomart1-2a.txt
# awk 'BEGIN{OFS="\t"}NR==FNR{a[$1]=$0;next}{if(a[$1]){print $0,a[$1];}else{print $0,"NA","NA","NA";}}' pn_biomart3a.txt pn_biomart1-2a.txt > pn_biomart1-2-3a.txt
# awk 'BEGIN{OFS="\t"}NR==FNR{a[$1]=$0;next}{if(a[$1]){print $0,a[$1];}else{print $0,"NA","NA","NA";}}' pn_biomart4a.txt pn_biomart1-2-3a.txt > pn_biomart.tmp.txt
#
# printf 'ensembl_transcript_id\thgnc_symbol\tentrezgene_accession\trefseq_mrna_predicted\tensembl_gene_id\tensembl_gene_id_version\tensembl_transcript_id\tensembl_transcript_id_version\thgnc_id\tensembl_transcript_id\tuniprotswissprot\twikigene_name\tensembl_transcript_id\tzfin_id_id\twikigene_id\n' > biomart_headers # NOTE - many of these cols will get removed later
# # printf 'ensembl_gene_id\tensembl_gene_id_version\tensembl_transcript_id\tensembl_transcript_id_version\thgnc_id\tensembl_transcript_id\thgnc_symbol\tentrezgene_accession\trefseq_mrna_predicted\tensembl_transcript_id\tuniprotswissprot\twikigene_name\tensembl_transcript_id\tzfin_id_id\twikigene_id\n' > biomart_headers
# cat biomart_headers pn_biomart.tmp.txt | awk '{print $1,$2,$3,$4,$5,$6,$8,$9,$11,$12,$14,$15}' OFS='\t' | awk '{print $5,$6,$1,$7,$8,$2,$3,$4,$9,$10,$11,$12}' OFS='\t' > pn_biomart.txt
#
#
# # Burton's mouthbrooder genes (AstBur1.0)
# # wget -O ab_biomart.txt 'http://www.ensembl.org/biomart/martservice?query=<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE Query><Query  virtualSchemaName = "default" formatter = "TSV" header = "0" uniqueRows = "0" count = "" datasetConfigVersion = "0.6" ><Dataset name = "hburtoni_gene_ensembl" interface = "default" ><Attribute name = "ensembl_gene_id" /><Attribute name = "ensembl_gene_id_version" /><Attribute name = "ensembl_transcript_id" /><Attribute name = "ensembl_transcript_id_version" /><Attribute name = "hgnc_id" /><Attribute name = "hgnc_symbol" /><Attribute name = "entrezgene_accession" /><Attribute name = "refseq_mrna_predicted" /><Attribute name = "uniprotswissprot" /><Attribute name = "wikigene_name" /><Attribute name = "zfin_id_id" /><Attribute name = "wikigene_id" /></Dataset></Query>' # this will not work as biomart cannot process this many attributes
#
# wget -O ab_biomart1.txt 'http://www.ensembl.org/biomart/martservice?query=<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE Query><Query  virtualSchemaName = "default" formatter = "TSV" header = "0" uniqueRows = "0" count = "" datasetConfigVersion = "0.6" ><Dataset name = "hburtoni_gene_ensembl" interface = "default" ><Attribute name = "ensembl_gene_id" /><Attribute name = "ensembl_gene_id_version" /><Attribute name = "ensembl_transcript_id" /><Attribute name = "ensembl_transcript_id_version" /><Attribute name = "hgnc_id" /></Dataset></Query>'
# awk '!$5{print $0,"NA";next}1' ab_biomart1.txt > ab_biomart1a.txt # fill the 5th column with NA if empty
#
# wget -O ab_biomart2.txt 'http://www.ensembl.org/biomart/martservice?query=<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE Query><Query  virtualSchemaName = "default" formatter = "TSV" header = "0" uniqueRows = "0" count = "" datasetConfigVersion = "0.6" ><Dataset name = "hburtoni_gene_ensembl" interface = "default" ><Attribute name = "ensembl_transcript_id" /><Attribute name = "hgnc_symbol" /><Attribute name = "entrezgene_accession" /><Attribute name = "refseq_mrna_predicted" /></Dataset></Query>'
# awk '!$2{print $0,"NA";next}1' ab_biomart2.txt | awk '!$3{print $0,"NA";next}1' | awk '!$4{print $0,"NA";next}1' > ab_biomart2a.txt # fill the 2nd, 3rd and 4th column with NA if empty
#
# wget -O ab_biomart3.txt 'http://www.ensembl.org/biomart/martservice?query=<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE Query><Query  virtualSchemaName = "default" formatter = "TSV" header = "0" uniqueRows = "0" count = "" datasetConfigVersion = "0.6" ><Dataset name = "hburtoni_gene_ensembl" interface = "default" ><Attribute name = "ensembl_transcript_id" /><Attribute name = "uniprotswissprot" /><Attribute name = "wikigene_name" /></Dataset></Query>'
# awk '!$2{print $0,"NA";next}1' ab_biomart3.txt | awk '!$3{print $0,"NA";next}1' > ab_biomart3a.txt # fill the 2nd and 3rd column with NA if empty
#
# wget -O ab_biomart4.txt 'http://www.ensembl.org/biomart/martservice?query=<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE Query><Query  virtualSchemaName = "default" formatter = "TSV" header = "0" uniqueRows = "0" count = "" datasetConfigVersion = "0.6" ><Dataset name = "hburtoni_gene_ensembl" interface = "default" ><Attribute name = "ensembl_transcript_id" /><Attribute name = "zfin_id_id" /><Attribute name = "wikigene_id" /></Dataset></Query>'
# awk '!$2{print $0,"NA";next}1' ab_biomart4.txt | awk '!$3{print $0,"NA";next}1' > ab_biomart4a.txt # fill the 2nd and 3rd column with NA if empty
#
# awk 'BEGIN{OFS="\t"}NR==FNR{a[$3]=$0;next}{if(a[$1]){print $0,a[$1];}else{print $0,"NA","NA","NA","NA","NA";}}' ab_biomart1a.txt ab_biomart2a.txt > ab_biomart1-2a.txt
# awk 'BEGIN{OFS="\t"}NR==FNR{a[$1]=$0;next}{if(a[$1]){print $0,a[$1];}else{print $0,"NA","NA","NA";}}' ab_biomart3a.txt ab_biomart1-2a.txt > ab_biomart1-2-3a.txt
# awk 'BEGIN{OFS="\t"}NR==FNR{a[$1]=$0;next}{if(a[$1]){print $0,a[$1];}else{print $0,"NA","NA","NA";}}' ab_biomart4a.txt ab_biomart1-2-3a.txt > ab_biomart.tmp.txt
#
# printf 'ensembl_transcript_id\thgnc_symbol\tentrezgene_accession\trefseq_mrna_predicted\tensembl_gene_id\tensembl_gene_id_version\tensembl_transcript_id\tensembl_transcript_id_version\thgnc_id\tensembl_transcript_id\tuniprotswissprot\twikigene_name\tensembl_transcript_id\tzfin_id_id\twikigene_id\n' > biomart_headers # NOTE - many of these cols will get removed later
# # printf 'ensembl_gene_id\tensembl_gene_id_version\tensembl_transcript_id\tensembl_transcript_id_version\thgnc_id\tensembl_transcript_id\thgnc_symbol\tentrezgene_accession\trefseq_mrna_predicted\tensembl_transcript_id\tuniprotswissprot\twikigene_name\tensembl_transcript_id\tzfin_id_id\twikigene_id\n' > biomart_headers
# cat biomart_headers ab_biomart.tmp.txt | awk '{print $1,$2,$3,$4,$5,$6,$8,$9,$11,$12,$14,$15}' OFS='\t' | awk '{print $5,$6,$1,$7,$8,$2,$3,$4,$9,$10,$11,$12}' OFS='\t' > ab_biomart.txt
#
#
# # Lyretail cichlid (NeoBri1.0) - check as this is not in BioMart online (poor annotation!)
# # Since this is not in biomart, just stick with $file1 as the gene alias file
#
# # Nile tilapia genes (O_niloticus_UMD_NMBU)
# # wget -O on_biomart.txt 'http://www.ensembl.org/biomart/martservice?query=<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE Query><Query  virtualSchemaName = "default" formatter = "TSV" header = "0" uniqueRows = "0" count = "" datasetConfigVersion = "0.6" ><Dataset name = "oniloticus_gene_ensembl" interface = "default" ><Attribute name = "ensembl_gene_id" /><Attribute name = "ensembl_gene_id_version" /><Attribute name = "ensembl_transcript_id" /><Attribute name = "ensembl_transcript_id_version" /><Attribute name = "hgnc_id" /><Attribute name = "hgnc_symbol" /><Attribute name = "entrezgene_accession" /><Attribute name = "refseq_mrna_predicted" /><Attribute name = "uniprotswissprot" /><Attribute name = "wikigene_name" /><Attribute name = "zfin_id_id" /><Attribute name = "wikigene_id" /></Dataset></Query>' # this will not work as biomart cannot process this many attributes
#
# wget -O on_biomart1.txt 'http://www.ensembl.org/biomart/martservice?query=<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE Query><Query  virtualSchemaName = "default" formatter = "TSV" header = "0" uniqueRows = "0" count = "" datasetConfigVersion = "0.6" ><Dataset name = "oniloticus_gene_ensembl" interface = "default" ><Attribute name = "ensembl_gene_id" /><Attribute name = "ensembl_gene_id_version" /><Attribute name = "ensembl_transcript_id" /><Attribute name = "ensembl_transcript_id_version" /><Attribute name = "hgnc_id" /></Dataset></Query>'
# awk '!$5{print $0,"NA";next}1' on_biomart1.txt > on_biomart1a.txt # fill the 5th column with NA if empty
#
# wget -O on_biomart2.txt 'http://www.ensembl.org/biomart/martservice?query=<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE Query><Query  virtualSchemaName = "default" formatter = "TSV" header = "0" uniqueRows = "0" count = "" datasetConfigVersion = "0.6" ><Dataset name = "oniloticus_gene_ensembl" interface = "default" ><Attribute name = "ensembl_transcript_id" /><Attribute name = "hgnc_symbol" /><Attribute name = "entrezgene_accession" /><Attribute name = "refseq_mrna_predicted" /></Dataset></Query>'
# awk '!$2{print $0,"NA";next}1' on_biomart2.txt | awk '!$3{print $0,"NA";next}1' | awk '!$4{print $0,"NA";next}1' > on_biomart2a.txt # fill the 2nd, 3rd and 4th column with NA if empty
#
# wget -O on_biomart3.txt 'http://www.ensembl.org/biomart/martservice?query=<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE Query><Query  virtualSchemaName = "default" formatter = "TSV" header = "0" uniqueRows = "0" count = "" datasetConfigVersion = "0.6" ><Dataset name = "oniloticus_gene_ensembl" interface = "default" ><Attribute name = "ensembl_transcript_id" /><Attribute name = "uniprotswissprot" /><Attribute name = "wikigene_name" /></Dataset></Query>'
# awk '!$2{print $0,"NA";next}1' on_biomart3.txt | awk '!$3{print $0,"NA";next}1' > on_biomart3a.txt # fill the 2nd and 3rd column with NA if empty
#
# wget -O on_biomart4.txt 'http://www.ensembl.org/biomart/martservice?query=<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE Query><Query  virtualSchemaName = "default" formatter = "TSV" header = "0" uniqueRows = "0" count = "" datasetConfigVersion = "0.6" ><Dataset name = "oniloticus_gene_ensembl" interface = "default" ><Attribute name = "ensembl_transcript_id" /><Attribute name = "zfin_id_id" /><Attribute name = "wikigene_id" /></Dataset></Query>'
# awk '!$2{print $0,"NA";next}1' on_biomart4.txt | awk '!$3{print $0,"NA";next}1' > on_biomart4a.txt # fill the 2nd and 3rd column with NA if empty
#
# awk 'BEGIN{OFS="\t"}NR==FNR{a[$3]=$0;next}{if(a[$1]){print $0,a[$1];}else{print $0,"NA","NA","NA","NA","NA";}}' on_biomart1a.txt on_biomart2a.txt > on_biomart1-2a.txt
# awk 'BEGIN{OFS="\t"}NR==FNR{a[$1]=$0;next}{if(a[$1]){print $0,a[$1];}else{print $0,"NA","NA","NA";}}' on_biomart3a.txt on_biomart1-2a.txt > on_biomart1-2-3a.txt
# awk 'BEGIN{OFS="\t"}NR==FNR{a[$1]=$0;next}{if(a[$1]){print $0,a[$1];}else{print $0,"NA","NA","NA";}}' on_biomart4a.txt on_biomart1-2-3a.txt > on_biomart.tmp.txt
#
# printf 'ensembl_transcript_id\thgnc_symbol\tentrezgene_accession\trefseq_mrna_predicted\tensembl_gene_id\tensembl_gene_id_version\tensembl_transcript_id\tensembl_transcript_id_version\thgnc_id\tensembl_transcript_id\tuniprotswissprot\twikigene_name\tensembl_transcript_id\tzfin_id_id\twikigene_id\n' > biomart_headers # NOTE - many of these cols will get removed later
# # printf 'ensembl_gene_id\tensembl_gene_id_version\tensembl_transcript_id\tensembl_transcript_id_version\thgnc_id\tensembl_transcript_id\thgnc_symbol\tentrezgene_accession\trefseq_mrna_predicted\tensembl_transcript_id\tuniprotswissprot\twikigene_name\tensembl_transcript_id\tzfin_id_id\twikigene_id\n' > biomart_headers
# cat biomart_headers on_biomart.tmp.txt | awk '{print $1,$2,$3,$4,$5,$6,$8,$9,$11,$12,$14,$15}' OFS='\t' | awk '{print $5,$6,$1,$7,$8,$2,$3,$4,$9,$10,$11,$12}' OFS='\t' > on_biomart.txt

# Ac-3. awk match files '$file1' and '$file2' above to create two files:

# Ac-3a. One tab delimited file WITH HEADERS > ${Mz,Pn,Ab,Nb,On,Ac}ggenaltsv (these are stored in the species gtf dir), and
sed 's/101.gtf/101.genealias.txt.tmp1/g' $antfiles | grep -v $removesp | sort -u > $processggenaltsv

while read -r i; do
  echo ${i}_biomart.txt >> $biomartfiles.tmp
done < $biomartspecies
sort -u $biomartfiles.tmp > $biomartfiles; rm $biomartfiles.tmp

while read -u 3 -r file1 && read -u 4 -r file2
do
  awk 'BEGIN{OFS="\t"}NR==FNR{a[$1]=$0;next}{if(a[$1]){print $0,a[$1];}else{print $0,"NA","NA";}}' ${file2} ${file1} | awk '{print $1,$14,$2,$3,$4,$5,$6,$7,$8,$9,$10,$11,$12}' OFS='\t' > $(echo "${file2}" | sed 's/.txt.tmp1/.tsv/g')
done 3<$biomartfiles 4<$processggenaltsv

Nbggenaltsvtmp=$(echo "$annotNbg" | sed 's/101.gtf/101.genealias.txt.tmp1/g'); cp $Nbggenaltsvtmp $Nbggenaltsv # just copy the tmp1 file and rename for this (since no biomart db exists)

# Ac-3b. Using the file from 'Ac-3a' above, prepare the gene alias files with correct format (plus ensure to exclude any NA/na columns)
# example format (3 col, tab delimited)
# ENSDARG00000031971      kdelc1  ENSDARG00000031971&kdelc1&393905&Dr.82452
# ENSG00000175899 A2M     HGNC:7&A2M&FWP007&S863-7&CPAMD5&BX647329&X68728&M11313&2&MGI:2449119&2408344&9697696&NM_000014&CCDS44827&OTTHUMG00000150267&2&P01023&ENSG00000175899

awk 'NR>1 {print $1,$2,$1"&"$2}' OFS='\t' $Nbggenaltsv | sed 's/\&NA//g' > $Nbggenal

# merge rows with same first column (ensembl_gene_id) and obtain unique cells in each row only for the output
sed 's/101.gtf/101.genealias.tsv/g' $antfiles | grep -v $removesp | sort -u > $processggenaltsv2

while read -r i; do
  awk -F'\t' 'NF>1{a[$1] = a[$1]"\t"$0};END{for(i in a)print i"\t"a[i]}' ${i} |
  awk '{ n=split($0,a,FS); $0=""; j=1; delete u; for (i=1; i<=n; i++) if (!u[a[i]]++) $(j++) = a[i]; print }' |
  sed 's/NA//g' > ${i}.tmpfile0
  awk '{print $1,$2}' OFS='\t' ${i}.tmpfile0 > ${i}.tmpfile1
  sed 's/ /\&/g' ${i}.tmpfile0 > ${i}.tmpfile2
  paste ${i}.tmpfile1 ${i}.tmpfile2 | awk '{print $1,$2,$3}' OFS='\t' > $(echo "${i}" | sed 's/.tsv/.txt/g')
  rm ${i}.tmpfile*
done < $processggenaltsv2

sed 's/.tsv/.txt/g' $processggenaltsv2 > $genalpaths
echo $(ls -1 $Nbggenal) >> $genalpaths

while read -r d; do
# for d in "$Mzgannot" "$Pngannot" "$Abgannot" "$Nbgannot" "$Ongannot" "$Acgannot"; do
  rm $(echo "${d}" | sed 's/101.gtf/101.genealias.txt.tmp1/g')
done < $antfiles

# B. Create data.config.user file with species specific entries
# see this for using own motifs: https://www.regulatory-genomics.org/motif-analysis/additional-motif-data/
# When RGT is installed, it will automatically create a folder to store additional data (default: ~/rgtdata).
# Within the subfolder motifs, files related to the motif analysis tool will be added: position frequency matrices (describing transcription factor motifs), files needed for the HTML report, etc

echo "$rgtidsp1" >> $rgtdatapath/data.config.user
echo "genome: $FAMzg" >> $rgtdatapath/data.config.user
echo "chromosome_sizes: $Mzgchr" >> $rgtdatapath/data.config.user
echo "genes_Gencode: $MzggenGC" >> $rgtdatapath/data.config.user
echo "genes_RefSeq: $MzggenRS" >> $rgtdatapath/data.config.user
echo "annotation: $annotMzg" >> $rgtdatapath/data.config.user
echo "gene_alias: $Mzggenal" >> $rgtdatapath/data.config.user
printf '\n' >> $rgtdatapath/data.config.user

echo "$rgtidsp2" >> $rgtdatapath/data.config.user
echo "genome: $FAPng" >> $rgtdatapath/data.config.user
echo "chromosome_sizes: $Pngchr" >> $rgtdatapath/data.config.user
echo "genes_Gencode: $PnggenGC" >> $rgtdatapath/data.config.user
echo "genes_RefSeq: $PnggenRS" >> $rgtdatapath/data.config.user
echo "annotation: $annotPng" >> $rgtdatapath/data.config.user
echo "gene_alias: $Pnggenal" >> $rgtdatapath/data.config.user
printf '\n' >> $rgtdatapath/data.config.user

echo "$rgtidsp3" >> $rgtdatapath/data.config.user
echo "genome: $FAAbg" >> $rgtdatapath/data.config.user
echo "chromosome_sizes: $Abgchr" >> $rgtdatapath/data.config.user
echo "genes_Gencode: $AbggenGC" >> $rgtdatapath/data.config.user
echo "genes_RefSeq: $AbggenRS" >> $rgtdatapath/data.config.user
echo "annotation: $annotAbg" >> $rgtdatapath/data.config.user
echo "gene_alias: $Abggenal" >> $rgtdatapath/data.config.user
printf '\n' >> $rgtdatapath/data.config.user

echo "$rgtidsp4" >> $rgtdatapath/data.config.user
echo "genome: $FANbg" >> $rgtdatapath/data.config.user
echo "chromosome_sizes: $Nbgchr" >> $rgtdatapath/data.config.user
echo "genes_Gencode: $NbggenGC" >> $rgtdatapath/data.config.user
echo "genes_RefSeq: $NbggenRS" >> $rgtdatapath/data.config.user
echo "annotation: $annotNbg" >> $rgtdatapath/data.config.user
echo "gene_alias: $Nbggenal" >> $rgtdatapath/data.config.user
printf '\n' >> $rgtdatapath/data.config.user

echo "$rgtidsp5" >> $rgtdatapath/data.config.user
echo "genome: $FAOng" >> $rgtdatapath/data.config.user
echo "chromosome_sizes: $Ongchr" >> $rgtdatapath/data.config.user
echo "genes_Gencode: $OnggenGC" >> $rgtdatapath/data.config.user
echo "genes_RefSeq: $OnggenRS" >> $rgtdatapath/data.config.user
echo "annotation: $annotOng" >> $rgtdatapath/data.config.user
echo "gene_alias: $Onggenal" >> $rgtdatapath/data.config.user
printf '\n' >> $rgtdatapath/data.config.user

echo "$rgtidsp6" >> $rgtdatapath/data.config.user
echo "genome: $FAAcg" >> $rgtdatapath/data.config.user
echo "chromosome_sizes: $Acgchr" >> $rgtdatapath/data.config.user
echo "genes_Gencode: $AcggenGC" >> $rgtdatapath/data.config.user
echo "genes_RefSeq: $AcggenRS" >> $rgtdatapath/data.config.user
echo "annotation: $annotAcg" >> $rgtdatapath/data.config.user
echo "gene_alias: $Acggenal" >> $rgtdatapath/data.config.user
printf '\n' >> $rgtdatapath/data.config.user

echo '[MotifData]' >> $rgtdatapath/data.config.user
echo "pwm_dataset: motifs" >> $rgtdatapath/data.config.user # Contains the path to the motif position weight matrices (PWM) repositories.
echo "logo_dataset: logos" >> $rgtdatapath/data.config.user # Contains the path to the logo graphs (graphical depiction of PWMs). Look here: http://www.regulatory-genomics.org/additional-motif-data/
echo "repositories: cichlidmzCSsp, cichlidpnCSsp, cichlidabCSsp, cichlidnbCSsp, cichlidonCSsp, cichlidacCSsp, cichlidCW, cichlidJASPAR, jaspar_vertebrates, hocomoco, jaspar_plants, uniprobe_primary, uniprobe_secondary" >> $rgtdatapath/data.config.user #  	The PWM repositories that will be used in the analyses. It is a comma-separated list of folders inside <pwm_dataset> (see this option above) folder.
printf '\n' >> $rgtdatapath/data.config.user

## C. Create an array to work on files of each species

# Create narrowPeak file paths for each species - can change species IDs for footprinting here
for Afpsp in "${!fpsp@}"; do
  # echo "$Afpsp is set to ${!Afpsp}"
  ls -1 $idrdir/"${!Afpsp}"*.final.narrowPeak >> $tffprdir/"${!Afpsp}"peakpaths.txt
done
# ls -1 $idrdir/*Ac*.final.narrowPeak > $tffprdir/Acpeakpaths.txt # Ac filenames are a little different so above will not work!!

# this will assign peakpaths files to ${fpsp@}peaks variables e.g. $Abpeaks
for Bfpsp in "${!fpsp@}"; do
  # echo "$Bfpsp is set to ${!Bfpsp}"
  eval "${!Bfpsp}"peaks=${tffprdir}/"${!Bfpsp}"peakpaths.txt
done

# get the total number of files for array and assign to variables e.g. $Abpeararrayend for each species, and then assign script variables for running footprinting e.g. $AbFPscript
for Cfpsp in "${!fpsp@}"; do
  # echo "$Cfpsp is set to ${!Cfpsp}"
  eval "${!Cfpsp}"peaks=${tffprdir}/"${!Cfpsp}"peakpaths.txt
  eval "${!Cfpsp}"peararrayend=$(wc -l "${!Cfpsp}"peakpaths.txt | awk -v e="$e" '{print ($1 - e)}')
  eval "${!Cfpsp}"FPscript="${!Cfpsp}"_TFfp.sh
done

## D. run TF footprinting and creating signal tracks e.g. https://www.regulatory-genomics.org/hint/tutorial/

## Da. Prepare PWM files/folders and data.config.user to use own motifs and genome info

# ## Daa. Prepare and move pwm's to specfic path - NOTE: this is relatively hardcoded and thus needs changing for future work
#
# # split to create multiple meme files
#
# for Apwmsp in "${!pwmsp@}"; do
#   # echo "$Apwmsp is set to ${!Apwmsp}"
#   mkdir -p $rgtdatapath/motifs/cichlid"${!Apwmsp}"CSsp
#   # python3 $splitmeme -i /tgac/workarea/group-vh/Tarang/Cichlid_GRNs/Arboretum_GT_v3/1.TFBSs_v2/FINAL_cichlidPWM_motifs/MouseDerived/2a_CS_"${!Apwmsp}".meme -o $rgtdatapath/motifs/cichlid"${!Apwmsp}"CSsp/tmp -t CS -s "${!Apwmsp}"
#   # rm $rgtdatapath/motifs/cichlid"${!Apwmsp}"CSsp/tmp/MEME_CS_"${!Apwmsp}".meme
# done
#
# mkdir -p $rgtdatapath/motifs/cichlidCW
# # python3 $splitmeme -i /tgac/workarea/group-vh/Tarang/Cichlid_GRNs/Arboretum_GT_v3/1.TFBSs_v2/FINAL_cichlidPWM_motifs/MouseDerived/2b_CW_mz.meme -o $rgtdatapath/motifs/cichlidCW/tmp -t CW -s CW
# # rm $rgtdatapath/motifs/cichlidCW/tmp/MEME_CW_CW.meme
#
# mkdir -p $rgtdatapath/motifs/cichlidJASPAR
# # python3 $splitmeme -i /tgac/workarea/group-vh/Tarang/Cichlid_GRNs/Arboretum_GT_v3/1.TFBSs_v2/FINAL_cichlidPWM_motifs/MouseDerived/2c_JASPAR_mz.meme -o $rgtdatapath/motifs/cichlidJASPAR/tmp -t CJP -s CJP
# # rm $rgtdatapath/motifs/cichlidJASPAR/tmp/MEME_CJP_CJP.meme
#
# # .. Need to convert meme format to JASPAR2016 format - use R universal matrix
# for i in /Users/mehtat/Documents/TGAC/Projects/Cichlid_GRNs/Arboretum_GT_v3/1.TFBSs_v2/FINAL_cichlidPWM_motifs/MouseDerived/{CS,CW,JP}/{mz,pn,ab,nb,on}/*.meme; do
#   Rscript ~/github/ATAC_bioinformatics/meme2jaspar.R -i ${i} -o "$(echo ${i} | sed 's/.meme/.tmp.pwm/g')"
# done
#
# # .. convert JASPAR 2016 CFM PWM to JASPAR OLD PFM format by removing header, nucleotides and square brackets
# for i in /Users/mehtat/Documents/TGAC/Projects/Cichlid_GRNs/Arboretum_GT_v3/1.TFBSs_v2/FINAL_cichlidPWM_motifs/MouseDerived/{CS,CW}/{mz,pn,ab,nb,on}/*.tmp.pwm; do
#   awk '!/^>/' ${i} | sed 's/A \[  //g' | sed 's/T \[  //g' | sed 's/C \[  //g' | sed 's/G \[  //g' | sed 's/ \]//g' | grep . > "$(echo ${i} | sed 's/.tmp.pwm/.pwm/g')"
#   rm ${i}
# done
# for i in /Users/mehtat/Documents/TGAC/Projects/Cichlid_GRNs/Arboretum_GT_v3/1.TFBSs_v2/FINAL_cichlidPWM_motifs/MouseDerived/JP/mz/*.tmp.pwm; do
#   awk '!/^>/' ${i} | sed 's/A \[  //g' | sed 's/T \[  //g' | sed 's/C \[  //g' | sed 's/G \[  //g' | sed 's/ \]//g' | grep . > "$(echo ${i} | sed 's/.tmp.pwm/.pwm/g')"
#   rm ${i}
# done
#
# # .. move new PWMs to sub dirs
# mkdir -p /Users/mehtat/Documents/TGAC/Projects/Cichlid_GRNs/Arboretum_GT_v3/1.TFBSs_v2/FINAL_cichlidPWM_motifs/MouseDerived/{CS,CW}/{mz,pn,ab,nb,on}/JPoldPWMformat
# mkdir -p /Users/mehtat/Documents/TGAC/Projects/Cichlid_GRNs/Arboretum_GT_v3/1.TFBSs_v2/FINAL_cichlidPWM_motifs/MouseDerived/JP/mz/JPoldPWMformat
# for i in /Users/mehtat/Documents/TGAC/Projects/Cichlid_GRNs/Arboretum_GT_v3/1.TFBSs_v2/FINAL_cichlidPWM_motifs/MouseDerived/{CS,CW}/{mz,pn,ab,nb,on}; do
#   mv ${i}/*.pwm ${i}/JPoldPWMformat
# done
#
# for i in /Users/mehtat/Documents/TGAC/Projects/Cichlid_GRNs/Arboretum_GT_v3/1.TFBSs_v2/FINAL_cichlidPWM_motifs/MouseDerived/JP/mz; do
#   mv ${i}/*.pwm ${i}/JPoldPWMformat
# done
#
#
# # .. move the created PWM to HPC
# for i in mz pn ab nb on; do
#   cp -r /tgac/workarea/group-vh/Tarang/ATACseq/motifs/CS/${i}/JPoldPWMformat/* $rgtdatapath/motifs/cichlid"${i}"CSsp
# done
#
# cp -r /tgac/workarea/group-vh/Tarang/ATACseq/motifs/CW/mz/JPoldPWMformat/* $rgtdatapath/motifs/cichlidCW
# cp -r /tgac/workarea/group-vh/Tarang/ATACseq/motifs/JP/mz/JPoldPWMformat/* $rgtdatapath/motifs/cichlidJASPAR
#
# # .. convert preexisting *.eps logos to *.png for cichlid PWMs and move to $rgtdatapath/motifs/logos
# # use imagemagick: 'brew install imagemagick'; 'brew install ghostscript'
# for i in /Users/mehtat/Documents/TGAC/Projects/Cichlid_GRNs/Arboretum_GT_v3/1.TFBSs_v2/FINAL_cichlidPWM_motifs/MouseDerived/CS/{mz,pn,ab,nb,on}/logos; do
#   mkdir ${i}/png
# done
#
# for i in /Users/mehtat/Documents/TGAC/Projects/Cichlid_GRNs/Arboretum_GT_v3/1.TFBSs_v2/FINAL_cichlidPWM_motifs/MouseDerived/CS/{mz,pn,ab,nb,on}/logos/*.eps; do
#   convert -density 150 ${i} $(echo ${i} | sed 's/.eps/.png/g')
# done
#
# for i in /Users/mehtat/Documents/TGAC/Projects/Cichlid_GRNs/Arboretum_GT_v3/1.TFBSs_v2/FINAL_cichlidPWM_motifs/MouseDerived/CS/{mz,pn,ab,nb,on}/logos; do
#   mv ${i}/*.png ${i}/png
# done
#
# for i in /Users/mehtat/Documents/TGAC/Projects/Cichlid_GRNs/Arboretum_GT_v3/1.TFBSs_v2/FINAL_cichlidPWM_motifs/MouseDerived/{CW,JP}/mz/logos; do
#   mkdir ${i}/png
# done
#
# for i in /Users/mehtat/Documents/TGAC/Projects/Cichlid_GRNs/Arboretum_GT_v3/1.TFBSs_v2/FINAL_cichlidPWM_motifs/MouseDerived/{CW,JP}/mz/logos/*.eps; do
#   convert -density 150 ${i} $(echo ${i} | sed 's/.eps/.png/g')
# done
#
# for i in /Users/mehtat/Documents/TGAC/Projects/Cichlid_GRNs/Arboretum_GT_v3/1.TFBSs_v2/FINAL_cichlidPWM_motifs/MouseDerived/{CW,JP}/mz/logos; do
#   mv ${i}/*.png ${i}/png
# done
#
# # copy to group workarea on HPC and then to $rgtdatapath/logos (once logo generation has ran)
# for i in mz pn ab nb on; do
#   mkdir -p $rgtdatapath/logos/cichlid"${i}"CSsp
#   cp -r /tgac/workarea/group-vh/Tarang/ATACseq/motifs/CS/${i}/logos/* $rgtdatapath/logos/cichlid"${i}"CSsp
# done
#
# mkdir -p $rgtdatapath/logos/cichlidCW; cp -r /tgac/workarea/group-vh/Tarang/ATACseq/motifs/CW/mz/logos/* $rgtdatapath/logos/cichlidCW
# mkdir -p $rgtdatapath/logos/cichlidJASPAR; cp -r /tgac/workarea/group-vh/Tarang/ATACseq/motifs/JP/mz/logos/* $rgtdatapath/logos/cichlidJASPAR
#
#
# # .. Consider making the tab delimited *.mtf files for selected motifs: see https://www.regulatory-genomics.org/motif-analysis/additional-motif-data/
# # AHR	AHR_HUMAN.H11MO.0.B	0.B	AHR	PAS domain factors	P35869	Integrative	vertebrates	Homo sapiens	2.8475,6.6065,8.544,11.1115,11.6185,12.7235
# # The first field simply the clean “name” of the motif.
# # The second field is the full, unique, original name of the motif.
# # The third field is the version of this motif (it changes slightly across different repositories)
# # The fourth field is the TF gene name, the so-called “gene symbol”
# # The fifth field is the so-called “motif family”, a description that varies a lot across repositories. CHANGED THIS FOR ENSMUS ID
# # The sixth field is one or more Uniprot identifiers
# # The seventh field is the data source (Chip-Seq, Selex, Integrative)
# # The eight field is the taxonomic group
# # The ninth field is the species (usually the full name, eg “Home sapiens”, not “hs”)
# # The tenth field is a list of precomputed thresholds for several FPR values: 0.005, 0.001, 0.0005, 0.0001, 0.00005, 0.00001
# # NOTE: The good news is that you don’t need to set them all. Any field you do not want to set you can replace with a single dot.
#
# # .. cichlid{mz,pn,ab,nb,on}CSsp mtf files
# cichlidmeta=/Users/mehtat/Documents/TGAC/Projects/Cichlid_GRNs/Arboretum_GT_v3/1.TFBSs_v2/FINAL_cichlidPWM_motifs/MouseDerived/cichlid_allMm_motifs_meta_info.txt
# JPv2018map=/Users/mehtat/Documents/TGAC/Projects/Cichlid_GRNs/Arboretum_GT_v3/May2019_ReviewerComments/1.1b.RetinaMotifDivergence/JASPAR_Vertebrates_2018_motifname.OGID.txt
# ogids=/Users/mehtat/Documents/TGAC/Projects/Cichlid_GRNs/Arboretum_GT_v3/OGIDS.txt5
#
# cd /Users/mehtat/Documents/TGAC/Projects/Cichlid_GRNs/Arboretum_GT_v3/1.TFBSs_v2/FINAL_cichlidPWM_motifs/MouseDerived/CS/mz/JPoldPWMformat
# ls -1 *.pwm | awk '{print $1,$1}' OFS='\t' | awk -F'_' '{print $0,$7}' OFS='\t' | awk '{print $1,$3}' OFS='\t' | awk -F"\t" '{gsub(".ig","",$2)}1' OFS='\t' > cichlidmzCSsp.mtf.tmp1
# awk 'BEGIN{OFS="\t"}NR==FNR{a[$4]=$0;next}{if(a[$2]){print $0,a[$2];}else{print $0,".","NULL",".",".",".",".",".",".",".",".",".",".",".",".",".",".",".",".";}}' $JPv2018map cichlidmzCSsp.mtf.tmp1 | awk '{print $2,$4"_CS_"$2,$1,"CS_v1",$4,$20,".","Integrative","vertebrates","Metriaclima_zebra","4,8,12,16,20,24"}' OFS='\t' > cichlidmzCSsp.mtf.tmp2
#
# # # pull out all gene symbols in $cichlidmeta file using ensemblID
# # while read -r a b c d e f g h i j k; do
# #   # echo $e
# #   grep -A 25 -B 3 -wiF ${f} $cichlidmeta | grep 'Gene symbol\|Ensembl id' >> cichlidmzCSsp.mtf.tmp3
# # done < cichlidmzCSsp.mtf.tmp2
# # # convert the above output from rows to two columns
# # {
# # awk -F: 'BEGIN{ sl="Gene symbol"}
# #          $1~sl && head == 1 { head=0; exit 0}
# #          $1~sl && head == 0 { head=1; }
# #          head == 1 {
# #              gsub(/^[ \t]+/,"",$1);   # remove leading  spaces
# #              gsub(/[ \t]+$/,"",$1);   # remove trailing spaces
# #              printf( "%s\t", $1)
# #          }
# #          ' cichlidmzCSsp.mtf.tmp3
# # #echo
# # awk -F: 'BEGIN { sl="Gene symbol"}
# #          $1~sl { printf( "%s\n", "") }
# #          {
# #              gsub(/^[ \t]+/,"",$2);   # remove leading  spaces
# #              gsub(/[ \t]+$/,"",$2);   # remove trailing spaces
# #              printf( "%s\t", $2)
# #          }
# #          ' cichlidmzCSsp.mtf.tmp3
# # echo
# # } | column -t -s "$(printf '%b' '\t')" > cichlidmzCSsp.mtf.tmp4
# #
# # awk 'BEGIN{OFS="\t"}NR==FNR{a[$2]=$0;next}{if(a[$5]){print $0,a[$5];}else{print $0,".","NULL",".",".",".",".",".",".",".",".",".",".",".",".",".",".",".",".","NO","NO";}}' cichlidmzCSsp.mtf.tmp4 cichlidmzCSsp.mtf.tmp2 | awk '{print $4"_CS_"$2,$1,"CS_v1",$4,$20,".","Integrative","vertebrates","Metriaclima_zebra","4,8,12,16,20,24"}' OFS='\t' > cichlidmzCSsp.mtf.tmp5
#
# awk 'BEGIN{OFS="\t"}NR==FNR{a[$2]=$0;next}{if(a[$1]){print $0,a[$1];}else{print $0,"NA","NA","NA","NA","NA","NA","NA","NA","NA","NA","NA","NA","NA","NA","NA","NA";}}' $ogids cichlidmzCSsp.mtf.tmp2 | awk '{if($5 == "NULL")print $26"_CS_"$1,$3,$4,$26,$6,$7,$8,$9,$10,$11;else print $2,$3,$4,$5,$6,$7,$8,$9,$10,$11;}' OFS='\t' > cichlidmzCSsp.mtf
# rm cichlidmzCSsp.mtf.tmp*
#
# cd /Users/mehtat/Documents/TGAC/Projects/Cichlid_GRNs/Arboretum_GT_v3/1.TFBSs_v2/FINAL_cichlidPWM_motifs/MouseDerived/CS/pn/JPoldPWMformat
# ls -1 *.pwm | awk '{print $1,$1}' OFS='\t' | awk -F'_' '{print $0,$7}' OFS='\t' | awk '{print $1,$3}' OFS='\t' | awk -F"\t" '{gsub(".ig","",$2)}1' OFS='\t' > cichlidpnCSsp.mtf.tmp1
# awk 'BEGIN{OFS="\t"}NR==FNR{a[$5]=$0;next}{if(a[$2]){print $0,a[$2];}else{print $0,".","NULL",".",".",".",".",".",".",".",".",".",".",".",".",".",".",".",".";}}' $JPv2018map cichlidpnCSsp.mtf.tmp1 | awk '{print $2,$4"_CS_"$2,$1,"CS_v1",$4,$20,".","Integrative","vertebrates","Pundamilia_nyererei","4,8,12,16,20,24"}' OFS='\t' > cichlidpnCSsp.mtf.tmp2
# awk 'BEGIN{OFS="\t"}NR==FNR{a[$3]=$0;next}{if(a[$1]){print $0,a[$1];}else{print $0,"NA","NA","NA","NA","NA","NA","NA","NA","NA","NA","NA","NA","NA","NA","NA","NA";}}' $ogids cichlidpnCSsp.mtf.tmp2 | awk '{if($5 == "NULL")print $26"_CS_"$1,$3,$4,$26,$6,$7,$8,$9,$10,$11;else print $2,$3,$4,$5,$6,$7,$8,$9,$10,$11;}' OFS='\t' > cichlidpnCSsp.mtf
# rm cichlidpnCSsp.mtf.tmp*
#
# cd /Users/mehtat/Documents/TGAC/Projects/Cichlid_GRNs/Arboretum_GT_v3/1.TFBSs_v2/FINAL_cichlidPWM_motifs/MouseDerived/CS/ab/JPoldPWMformat
# ls -1 *.pwm | awk '{print $1,$1}' OFS='\t' | awk -F'_' '{print $0,$7}' OFS='\t' | awk '{print $1,$3}' OFS='\t' | awk -F"\t" '{gsub(".ig","",$2)}1' OFS='\t' > cichlidabCSsp.mtf.tmp1
# awk 'BEGIN{OFS="\t"}NR==FNR{a[$6]=$0;next}{if(a[$2]){print $0,a[$2];}else{print $0,".","NULL",".",".",".",".",".",".",".",".",".",".",".",".",".",".",".",".";}}' $JPv2018map cichlidabCSsp.mtf.tmp1 | awk '{print $2,$4"_CS_"$2,$1,"CS_v1",$4,$20,".","Integrative","vertebrates","Astatotilapia_burtoni","4,8,12,16,20,24"}' OFS='\t' > cichlidabCSsp.mtf.tmp2
# awk 'BEGIN{OFS="\t"}NR==FNR{a[$4]=$0;next}{if(a[$1]){print $0,a[$1];}else{print $0,"NA","NA","NA","NA","NA","NA","NA","NA","NA","NA","NA","NA","NA","NA","NA","NA";}}' $ogids cichlidabCSsp.mtf.tmp2 | awk '{if($5 == "NULL")print $26"_CS_"$1,$3,$4,$26,$6,$7,$8,$9,$10,$11;else print $2,$3,$4,$5,$6,$7,$8,$9,$10,$11;}' OFS='\t' > cichlidabCSsp.mtf
# rm cichlidabCSsp.mtf.tmp*
#
# cd /Users/mehtat/Documents/TGAC/Projects/Cichlid_GRNs/Arboretum_GT_v3/1.TFBSs_v2/FINAL_cichlidPWM_motifs/MouseDerived/CS/nb/JPoldPWMformat
# ls -1 *.pwm | awk '{print $1,$1}' OFS='\t' | awk -F'_' '{print $0,$7}' OFS='\t' | awk '{print $1,$3}' OFS='\t' | awk -F"\t" '{gsub(".ig","",$2)}1' OFS='\t' > cichlidnbCSsp.mtf.tmp1
# awk 'BEGIN{OFS="\t"}NR==FNR{a[$7]=$0;next}{if(a[$2]){print $0,a[$2];}else{print $0,".","NULL",".",".",".",".",".",".",".",".",".",".",".",".",".",".",".",".";}}' $JPv2018map cichlidnbCSsp.mtf.tmp1 | awk '{print $2,$4"_CS_"$2,$1,"CS_v1",$4,$20,".","Integrative","vertebrates","Neolamprologus_brichardi","4,8,12,16,20,24"}' OFS='\t' > cichlidnbCSsp.mtf.tmp2
# awk 'BEGIN{OFS="\t"}NR==FNR{a[$5]=$0;next}{if(a[$1]){print $0,a[$1];}else{print $0,"NA","NA","NA","NA","NA","NA","NA","NA","NA","NA","NA","NA","NA","NA","NA","NA";}}' $ogids cichlidnbCSsp.mtf.tmp2 | awk '{if($5 == "NULL")print $26"_CS_"$1,$3,$4,$26,$6,$7,$8,$9,$10,$11;else print $2,$3,$4,$5,$6,$7,$8,$9,$10,$11;}' OFS='\t' > cichlidnbCSsp.mtf
# rm cichlidnbCSsp.mtf.tmp*
#
# cd /Users/mehtat/Documents/TGAC/Projects/Cichlid_GRNs/Arboretum_GT_v3/1.TFBSs_v2/FINAL_cichlidPWM_motifs/MouseDerived/CS/on/JPoldPWMformat
# ls -1 *.pwm | awk '{print $1,$1}' OFS='\t' | awk -F'_' '{print $0,$7}' OFS='\t' | awk '{print $1,$3}' OFS='\t' | awk -F"\t" '{gsub(".ig","",$2)}1' OFS='\t' > cichlidonCSsp.mtf.tmp1
# awk 'BEGIN{OFS="\t"}NR==FNR{a[$8]=$0;next}{if(a[$2]){print $0,a[$2];}else{print $0,".","NULL",".",".",".",".",".",".",".",".",".",".",".",".",".",".",".",".";}}' $JPv2018map cichlidonCSsp.mtf.tmp1 | awk '{print $2,$4"_CS_"$2,$1,"CS_v1",$4,$20,".","Integrative","vertebrates","Oreochromis_niloticus","4,8,12,16,20,24"}' OFS='\t' > cichlidonCSsp.mtf.tmp2
# awk 'BEGIN{OFS="\t"}NR==FNR{a[$6]=$0;next}{if(a[$1]){print $0,a[$1];}else{print $0,"NA","NA","NA","NA","NA","NA","NA","NA","NA","NA","NA","NA","NA","NA","NA","NA";}}' $ogids cichlidonCSsp.mtf.tmp2 | awk '{if($5 == "NULL")print $26"_CS_"$1,$3,$4,$26,$6,$7,$8,$9,$10,$11;else print $2,$3,$4,$5,$6,$7,$8,$9,$10,$11;}' OFS='\t' > cichlidonCSsp.mtf
# rm cichlidonCSsp.mtf.tmp*
#
# cp /tgac/workarea/group-vh/Tarang/ATACseq/motifs/cichlid*CSsp.mtf $rgtdatapath/motifs/
#
#
# # .. cichlidCW mtf file
# cd /Users/mehtat/Documents/TGAC/Projects/Cichlid_GRNs/Arboretum_GT_v3/1.TFBSs_v2/FINAL_cichlidPWM_motifs/MouseDerived/CW/mz/JPoldPWMformat
# JPv2018map=/Users/mehtat/Documents/TGAC/Projects/Cichlid_GRNs/Arboretum_GT_v3/May2019_ReviewerComments/1.1b.RetinaMotifDivergence/JASPAR_Vertebrates_2018_motifname.OGID.txt
# ls -1 *.pwm | awk '{print $1,$1}' OFS='\t' | awk -F'_' '{print $0,$20}' OFS='\t' | awk '{print $1,$3}' OFS='\t' > cichlidCW.mtf.tmp1
# awk 'BEGIN{OFS="\t"}NR==FNR{a[$18]=$0;next}{if(a[$2]){print $0,a[$2];}else{print $0,".","NULL",".",".",".",".",".",".",".",".",".",".",".",".",".",".",".",".";}}' $JPv2018map cichlidCW.mtf.tmp1 | awk '{print $4"_CW_"$2,$1,"CW_v1",$4,".",".","Integrative","vertebrates","Cichlidae","."}' OFS='\t' > cichlidCW.mtf
# rm cichlidCW.mtf.tmp1
# # fill in some blanks manually by searching in other mapping file:
# # for i in ENSMUSG00000025025 ENSMUSG00000028023 ENSMUSG00000030087 ENSMUSG00000061911; do grep -A 25 -B 3 ${i} $cichlidmeta | grep 'Gene symbol\|Ensembl id'; done
# cp /tgac/workarea/group-vh/Tarang/ATACseq/motifs/cichlidCW.mtf $rgtdatapath/motifs/
#
#
#
# # .. cichlid JASPAR 2018 mtf file
# cd /Users/mehtat/Documents/TGAC/Projects/Cichlid_GRNs/Arboretum_GT_v3/1.TFBSs_v2/FINAL_cichlidPWM_motifs/MouseDerived/JP/mz/JPoldPWMformat
# JPv2018map=/Users/mehtat/Documents/TGAC/Projects/Cichlid_GRNs/Arboretum_GT_v3/May2019_ReviewerComments/1.1b.RetinaMotifDivergence/JASPAR_Vertebrates_2018_motifname.OGID.txt
# awk '{print $1,$1,"JPv2018",$2,".",".","Integrative","vertebrates","Mus musculus","."}' OFS='\t' $JPv2018map > cichlidJASPAR.mtf
# cp /tgac/workarea/group-vh/Tarang/ATACseq/motifs/cichlidJASPAR.mtf $rgtdatapath/motifs/
#
#
# ## Dab. generate logos of above
# cd $rgtdatapath
#
#
# nano setuplogo.sh
#
# #!/bin/bash -e
# #SBATCH -p ei-short # partition (queue)
# #SBATCH -N 1 # number of nodes
# #SBATCH -n 1 # number of tasks
# #SBATCH --array=0-4
# #SBATCH --mem-per-cpu 12000
# #SBATCH -t 0-00:45
# #SBATCH --mail-type=ALL # notifications for job done & fail
# #SBATCH --mail-user=Tarang.Mehta@earlham.ac.uk # send-to address
# #SBATCH -o slurm.%N.%j.out # STDOUT
# #SBATCH -e slurm.%N.%j.err # STDERR
#
# echo 'hocomoco' > motiflist
# echo 'jaspar_plants' >> motiflist
# echo 'jaspar_vertebrates' >> motiflist
# echo 'uniprobe_primary' >> motiflist
# echo 'uniprobe_secondary' >> motiflist
#
# mapfile -t motiflist < motiflist
#
# # NOTE: the python script requires an active internet connection to access weblogo
# USERNAME=mehtat
# HOSTNAME="software"
# PWD=$(pwd)
# SCRIPT="cd ${PWD}; python3 setupLogoData.py ${motiflist[${SLURM_ARRAY_TASK_ID}]}; exit" # generate logos for all motifs subdirs
# ssh -o StrictHostKeyChecking=no -l ${USERNAME} ${HOSTNAME} "${SCRIPT}"
#
# # run the above
# sbatch setuplogo.sh
#
##. Add A. calliptera using M. zebra motifs {copy and rename M. zebra motifs}
# cp -r $rgtdatapath/motifs/cichlidmzCSsp $rgtdatapath/motifs/cichlidacCSsp
# cp -r $rgtdatapath/logos/cichlidmzCSsp $rgtdatapath/logos/cichlidacCSsp
#
# # insert above data to config file
# echo '[MotifData]' >> $rgtdatapath/data.config.user
# echo "pwm_dataset: motifs" >> $rgtdatapath/data.config.user # Contains the path to the motif position weight matrices (PWM) repositories.
# echo "logo_dataset: logos" >> $rgtdatapath/data.config.user # Contains the path to the logo graphs (graphical depiction of PWMs). Look here: http://www.regulatory-genomics.org/additional-motif-data/
# echo "repositories: cichlidmzCSsp, cichlidpnCSsp, cichlidabCSsp, cichlidnbCSsp, cichlidonCSsp, cichlidacCSsp, cichlidCW, cichlidJASPAR, jaspar_vertebrates, hocomoco, jaspar_plants, uniprobe_primary, uniprobe_secondary" >> $rgtdatapath/data.config.user #  	The PWM repositories that will be used in the analyses. It is a comma-separated list of folders inside <pwm_dataset> (see this option above) folder.


## Db. Prepare scripts for footprinting + motif matching

##### ~~~~~ #####
# NOTE: for each run, the following was ran/loaded for footprinting
# pseudocounts: 1.0
# used database(s): cichlid{mz,pn,ab,nb,on,ac}CSsp,cichlidCW,cichlidJASPAR,jaspar_vertebrates,hocomoco
# fpr threshold for footprinting: 0.0001
# motifs loaded: 2042
##### ~~~~~ #####

############################################################################################################################

# rgt-hint footprinting output is a bed-file, *_mpbs.bed and .info file for number of peaks and footprints
# the *_mpbs.bed file contains the following cols
# col1 - chr, col2 - start, col3 - end, col4 - motifID, col5 - bit-score of the motif matching, col6 - strand


# The output of HINT-ATAC footprinting is a .bed-file of footprint ranges ranked by tag count.
# All TFBS overlapping a footprint with more than 2/3 of the TFBS bases was assumed to be bound and scored using the tag count of the footprint.
# The rest of the TFBS (within peaks) were set to score 0 (low chance of protein binding).
# The auROC was calculated based on the ability of these scores to predict true protein binding.
# It should be noted that this affects the shape of the ROC curve, as all TFBS without overlaps are assumed to have the same probability of being bound.
# However, this is a characteristic of the method, and HINT-ATAC was therefore evaluated on the same premise as other tools.

# rgt-motifanalysis matching
# output is a BED file for each input file, containing the matched motif instances for each footprint region. The 4th column contains the motif name and the 5th column the bit-score of the motif match.

# rgt-hint differential
# output are lineplots of the footprinting - can be run for single and/or multiple samples
############################################################################################################################


# NOTE: in below, the following VARIABLES are harcoded into the script - IF the species id etc. are changed at the top then they ALSO NEED TO BE CHANGED IN THE SCRIPT BELOW!!!!!!
# fpsp*
# rgtidsp*
# rgtidsp*a
# pwmsp*
# NOTE: In the /hpc-home/mehtat/rgtdata/motifs/cichlid*.mtf files, you have arbitrarily set the FPR thresholds to the following:
# 0.005 = 4
# 0.001 = 8
# 0.0005 = 12
# 0.0001 = 16
# 0.00005 = 20
# 0.00001 = 24
# If you want to change this then you have to change in all the cichlid*.mtf files - only picked arbitrary numbers as simply entering a '.' does not work (even though the documentation said it does!)
# script to do this:
# for i in ~/rgtdata/motifs/cichlid*.mtf; do
#   #awk '{print $1,$2,$3,$4,$5,$6,$7,$8,$9,".,.,.,.,.,."}' OFS='\t' $i > ${i}2
#   awk '{print $1,$2,$3,$4,$5,$6,$7,$8,$9,"4,8,12,16,20,24"}' OFS='\t' $i > ${i}2
#   rm $i
#   mv ${i}2 $i
# done


# The samtools sort and index doesn't finish before RGT-HINT starts and thus, does not run; therefore there are two for loops below to create two separate scripts

# create the relevant files for mapping in array
for Dfpsp in "${!fpsp@}"; do
  # echo "$Dfpsp is set to ${!Dfpsp}"
  # 1. prepare a prefix file using the peaks file e.g. $Abpeaks
  awk -F'/' ' { print $NF } ' $(eval echo \$"${!Dfpsp}"peaks) | sed 's/_peaks.final.narrowPeak//g' > "${!Dfpsp}"prefixes.txt
  # 2. prepare another file to iterate the input BAM files (can use the array on this) - echo the *peakarray and sed replace to prepare the path (will have to use the mapfile from above to add the prefix to peak calling folder)
  sed "s|$idrdir|$annotdir|g" "${!Dfpsp}"peakpaths.txt | sed 's/_peaks.final.narrowPeak//g' | awk -F'/' ' { print $0"/"$NF } ' | sed 's|$|.nochrM.nodup.filt.shifted.bam|g' > "${!Dfpsp}"inputBAM.txt
  # 3. create signal prefix file
  sed 's/$/_BC/g' "${!Dfpsp}"prefixes.txt > "${!Dfpsp}"signalprefixes.txt
done

for Dfpsp in "${!fpsp@}"; do
  # echo "$Dfpsp is set to ${!Dfpsp}"
  echo '#!/bin/bash -e' > "${!Dfpsp}"'_TFfp.sh'
  echo '#SBATCH -p ei-medium # partition (queue)' >> "${!Dfpsp}"'_TFfp.sh'
  echo '#SBATCH -N 1 # number of nodes' >> "${!Dfpsp}"'_TFfp.sh'
  echo '#SBATCH -n 1 # number of tasks' >> "${!Dfpsp}"'_TFfp.sh'
  echo '#SBATCH --array=0-'"$(eval "echo \$"${!Dfpsp}"peararrayend")" >> "${!Dfpsp}"'_TFfp.sh'
  echo '#SBATCH --mem-per-cpu 48000' >> "${!Dfpsp}"'_TFfp.sh'
  echo '#SBATCH -t 0-05:59' >> "${!Dfpsp}"'_TFfp.sh'
  echo '#SBATCH --constraint=intel' >> "${!Dfpsp}"'_TFfp.sh'
  echo '#SBATCH --mail-type=ALL # notifications for job done & fail' >> "${!Dfpsp}"'_TFfp.sh'
  echo '#SBATCH --mail-user=Tarang.Mehta@earlham.ac.uk # send-to address' >> "${!Dfpsp}"'_TFfp.sh'
  echo '#SBATCH -o slurm.%N.%j.out # STDOUT' >> "${!Dfpsp}"'_TFfp.sh'
  echo '#SBATCH -e slurm.%N.%j.err # STDERR' >> "${!Dfpsp}"'_TFfp.sh'
  printf '\n' >> "${!Dfpsp}"'_TFfp.sh'
  echo "ml samtools/1.7" >> "${!Dfpsp}"'_TFfp.sh'
  echo 'export PATH="$PATH:/hpc-home/mehtat/.local/bin/"' >> "${!Dfpsp}"'_TFfp.sh'
  printf '\n' >> "${!Dfpsp}"'_TFfp.sh'
  echo "rgtidsp1='[MzebraUMD2a]'" >> "${!Dfpsp}"'_TFfp.sh'
  echo "rgtidsp2='[PunNye1.0]'" >> "${!Dfpsp}"'_TFfp.sh'
  echo "rgtidsp3='[AstBur1.0]'" >> "${!Dfpsp}"'_TFfp.sh'
  echo "rgtidsp4='[NeoBri1.0]'" >> "${!Dfpsp}"'_TFfp.sh'
  echo "rgtidsp5='[OniloticusUMD]'" >> "${!Dfpsp}"'_TFfp.sh'
  echo "rgtidsp6='[fAstCal1.2]'" >> "${!Dfpsp}"'_TFfp.sh'
  echo "rgtidsp1a='MzebraUMD2a'" >> "${!Dfpsp}"'_TFfp.sh'
  echo "rgtidsp2a='PunNye1.0'" >> "${!Dfpsp}"'_TFfp.sh'
  echo "rgtidsp3a='AstBur1.0'" >> "${!Dfpsp}"'_TFfp.sh'
  echo "rgtidsp4a='NeoBri1.0'" >> "${!Dfpsp}"'_TFfp.sh'
  echo "rgtidsp5a='OniloticusUMD'" >> "${!Dfpsp}"'_TFfp.sh'
  echo "rgtidsp6a='fAstCal1.2'" >> "${!Dfpsp}"'_TFfp.sh'
  echo "fpsp1=Mz" >> "${!Dfpsp}"'_TFfp.sh'
  echo "fpsp2=Pn" >> "${!Dfpsp}"'_TFfp.sh'
  echo "fpsp3=Ab" >> "${!Dfpsp}"'_TFfp.sh'
  echo "fpsp4=Nb" >> "${!Dfpsp}"'_TFfp.sh'
  echo "fpsp5=On" >> "${!Dfpsp}"'_TFfp.sh'
  echo "fpsp6=Ac" >> "${!Dfpsp}"'_TFfp.sh'
  echo "pwmsp1=mz" >> "${!Dfpsp}"'_TFfp.sh'
  echo "pwmsp2=pn" >> "${!Dfpsp}"'_TFfp.sh'
  echo "pwmsp3=ab" >> "${!Dfpsp}"'_TFfp.sh'
  echo "pwmsp4=nb" >> "${!Dfpsp}"'_TFfp.sh'
  echo "pwmsp5=on" >> "${!Dfpsp}"'_TFfp.sh'
  echo "pwmsp6=ac" >> "${!Dfpsp}"'_TFfp.sh'
  printf '\n' >> "${!Dfpsp}"'_TFfp.sh'
  echo '# 0. mapfile the narrowPeak files' >> "${!Dfpsp}"'_TFfp.sh'
  echo "mapfile -t ${!Dfpsp}peakarray < $(eval "echo \$"${!Dfpsp}peaks) # assign files to variable for array" >> "${!Dfpsp}"'_TFfp.sh'
  echo 'echo "# 0. mapfile the narrowPeak files ~~ DONE"' >> "${!Dfpsp}"'_TFfp.sh'
  printf '\n' >> "${!Dfpsp}"'_TFfp.sh'
  echo '# 1. prepare a prefix file using the peaks file e.g. $Abpeaks' >> "${!Dfpsp}"'_TFfp.sh'
  echo "${!Dfpsp}prefix=(${!Dfpsp}prefixes.txt)" >> "${!Dfpsp}"'_TFfp.sh'
  echo "#awk -F'/' ' { print "'$NF } '"' $(eval "echo \$"${!Dfpsp}peaks) | sed 's/_peaks.final.narrowPeak//g' > \$${!Dfpsp}prefix" >> "${!Dfpsp}"'_TFfp.sh'
  echo 'echo "# 1. prepare a prefix file using the peaks file e.g. $Abpeaks ~~ DONE"' >> "${!Dfpsp}"'_TFfp.sh'
  printf '\n' >> "${!Dfpsp}"'_TFfp.sh'
  echo '# 2. mapfile the above file' >> "${!Dfpsp}"'_TFfp.sh'
  echo "mapfile -t ${!Dfpsp}prefixes < \$${!Dfpsp}prefix" >> "${!Dfpsp}"'_TFfp.sh'
  echo 'echo "# 2. mapfile the above file ~~ DONE"' >> "${!Dfpsp}"'_TFfp.sh'
  printf '\n' >> "${!Dfpsp}"'_TFfp.sh'
  echo '# 3. prepare another file to iterate the input BAM files (can use the array on this) - echo the *peakarray and sed replace to prepare the path (will have to use the mapfile from above to add the prefix to peak calling folder)' >> "${!Dfpsp}"'_TFfp.sh'
  echo "${!Dfpsp}BAM=(${!Dfpsp}inputBAM.txt)" >> "${!Dfpsp}"'_TFfp.sh'
  echo '#echo '"\${${!Dfpsp}"'peakarray[${SLURM_ARRAY_TASK_ID}]} | sed "s|'"$idrdir|$annotdir/\${${!Dfpsp}"'prefixes[${SLURM_ARRAY_TASK_ID}]}|g" | sed '"'s/_peaks.final.narrowPeak/.nochrM.nodup.filt.shifted.bam/g' >> \$${!Dfpsp}BAM" >> "${!Dfpsp}"'_TFfp.sh'
  echo 'echo "# 3. prepare another file to iterate the input BAM files (can use the array on this) - echo the *peakarray and sed replace to prepare the path (will have to use the mapfile from above to add the prefix to peak calling folder) ~~ DONE"' >> "${!Dfpsp}"'_TFfp.sh'
  printf '\n' >> "${!Dfpsp}"'_TFfp.sh'
  echo '# 4. mapfile the file from above' >> "${!Dfpsp}"'_TFfp.sh'
  echo "mapfile -t ${!Dfpsp}BAM < \$${!Dfpsp}BAM" >> "${!Dfpsp}"'_TFfp.sh'
  echo 'echo "# 4. mapfile the file from above ~~ DONE"' >> "${!Dfpsp}"'_TFfp.sh'
  printf '\n' >> "${!Dfpsp}"'_TFfp.sh'
  echo '# 5. run samtools sort and index and drop in this folder' >> "${!Dfpsp}"'_TFfp.sh'
  echo 'samtools sort '"\${${!Dfpsp}"'BAM[${SLURM_ARRAY_TASK_ID}]} -o "$(basename "'"\${${!Dfpsp}"'BAM[${SLURM_ARRAY_TASK_ID}]}" .bam).sorted.bam"' >> "${!Dfpsp}"'_TFfp.sh'
  echo 'samtools index "$(basename "'"\${${!Dfpsp}"'BAM[${SLURM_ARRAY_TASK_ID}]}" .bam).sorted.bam"' >> "${!Dfpsp}"'_TFfp.sh'
  echo 'echo "# 5. run samtools sort and index and drop in this folder ~~ DONE"' >> "${!Dfpsp}"'_TFfp.sh'
done

for Dfpsp in "${!fpsp@}"; do
  # echo "$Dfpsp is set to ${!Dfpsp}"
  echo '#!/bin/bash -e' > "${!Dfpsp}"'_TFfp_b.sh'
  echo '#SBATCH -p ei-medium # partition (queue)' >> "${!Dfpsp}"'_TFfp_b.sh'
  echo '#SBATCH -N 1 # number of nodes' >> "${!Dfpsp}"'_TFfp_b.sh'
  echo '#SBATCH -n 1 # number of tasks' >> "${!Dfpsp}"'_TFfp_b.sh'
  echo '#SBATCH --array=0-'"$(eval "echo \$"${!Dfpsp}"peararrayend")" >> "${!Dfpsp}"'_TFfp_b.sh'
  echo '#SBATCH --mem-per-cpu 32000' >> "${!Dfpsp}"'_TFfp_b.sh'
  echo '#SBATCH -t 1-23:59' >> "${!Dfpsp}"'_TFfp_b.sh'
  echo '#SBATCH --constraint=intel' >> "${!Dfpsp}"'_TFfp_b.sh'
  echo '#SBATCH --mail-type=ALL # notifications for job done & fail' >> "${!Dfpsp}"'_TFfp_b.sh'
  echo '#SBATCH --mail-user=Tarang.Mehta@earlham.ac.uk # send-to address' >> "${!Dfpsp}"'_TFfp_b.sh'
  echo '#SBATCH -o slurm.%N.%j.out # STDOUT' >> "${!Dfpsp}"'_TFfp_b.sh'
  echo '#SBATCH -e slurm.%N.%j.err # STDERR' >> "${!Dfpsp}"'_TFfp_b.sh'
  printf '\n' >> "${!Dfpsp}"'_TFfp_b.sh'
  echo "ml samtools/1.7" >> "${!Dfpsp}"'_TFfp_b.sh'
  echo 'export PATH="$PATH:/hpc-home/mehtat/.local/bin/"' >> "${!Dfpsp}"'_TFfp_b.sh'
  printf '\n' >> "${!Dfpsp}"'_TFfp_b.sh'
  echo "rgtidsp1='[MzebraUMD2a]'" >> "${!Dfpsp}"'_TFfp_b.sh'
  echo "rgtidsp2='[PunNye1.0]'" >> "${!Dfpsp}"'_TFfp_b.sh'
  echo "rgtidsp3='[AstBur1.0]'" >> "${!Dfpsp}"'_TFfp_b.sh'
  echo "rgtidsp4='[NeoBri1.0]'" >> "${!Dfpsp}"'_TFfp_b.sh'
  echo "rgtidsp5='[OniloticusUMD]'" >> "${!Dfpsp}"'_TFfp_b.sh'
  echo "rgtidsp6='[fAstCal1.2]'" >> "${!Dfpsp}"'_TFfp_b.sh'
  echo "rgtidsp1a='MzebraUMD2a'" >> "${!Dfpsp}"'_TFfp_b.sh'
  echo "rgtidsp2a='PunNye1.0'" >> "${!Dfpsp}"'_TFfp_b.sh'
  echo "rgtidsp3a='AstBur1.0'" >> "${!Dfpsp}"'_TFfp_b.sh'
  echo "rgtidsp4a='NeoBri1.0'" >> "${!Dfpsp}"'_TFfp_b.sh'
  echo "rgtidsp5a='OniloticusUMD'" >> "${!Dfpsp}"'_TFfp_b.sh'
  echo "rgtidsp6a='fAstCal1.2'" >> "${!Dfpsp}"'_TFfp_b.sh'
  echo "fpsp1=Mz" >> "${!Dfpsp}"'_TFfp_b.sh'
  echo "fpsp2=Pn" >> "${!Dfpsp}"'_TFfp_b.sh'
  echo "fpsp3=Ab" >> "${!Dfpsp}"'_TFfp_b.sh'
  echo "fpsp4=Nb" >> "${!Dfpsp}"'_TFfp_b.sh'
  echo "fpsp5=On" >> "${!Dfpsp}"'_TFfp_b.sh'
  echo "fpsp6=Ac" >> "${!Dfpsp}"'_TFfp_b.sh'
  echo "pwmsp1=mz" >> "${!Dfpsp}"'_TFfp_b.sh'
  echo "pwmsp2=pn" >> "${!Dfpsp}"'_TFfp_b.sh'
  echo "pwmsp3=ab" >> "${!Dfpsp}"'_TFfp_b.sh'
  echo "pwmsp4=nb" >> "${!Dfpsp}"'_TFfp_b.sh'
  echo "pwmsp5=on" >> "${!Dfpsp}"'_TFfp_b.sh'
  echo "pwmsp6=ac" >> "${!Dfpsp}"'_TFfp_b.sh'
  printf '\n' >> "${!Dfpsp}"'_TFfp_b.sh'
  echo '# 0. mapfile the narrowPeak files' >> "${!Dfpsp}"'_TFfp_b.sh'
  echo "mapfile -t ${!Dfpsp}peakarray < $(eval "echo \$"${!Dfpsp}peaks) # assign files to variable for array" >> "${!Dfpsp}"'_TFfp_b.sh'
  echo 'echo "# 0. mapfile the narrowPeak files ~~ DONE"' >> "${!Dfpsp}"'_TFfp_b.sh'
  printf '\n' >> "${!Dfpsp}"'_TFfp_b.sh'
  echo '# 1. prepare a prefix file using the peaks file e.g. $Abpeaks' >> "${!Dfpsp}"'_TFfp_b.sh'
  echo "${!Dfpsp}prefix=(${!Dfpsp}prefixes.txt)" >> "${!Dfpsp}"'_TFfp_b.sh'
  echo "#awk -F'/' ' { print "'$NF } '"' $(eval "echo \$"${!Dfpsp}peaks) | sed 's/_peaks.final.narrowPeak//g' > \$${!Dfpsp}prefix" >> "${!Dfpsp}"'_TFfp_b.sh'
  echo 'echo "# 1. prepare a prefix file using the peaks file e.g. $Abpeaks ~~ DONE"' >> "${!Dfpsp}"'_TFfp_b.sh'
  printf '\n' >> "${!Dfpsp}"'_TFfp_b.sh'
  echo '# 2. mapfile the above file' >> "${!Dfpsp}"'_TFfp_b.sh'
  echo "mapfile -t ${!Dfpsp}prefixes < \$${!Dfpsp}prefix" >> "${!Dfpsp}"'_TFfp_b.sh'
  echo 'echo "# 2. mapfile the above file ~~ DONE"' >> "${!Dfpsp}"'_TFfp_b.sh'
  printf '\n' >> "${!Dfpsp}"'_TFfp_b.sh'
  echo '# 3. prepare another file to iterate the input BAM files (can use the array on this) - echo the *peakarray and sed replace to prepare the path (will have to use the mapfile from above to add the prefix to peak calling folder)' >> "${!Dfpsp}"'_TFfp_b.sh'
  echo "${!Dfpsp}BAM=(${!Dfpsp}inputBAM.txt)" >> "${!Dfpsp}"'_TFfp_b.sh'
  echo '#echo '"\${${!Dfpsp}"'peakarray[${SLURM_ARRAY_TASK_ID}]} | sed "s|'"$idrdir|$annotdir/\${${!Dfpsp}"'prefixes[${SLURM_ARRAY_TASK_ID}]}|g" | sed '"'s/_peaks.final.narrowPeak/.nochrM.nodup.filt.shifted.bam/g' >> \$${!Dfpsp}BAM" >> "${!Dfpsp}"'_TFfp_b.sh'
  echo 'echo "# 3. prepare another file to iterate the input BAM files (can use the array on this) - echo the *peakarray and sed replace to prepare the path (will have to use the mapfile from above to add the prefix to peak calling folder) ~~ DONE"' >> "${!Dfpsp}"'_TFfp_b.sh'
  printf '\n' >> "${!Dfpsp}"'_TFfp_b.sh'
  echo '# 4. mapfile the file from above' >> "${!Dfpsp}"'_TFfp_b.sh'
  echo "mapfile -t ${!Dfpsp}BAM < \$${!Dfpsp}BAM" >> "${!Dfpsp}"'_TFfp_b.sh'
  echo 'echo "# 4. mapfile the file from above ~~ DONE"' >> "${!Dfpsp}"'_TFfp_b.sh'
  printf '\n' >> "${!Dfpsp}"'_TFfp_b.sh'
  echo '# A. call footprints - input BAM is the query indexed and sorted of ATAC reads aligned to genome, mtDNA removed' >> "${!Dfpsp}"'_TFfp_b.sh'
  echo 'organism=\$"$(echo '"$Dfpsp | sed 's/[^0-9]//g' | sed 's/^/rgtidsp/' | sed 's/"'$/a/'"')"'"' >> "${!Dfpsp}"'_TFfp_b.sh'
  echo 'output=\$"$(echo '"$Dfpsp | sed 's/[^0-9]//g' | sed 's/^/pwmsp/')"'"' >> "${!Dfpsp}"'_TFfp_b.sh'
  echo "#mkdir -p $tffprdir/"'$(eval echo $output)_fp/${'"${!Dfpsp}"'prefixes[${SLURM_ARRAY_TASK_ID}]}' >> "${!Dfpsp}"'_TFfp_b.sh'
  echo '#rgt-hint footprinting --atac-seq --paired-end --organism=$(eval echo $organism) --output-location='"$tffprdir"'/$(eval echo $output)_fp/${'"${!Dfpsp}"'prefixes[${SLURM_ARRAY_TASK_ID}]} --output-prefix='"\${${!Dfpsp}"'prefixes[${SLURM_ARRAY_TASK_ID}]} "$(basename "'"\${${!Dfpsp}"'BAM[${SLURM_ARRAY_TASK_ID}]}" .bam).sorted.bam" '"\${${!Dfpsp}"'peakarray[${SLURM_ARRAY_TASK_ID}]}' >> "${!Dfpsp}"'_TFfp_b.sh'
  echo 'echo "# A. call footprints - input BAM is the query indexed and sorted of ATAC reads aligned to genome, mtDNA removed ~~ DONE"' >> "${!Dfpsp}"'_TFfp_b.sh'
  printf '\n' >> "${!Dfpsp}"'_TFfp_b.sh'
  # echo '# B. outputs signals for visualization in a genome browser' >> "${!Dfpsp}"'_TFfp_b.sh'
  # echo "${!Dfpsp}signalprefix=(${!Dfpsp}signalprefixes.txt)" >> "${!Dfpsp}"'_TFfp_b.sh'
  # echo "#sed 's"'/$/_BC/'"g' \$${!Dfpsp}prefix > \$${!Dfpsp}signalprefix" >> "${!Dfpsp}"'_TFfp_b.sh'
  # echo "mapfile -t ${!Dfpsp}signalprefix < \$${!Dfpsp}signalprefix" >> "${!Dfpsp}"'_TFfp_b.sh'
  # echo 'rgt-hint tracks --bc --bigWig --organism=$(eval echo $organism) --output-location='"$tffprdir"'/$(eval echo $output)_fp/${'"${!Dfpsp}"'prefixes[${SLURM_ARRAY_TASK_ID}]} "$(basename "'"\${${!Dfpsp}"'BAM[${SLURM_ARRAY_TASK_ID}]}" .bam).sorted.bam" '"\${${!Dfpsp}"'peakarray[${SLURM_ARRAY_TASK_ID}]} --output-prefix='"\${${!Dfpsp}"'signalprefix[${SLURM_ARRAY_TASK_ID}]}' >> "${!Dfpsp}"'_TFfp_b.sh'
  # echo 'echo "# B. outputs signals for visualization in a genome browser ~~ DONE"' >> "${!Dfpsp}"'_TFfp_b.sh'
  # printf '\n' >> "${!Dfpsp}"'_TFfp_b.sh'
  echo '# B. find associated TFs' >> "${!Dfpsp}"'_TFfp_b.sh'
  echo 'rgt-motifanalysis matching --filter "database:cichlid$(eval echo $output)CSsp,cichlidCW,cichlidJASPAR,jaspar_vertebrates,hocomoco" --organism $(eval echo $organism) --output-location '"$tffprdir"'/$(eval echo $output)_fp/${'"${!Dfpsp}"'prefixes[${SLURM_ARRAY_TASK_ID}]} --input-files '"$tffprdir"'/$(eval echo $output)'"_fp"'/'"\${${!Dfpsp}"'prefixes[${SLURM_ARRAY_TASK_ID}]}/'"\${${!Dfpsp}"'prefixes[${SLURM_ARRAY_TASK_ID}]}.bed' >> "${!Dfpsp}"'_TFfp_b.sh'
  echo 'echo "# B. find associated TFs ~~ DONE"' >> "${!Dfpsp}"'_TFfp_b.sh'
done


# ## Doing some individual runs of motif matching that didn't run due to node issues
# cd /ei/projects/9/9e238063-c905-4076-a975-f7c7f85dbd56/scratch/ATACseq/3.run2/3.TFfprint_SignalTrack/ac_fp/3bAc_12dpf_ATAC
#
# nano motifmatch.sh # this code holds the most promise as actually loading files - basically the same as original
#
# #!/bin/bash -e
# #SBATCH -p ei-medium # partition (queue)
# #SBATCH -N 1 # number of nodes
# #SBATCH -n 1 # number of tasks
# #SBATCH --mem-per-cpu 32000
# #SBATCH -t 0-23:59
# #SBATCH --constraint=intel
# #SBATCH --mail-type=ALL # notifications for job done & fail
# #SBATCH --mail-user=Tarang.Mehta@earlham.ac.uk # send-to address
# #SBATCH -o slurm.%N.%j.out # STDOUT
# #SBATCH -e slurm.%N.%j.err # STDERR
#
# export PATH="$PATH:/hpc-home/mehtat/.local/bin/"
#
# rgtidsp6='[fAstCal1.2]'
# rgtidsp6a='fAstCal1.2'
# fpsp6=Ac
# pwmsp6=ac
#
# # A. find associated TFs
# organism=\$"$(echo fpsp6 | sed 's/[^0-9]//g' | sed 's/^/rgtidsp/' | sed 's/$/a/')"
# output=\$"$(echo fpsp6 | sed 's/[^0-9]//g' | sed 's/^/pwmsp/')"
#
# rgt-motifanalysis matching --filter "database:cichlidacCSsp,cichlidCW,cichlidJASPAR,jaspar_vertebrates,hocomoco" --organism fAstCal1.2 --output-location /ei/projects/9/9e238063-c905-4076-a975-f7c7f85dbd56/scratch/ATACseq/3.run2/3.TFfprint_SignalTrack/ac_fp/3bAc_12dpf_ATAC --input-files /ei/projects/9/9e238063-c905-4076-a975-f7c7f85dbd56/scratch/ATACseq/3.run2/3.TFfprint_SignalTrack/ac_fp/3bAc_12dpf_ATAC/3bAc_12dpf_ATAC.bed
# rgt-motifanalysis matching  --organism fAstCal1.2 --filter "database:cichlidacCSsp,cichlidCW,cichlidJASPAR,jaspar_vertebrates,hocomoco" --output-location /ei/projects/9/9e238063-c905-4076-a975-f7c7f85dbd56/scratch/ATACseq/3.run2/3.TFfprint_SignalTrack/ac_fp/3bAc_12dpf_ATAC --input-files /ei/projects/9/9e238063-c905-4076-a975-f7c7f85dbd56/scratch/ATACseq/3.run2/3.TFfprint_SignalTrack/ac_fp/3bAc_12dpf_ATAC/3bAc_12dpf_ATAC.bed
#
# echo "# A. find associated TFs ~~ DONE"
#
# ## run the above
# sbatch motifmatch.sh
#
# cd /ei/projects/9/9e238063-c905-4076-a975-f7c7f85dbd56/scratch/ATACseq/3.run2/3.TFfprint_SignalTrack/nb_fp/Nb4_B_ATAC
#
# nano motifmatch.sh # this code holds the most promise as actually loading files - basically the same as original
#
# #!/bin/bash -e
# #SBATCH -p ei-medium # partition (queue)
# #SBATCH -N 1 # number of nodes
# #SBATCH -n 1 # number of tasks
# #SBATCH --mem-per-cpu 32000
# #SBATCH -t 0-23:59
# #SBATCH --constraint=intel
# #SBATCH --mail-type=ALL # notifications for job done & fail
# #SBATCH --mail-user=Tarang.Mehta@earlham.ac.uk # send-to address
# #SBATCH -o slurm.%N.%j.out # STDOUT
# #SBATCH -e slurm.%N.%j.err # STDERR
#
# export PATH="$PATH:/hpc-home/mehtat/.local/bin/"
#
# fpsp4=Nb
# pwmsp4=nb
#
# # mkdir v1
#
# # A. find associated TFs
# organism=\$"$(echo fpsp4 | sed 's/[^0-9]//g' | sed 's/^/rgtidsp/' | sed 's/$/a/')"
# output=\$"$(echo fpsp4 | sed 's/[^0-9]//g' | sed 's/^/pwmsp/')"
#
# rgt-motifanalysis matching --filter "database:cichlidnbCSsp,cichlidCW,cichlidJASPAR,jaspar_vertebrates,hocomoco" --organism NeoBri1.0 --output-location /ei/projects/9/9e238063-c905-4076-a975-f7c7f85dbd56/scratch/ATACseq/3.run2/3.TFfprint_SignalTrack/nb_fp/Nb4_B_ATAC --input-files /ei/projects/9/9e238063-c905-4076-a975-f7c7f85dbd56/scratch/ATACseq/3.run2/3.TFfprint_SignalTrack/nb_fp/Nb4_B_ATAC/Nb4_B_ATAC.bed
#
# echo "# A. find associated TFs ~~ DONE"
#
# ## run the above
# sbatch motifmatch.sh

## These are non-echo scripts - not amended so won't be 100% same as echo scripts (use the output of those for reference)
# scripts=(/ei/projects/9/9e238063-c905-4076-a975-f7c7f85dbd56/scratch/ATACseq/3.run2)
# ml samtools/1.7
# # idrdir=($scripts/1.IDR)
# idrdir=($scripts/idr_test) # THIS NEEDS CHANGING TO ABOVE PATH FOR FINAL SCRIPT
#
# # 0. mapfile the narrowPeak files
# mapfile -t Abpeakarray < $Abpeaks # assign files to variable for array
#
# # 1. prepare a prefix file using the peaks file e.g. $Abpeaks
# Abprefix=(Abprefixes.txt)
# awk -F'/' ' { print $NF } ' $Abpeaks | sed 's/_peaks.final.narrowPeak//g' > $Abprefix
#
# # 2. mapfile the above file
# mapfile -t Abprefixes < $Abprefix
#
# 3. prepare another file to iterate the input BAM files (can use the array on this) - echo the Abpeakarray and sed replace to prepare the path (will have to use the mapfile from above to add the prefix to peak calling folder)
# AbBAM=(AbinputBAM.txt)
# echo ${Abpeakarray[${SLURM_ARRAY_TASK_ID}]} | sed "s|$idrdir|$annotdir/${Abprefixes[${SLURM_ARRAY_TASK_ID}]}|g" | sed 's/_peaks.final.narrowPeak/.nochrM.nodup.filt.shifted.bam/g' >> $AbBAM
#
# this is for the non-shifted BAM - best to use the shifted BAM from ATACseqQC
# AbBAM=(AbinputBAM.txt)
# echo ${Abpeakarray[${SLURM_ARRAY_TASK_ID}]} | sed "s|$idrdir|$scripts/${Abprefixes[${SLURM_ARRAY_TASK_ID}]}/5.peak_calling|g" | sed 's/_peaks.final.narrowPeak/.nochrM.nodup.filt.querysorted.bam/g' >> $AbBAM
# echo "${Abpeakarray[0]}" | sed "s|$idrdir|$scripts/${Abprefixes[0]}/5.peak_calling|g" | sed 's/_peaks.final.narrowPeak/.nochrM.nodup.filt.querysorted.bam/g'
#
# # 4, mapfile the file from above
# mapfile -t AbBAM < $AbBAM
#
# # 5. run samtools sort and index and drop in this folder
# samtools sort "${AbBAM[${SLURM_ARRAY_TASK_ID}]}" -o "$(basename "${AbBAM[${SLURM_ARRAY_TASK_ID}]}" .bam).sorted.bam"
# samtools index "$(basename "${AbBAM[${SLURM_ARRAY_TASK_ID}]}" .bam).sorted.bam"
# this is for the non-shifted BAM - best to use the shifted BAM from ATACseqQC
# samtools sort "${AbBAM[${SLURM_ARRAY_TASK_ID}]}" -o "$(basename "${AbBAM[${SLURM_ARRAY_TASK_ID}]}" .querysorted.bam).sorted.bam"
# samtools index "$(basename "${AbBAM[${SLURM_ARRAY_TASK_ID}]}" .querysorted.bam).sorted.bam"
#
#
# # A. call footprints - input BAM is the query indexed and sorted of ATAC reads aligned to genome, mtDNA removed
# # export PATH="$PATH:/hpc-home/mehtat/.local/bin/rgt-TDF"
# # export PATH="$PATH:/hpc-home/mehtat/.local/bin/rgt-THOR"
# # export PATH="$PATH:/hpc-home/mehtat/.local/bin/rgt-filterVCF"
# # export PATH="$PATH:/hpc-home/mehtat/.local/bin/rgt-hint"
# # export PATH="$PATH:/hpc-home/mehtat/.local/bin/rgt-motifanalysis"
# # export PATH="$PATH:/hpc-home/mehtat/.local/bin/rgt-viz"
# # export PATH="$PATH:/hpc-home/mehtat/.local/bin/wigToBigWig"
# # export PATH="$PATH:/hpc-home/mehtat/.local/lib/python3.7/site-packages/rgt"
# # RGTDATA=(~/rgtdata)
# export PATH="$PATH:/hpc-home/mehtat/.local/bin/"
# mkdir -p $tffprdir/${pwmsp3}_fp/${Abprefixes[${SLURM_ARRAY_TASK_ID}]}
# rgt-hint footprinting --atac-seq --paired-end --organism=$rgtidsp3a --output-location=$tffprdir/${pwmsp3}_fp/${Abprefixes[${SLURM_ARRAY_TASK_ID}]} --output-prefix=${Abprefixes[${SLURM_ARRAY_TASK_ID}]} "$(basename "${AbBAM[${SLURM_ARRAY_TASK_ID}]}" .bam).sorted.bam" ${Abpeakarray[${SLURM_ARRAY_TASK_ID}]}
# this is for the non-shifted BAM - best to use the shifted BAM from ATACseqQC
# rgt-hint footprinting --atac-seq --paired-end --organism=$rgtidsp3a --output-location=$tffprdir/${pwmsp3}_fp/${Abprefixes[${SLURM_ARRAY_TASK_ID}]} --output-prefix=${Abprefixes[${SLURM_ARRAY_TASK_ID}]} "$(basename "${AbBAM[${SLURM_ARRAY_TASK_ID}]}" .querysorted.bam).sorted.bam" ${Abpeakarray[${SLURM_ARRAY_TASK_ID}]}
#
# # B. outputs signals for visualization in a genome browser
# Absignalprefix=(Absignalprefixes.txt)
# sed 's/$/_BC/g' $Abprefix > $Absignalprefix
# mapfile -t Absignalprefix < $Absignalprefix
# rgt-hint tracks --bc --bigWig --organism=$rgtidsp3a "$(basename "${AbBAM[${SLURM_ARRAY_TASK_ID}]}" .bam).sorted.bam" ${Abpeakarray[${SLURM_ARRAY_TASK_ID}]} --output-prefix=${Absignalprefix[${SLURM_ARRAY_TASK_ID}]}
# this is for the non-shifted BAM - best to use the shifted BAM from ATACseqQC
# rgt-hint tracks --bc --bigWig --organism=$rgtidsp3a "$(basename "${AbBAM[${SLURM_ARRAY_TASK_ID}]}" .querysorted.bam).sorted.bam" ${Abpeakarray[${SLURM_ARRAY_TASK_ID}]} --output-prefix=${Absignalprefix[${SLURM_ARRAY_TASK_ID}]}
#
# # C. find associated TFs
# rgt-motifanalysis matching --filter "database:cichlid${pwmsp3}CSsp, cichlidCW, cichlidJASPAR, jaspar_vertebrates, hocomoco" --organism=$rgtidsp3a --input-files $tffprdir/${pwmsp3}_fp/${Abprefixes[${SLURM_ARRAY_TASK_ID}]}/${Abprefixes[${SLURM_ARRAY_TASK_ID}]}.bed


### Generating comparative lineplots of TF footprinting
# Using the following:
# --bc: all analysis will be based on bias corrected signal
# fdr: 0.05

## Comparisons to do
# For each, you need to create the following to array on:
  # a. mpbs-files: ./MotifMatching/MEP1_mpbs.bed,./MotifMatching/MEP1_mpbs.bed
    # /ei/projects/9/9e238063-c905-4076-a975-f7c7f85dbd56/scratch/ATACseq/3.run2/3.TFfprint_SignalTrack/ab_fp/Ab5_B_ATAC/Ab5_B_ATAC_mpbs.bed
  # b. reads-files: ./BamFiles/MEP1.bam,./BamFiles/MEP2.bam
    # /ei/projects/9/9e238063-c905-4076-a975-f7c7f85dbd56/scratch/ATACseq/3.run2/2.Annotation/1aAc_3dpf_ATAC/1aAc_3dpf_ATAC.nochrM.nodup.filt.shifted.bam
  # c. conditions: MEP1,MEP2
  # d. output-location: MEP1_MEP2

# A. Between same species and tissue replicates
# a. mpbs-files
awk '{if($1 ~ "Mz")print $1, $2, "mz_fp";if($1 ~ "Ac")print $1, $2, "ac_fp";if($1 ~ "Pn")print $1, $2, "pn_fp";if($1 ~ "Ab")print $1, $2, "ab_fp";if($1 ~ "Nb")print $1, $2, "nb_fp";if($1 ~ "On")print $1, $2, "on_fp";}' OFS='\t' $prefixpairs | awk -F'\t' -v wd="$scripts" '{print wd"/3.TFfprint_SignalTrack/"$3"/"$1"/"$1"_mpbs.bed,"wd"/3.TFfprint_SignalTrack/"$3"/"$2"/"$2"_mpbs.bed"}' > $repdiffmpbs
# b. reads-files
awk '{if($1 ~ "Mz")print $1, $2, "mz_fp";if($1 ~ "Ac")print $1, $2, "ac_fp";if($1 ~ "Pn")print $1, $2, "pn_fp";if($1 ~ "Ab")print $1, $2, "ab_fp";if($1 ~ "Nb")print $1, $2, "nb_fp";if($1 ~ "On")print $1, $2, "on_fp";}' OFS='\t' $prefixpairs | awk -F'\t' -v wd="$scripts" '{print wd"/2.Annotation/"$1"/"$1".nochrM.nodup.filt.shifted.bam,"wd"/2.Annotation/"$2"/"$2".nochrM.nodup.filt.shifted.bam"}' > $repdiffread
# c. conditions
awk '{print $1","$2}' $prefixpairs > $repdiffcond
# d. output-location
awk '{print $1"__"$2}' $prefixpairs > $repdiffout # check if you need to mkdir
# e. create species specific files for the array
for i in Mz Ac Pn Ab Nb On; do
  grep $i $repdiffmpbs > "$( basename "${repdiffmpbs}" .txt)_${i}.txt"
  grep $i $repdiffread > "$( basename "${repdiffread}" .txt)_${i}.txt"
  grep $i $repdiffcond > "$( basename "${repdiffcond}" .txt)_${i}.txt"
  grep $i $repdiffout > "$( basename "${repdiffout}" .txt)_${i}.txt"
done

# # B. Between species same tissues - currently this cannot be done since one organism is required?
# awk '{if($1 ~ "Mz")print $1,"mz_fp";if($1 ~ "Ac")print $1,"ac_fp";if($1 ~ "Pn")print $1,"pn_fp";if($1 ~ "Ab")print $1,"ab_fp";if($1 ~ "Nb")print $1,"nb_fp";if($1 ~ "On")print $1,"on_fp";}' OFS='\t' $prefixATAC > sp.tmp
# # a. mpbs-files
# for i in dpf B_ATAC E_ATAC G_ATAC L_ATAC T_ATAC; do
#   grep $i sp.tmp |
#   awk -F'\t' -v wd="$scripts" '{print wd"/3.TFfprint_SignalTrack/"$2"/"$1"/"$1"_mpbs.bed"}' |
#   awk 'BEGIN { ORS = "," } { print }' | sed 's/.$/\n/' >> $spdiffmpbs
# done
# # b. reads-files
# for i in dpf B_ATAC E_ATAC G_ATAC L_ATAC T_ATAC; do
#   grep $i sp.tmp |
#   awk -F'\t' -v wd="$scripts" '{print wd"/2.Annotation/"$1"/"$1".nochrM.nodup.filt.shifted.bam"}' |
#   awk 'BEGIN { ORS = "," } { print }' | sed 's/.$/\n/' >> $spdiffread
# done
# # c. conditions
# for i in dpf B_ATAC E_ATAC G_ATAC L_ATAC T_ATAC; do
#   grep $i sp.tmp | awk '{print $1}' |
#   awk 'BEGIN { ORS = "," } { print }' | sed 's/.$/\n/'>> $spdiffcond
# done
#
# # d. output-location
# for i in dpf B_ATAC E_ATAC G_ATAC L_ATAC T_ATAC; do
#   # grep $i sp.tmp | awk '{print $1}' |
#   # awk 'BEGIN { ORS = "__" } { print }' | sed 's/.$/\n/'>> $spdiffout
#   echo ${i}_ATAC | sed 's/_ATAC_ATAC/_ATAC/g' >> $spdiffout
# done
#
# rm sp.tmp

# get the total number of files and assign to variables
for Cfpsp in "${!fpsp@}"; do
  # echo "$Cfpsp is set to ${!Cfpsp}"
  eval "${!Cfpsp}"motifarrayend=$(wc -l repdiffmpbs_paths_"${!Cfpsp}".txt | awk -v e="$e" '{print ($1 - e)}')
done

for Dfpsp in "${!fpsp@}"; do
  # echo "$Dfpsp is set to ${!Dfpsp}"
  echo '#!/bin/bash -e' > "${!Dfpsp}"'_TFfp_c.sh'
  echo '#SBATCH -p ei-largemem # partition (queue)' >> "${!Dfpsp}"'_TFfp_c.sh'
  echo '#SBATCH -N 1 # number of nodes' >> "${!Dfpsp}"'_TFfp_c.sh'
  echo '#SBATCH -c 32 # number of cores' >> "${!Dfpsp}"'_TFfp_c.sh'
  echo '#SBATCH --array=0-'"$(eval "echo \$"${!Dfpsp}"motifarrayend")" >> "${!Dfpsp}"'_TFfp_c.sh'
  echo '#SBATCH --mem 512GB' >> "${!Dfpsp}"'_TFfp_c.sh'
  echo '#SBATCH -t 3-23:59' >> "${!Dfpsp}"'_TFfp_c.sh'
  echo '#SBATCH --constraint=intel' >> "${!Dfpsp}"'_TFfp_c.sh'
  echo '#SBATCH --mail-type=ALL # notifications for job done & fail' >> "${!Dfpsp}"'_TFfp_c.sh'
  echo '#SBATCH --mail-user=Tarang.Mehta@earlham.ac.uk # send-to address' >> "${!Dfpsp}"'_TFfp_c.sh'
  echo '#SBATCH -o slurm.%N.%j.out # STDOUT' >> "${!Dfpsp}"'_TFfp_c.sh'
  echo '#SBATCH -e slurm.%N.%j.err # STDERR' >> "${!Dfpsp}"'_TFfp_c.sh'
  printf '\n' >> "${!Dfpsp}"'_TFfp_c.sh'
  echo 'export PATH="$PATH:/hpc-home/mehtat/.local/bin/"' >> "${!Dfpsp}"'_TFfp_c.sh'
  printf '\n' >> "${!Dfpsp}"'_TFfp_c.sh'
  echo "rgtidsp1='[MzebraUMD2a]'" >> "${!Dfpsp}"'_TFfp_c.sh'
  echo "rgtidsp2='[PunNye1.0]'" >> "${!Dfpsp}"'_TFfp_c.sh'
  echo "rgtidsp3='[AstBur1.0]'" >> "${!Dfpsp}"'_TFfp_c.sh'
  echo "rgtidsp4='[NeoBri1.0]'" >> "${!Dfpsp}"'_TFfp_c.sh'
  echo "rgtidsp5='[OniloticusUMD]'" >> "${!Dfpsp}"'_TFfp_c.sh'
  echo "rgtidsp6='[fAstCal1.2]'" >> "${!Dfpsp}"'_TFfp_c.sh'
  echo "rgtidsp1a='MzebraUMD2a'" >> "${!Dfpsp}"'_TFfp_c.sh'
  echo "rgtidsp2a='PunNye1.0'" >> "${!Dfpsp}"'_TFfp_c.sh'
  echo "rgtidsp3a='AstBur1.0'" >> "${!Dfpsp}"'_TFfp_c.sh'
  echo "rgtidsp4a='NeoBri1.0'" >> "${!Dfpsp}"'_TFfp_c.sh'
  echo "rgtidsp5a='OniloticusUMD'" >> "${!Dfpsp}"'_TFfp_c.sh'
  echo "rgtidsp6a='fAstCal1.2'" >> "${!Dfpsp}"'_TFfp_c.sh'
  echo "fpsp1=Mz" >> "${!Dfpsp}"'_TFfp_c.sh'
  echo "fpsp2=Pn" >> "${!Dfpsp}"'_TFfp_c.sh'
  echo "fpsp3=Ab" >> "${!Dfpsp}"'_TFfp_c.sh'
  echo "fpsp4=Nb" >> "${!Dfpsp}"'_TFfp_c.sh'
  echo "fpsp5=On" >> "${!Dfpsp}"'_TFfp_c.sh'
  echo "fpsp6=Ac" >> "${!Dfpsp}"'_TFfp_c.sh'
  echo "pwmsp1=mz" >> "${!Dfpsp}"'_TFfp_c.sh'
  echo "pwmsp2=pn" >> "${!Dfpsp}"'_TFfp_c.sh'
  echo "pwmsp3=ab" >> "${!Dfpsp}"'_TFfp_c.sh'
  echo "pwmsp4=nb" >> "${!Dfpsp}"'_TFfp_c.sh'
  echo "pwmsp5=on" >> "${!Dfpsp}"'_TFfp_c.sh'
  echo "pwmsp6=ac" >> "${!Dfpsp}"'_TFfp_c.sh'
  printf '\n' >> "${!Dfpsp}"'_TFfp_c.sh'
  echo 'mapfile '"${!Dfpsp}"'mpbs < repdiffmpbs_paths_'"${!Dfpsp}"'.txt' >> "${!Dfpsp}"'_TFfp_c.sh'
  echo 'mapfile '"${!Dfpsp}"'read < repdiffread_paths_'"${!Dfpsp}"'.txt' >> "${!Dfpsp}"'_TFfp_c.sh'
  echo 'mapfile '"${!Dfpsp}"'cond < repdiffcond_paths_'"${!Dfpsp}"'.txt' >> "${!Dfpsp}"'_TFfp_c.sh'
  echo 'mapfile '"${!Dfpsp}"'out < repdiffout_paths_'"${!Dfpsp}".'txt' >> "${!Dfpsp}"'_TFfp_c.sh'
  echo 'organism=\$"$(echo '"$Dfpsp | sed 's/[^0-9]//g' | sed 's/^/rgtidsp/' | sed 's/"'$/a/'"')"'"' >> "${!Dfpsp}"'_TFfp_c.sh'
  echo 'output=\$"$(echo '"$Dfpsp | sed 's/[^0-9]//g' | sed 's/^/pwmsp/')"'"' >> "${!Dfpsp}"'_TFfp_c.sh'
  printf '\n' >> "${!Dfpsp}"'_TFfp_c.sh'
  echo 'rgt-hint differential --organism $(eval echo $organism) --bc --nc 32 --mpbs-files ${'"${!Dfpsp}"'mpbs[${SLURM_ARRAY_TASK_ID}]} --reads-files ${'"${!Dfpsp}"'read[${SLURM_ARRAY_TASK_ID}]} --conditions ${'"${!Dfpsp}"'cond[${SLURM_ARRAY_TASK_ID}]} --output-location ${'"${!Dfpsp}"'out[${SLURM_ARRAY_TASK_ID}]}' >> "${!Dfpsp}"'_TFfp_c.sh'
  printf '\n' >> "${!Dfpsp}"'_TFfp_c.sh'
  echo 'echo "# C. TF footprinting lineplots ~~ DONE"' >> "${!Dfpsp}"'_TFfp_c.sh'
done

# for i in Mz Ac Pn Ab Nb On; do sbatch ${i}_TFfp_c.sh; done

# this runs for a single sample
# rgt-hint differential --organism $(eval echo $organism) --bc --nc 30 --mpbs-files /ei/projects/9/9e238063-c905-4076-a975-f7c7f85dbd56/scratch/ATACseq/3.run2/3.TFfprint_SignalTrack/Ac_fp/1aAc_3dpf_ATAC/v1/1aAc_3dpf_ATAC_mpbs.bed --reads-files /ei/projects/9/9e238063-c905-4076-a975-f7c7f85dbd56/scratch/ATACseq/3.run2/2.Annotation/1aAc_3dpf_ATAC/1aAc_3dpf_ATAC.nochrM.nodup.filt.shifted.bam --conditions 1aAc_3dpf_ATAC --output-location /ei/projects/9/9e238063-c905-4076-a975-f7c7f85dbd56/scratch/ATACseq/3.run2/3.TFfprint_SignalTrack/$(eval echo $output)_fp/1aAc_3dpf_ATAC/v1/diff

## Dc. Create signal tracks using a modified bedtools approach - this is outputted to '$scripts/*_*_ATAC/5.peak_calling'

# # DcA. Create the bedgraph to bigwig script - this is required (instead of running bedGraphToBigWig from bedtools which does not fix for the shifting and extsize smoothing you did in MACS2 - this gives errors of coordinates beyond the scaffolds)
# echo '#!/bin/bash' > bdg2bw.sh
# echo '# check commands: slopBed, bedGraphToBigWig and bedClip' >> bdg2bw.sh
# echo 'which bedtools &>/dev/null || { echo "bedtools not found! Download bedTools: <http://code.google.com/p/bedtools/>"; exit 1; }' >> bdg2bw.sh
# echo 'which bedGraphToBigWig &>/dev/null || { echo "bedGraphToBigWig not found! Download: <http://hgdownload.cse.ucsc.edu/admin/exe/>"; exit 1; }' >> bdg2bw.sh
# echo 'which bedClip &>/dev/null || { echo "bedClip not found! Download: <http://hgdownload.cse.ucsc.edu/admin/exe/>"; exit 1; }' >> bdg2bw.sh
# echo '# end of checking' >> bdg2bw.sh
# echo 'if [ $# -lt 2 ];then' >> bdg2bw.sh
# echo -e '\techo "Need 2 parameters! <bedgraph> <chrom info>"' >> bdg2bw.sh
# echo -e '\texit' >> bdg2bw.sh
# echo 'fi' >> bdg2bw.sh
# echo 'F=$1' >> bdg2bw.sh
# echo 'G=$2' >> bdg2bw.sh
# echo 'LC_COLLATE=C sort -k1,1 -k2,2n ${F} > ${F}.sort' >> bdg2bw.sh
# echo 'head -n -1 ${F}.sort > ${F}.re.sort' >> bdg2bw.sh
# echo 'bedClip ${F}.re.sort ${G} ${F}.re.sort.clip' >> bdg2bw.sh
# echo 'bedGraphToBigWig ${F}.re.sort.clip ${G} ${F/bdg/bw}' >> bdg2bw.sh
# echo 'rm -f ${F}.sort ${F}.re.sort ${F}.re.sort.clip' >> bdg2bw.sh

# DcA. signal tracks require scaffold length files (previously generated)
# variables at the top - generated using bioawk script in 'ATAC_Bioinf_pipeline_v2b.sh'

# DcB. signal track generation script - array for running on each sample and genome

# get a list of all the bdg paths for each species, and prep a prefixes filefor output
for Efpsp in "${!fpsp@}"; do
  # echo "$Efpsp is set to ${!Efpsp}"
  ls -1 $scripts/*"${!Efpsp}"*_*_ATAC/5.peak_calling/*FE.bdg > $tffprdir/"${!Efpsp}"bdgpaths.txt
  ls -1 $scripts/*"${!Efpsp}"*_*_ATAC/5.peak_calling/*logLR.bdg >> $tffprdir/"${!Efpsp}"bdgpaths.txt
  awk -F'/' ' { print $NF } ' $tffprdir/"${!Efpsp}"bdgpaths.txt | sed 's/_FE.bdg//g' | sed 's/_logLR.bdg//g' > $tffprdir/"${!Efpsp}"sigprefixes.txt
done

# get the total number of files for array and assign to variables, and then assign script variables for running signal tracks
for Ffpsp in "${!fpsp@}"; do
  # echo "$Ffpsp is set to ${!Ffpsp}"
  eval "${!Ffpsp}"sigarrayend=$(wc -l "${!Ffpsp}"bdgpaths.txt | awk -v e="$e" '{print ($1 - e)}')
  eval "${!Ffpsp}"sigscript="${!Ffpsp}"_sigtrack.sh
done

for Gfpsp in "${!fpsp@}"; do
  # echo "$Dfpsp is set to ${!Dfpsp}"
  echo '#!/bin/bash -e' > "${!Gfpsp}"'_sigtrack.sh'
  echo '#SBATCH -p ei-medium # partition (queue)' >> "${!Gfpsp}"'_sigtrack.sh'
  echo '#SBATCH -N 1 # number of nodes' >> "${!Gfpsp}"'_sigtrack.sh'
  echo '#SBATCH -n 1 # number of tasks' >> "${!Gfpsp}"'_sigtrack.sh'
  echo '#SBATCH --array=0-'"$(eval "echo \$"${!Gfpsp}"sigarrayend")" >> "${!Gfpsp}"'_sigtrack.sh'
  echo '#SBATCH --mem-per-cpu 32000' >> "${!Gfpsp}"'_sigtrack.sh'
  echo '#SBATCH -t 0-10:59' >> "${!Gfpsp}"'_sigtrack.sh'
  echo '#SBATCH --mail-type=ALL # notifications for job done & fail' >> "${!Gfpsp}"'_sigtrack.sh'
  echo '#SBATCH --mail-user=Tarang.Mehta@earlham.ac.uk # send-to address' >> "${!Gfpsp}"'_sigtrack.sh'
  echo '#SBATCH -o slurm.%N.%j.out # STDOUT' >> "${!Gfpsp}"'_sigtrack.sh'
  echo '#SBATCH -e slurm.%N.%j.err # STDERR' >> "${!Gfpsp}"'_sigtrack.sh'
  printf '\n' >> "${!Gfpsp}"'_sigtrack.sh'
  echo 'ml ucsc_utils' >> "${!Gfpsp}"'_sigtrack.sh'
  echo 'ml bedtools' >> "${!Gfpsp}"'_sigtrack.sh'
  echo 'ml OpenSSL' >> "${!Gfpsp}"'_sigtrack.sh'
  printf '\n' >> "${!Gfpsp}"'_sigtrack.sh'
  echo '#output=\$"$(echo '"$Gfpsp | sed 's/[^0-9]//g' | sed 's/^/pwmsp/')"'"' >> "${!Gfpsp}"'_sigtrack.sh'
  echo "mapfile -t ${!Gfpsp}sigfiles < $(eval "echo "$tffprdir/"${!Gfpsp}"bdgpaths.txt) # assign files to variable for array" >> "${!Gfpsp}"'_sigtrack.sh'
  echo "mapfile -t ${!Gfpsp}prefixes < ${!Gfpsp}sigprefixes.txt" >> "${!Gfpsp}"'_sigtrack.sh'
  echo '#sort -k1,1 -k2,2n ${'"${!Gfpsp}"'sigfiles[${SLURM_ARRAY_TASK_ID}]} > ${'"${!Gfpsp}"'sigfiles[${SLURM_ARRAY_TASK_ID}]}.sorted' >> "${!Gfpsp}"'_sigtrack.sh'
  echo '#sh bdg2bw.sh ${'"${!Gfpsp}"'sigfiles[${SLURM_ARRAY_TASK_ID}]} '"$(eval "echo \$"${!Gfpsp}"genomechr") $tffprdir"'/$(eval echo $output)_fp/${'"${!Gfpsp}"'prefixes[${SLURM_ARRAY_TASK_ID}]}/${'"${!Gfpsp}"'prefixes[${SLURM_ARRAY_TASK_ID}]}.bw' >> "${!Gfpsp}"'_sigtrack.sh'
  echo '#sh bdg2bw.sh ${'"${!Gfpsp}"'sigfiles[${SLURM_ARRAY_TASK_ID}]} '"$(eval "echo \$"${!Gfpsp}"genomechr")" >> "${!Gfpsp}"'_sigtrack.sh' >> "${!Gfpsp}"'_sigtrack.sh'
  echo 'LC_COLLATE=C sort -k1,1 -k2,2n ${'"${!Gfpsp}"'sigfiles[${SLURM_ARRAY_TASK_ID}]} > ${'"${!Gfpsp}"'sigfiles[${SLURM_ARRAY_TASK_ID}]}.sort' >> "${!Gfpsp}"'_sigtrack.sh'
  echo 'head -n -1 ${'"${!Gfpsp}"'sigfiles[${SLURM_ARRAY_TASK_ID}]}.sort > ${'"${!Gfpsp}"'sigfiles[${SLURM_ARRAY_TASK_ID}]}.re.sort' >> "${!Gfpsp}"'_sigtrack.sh'
  echo 'bedClip ${'"${!Gfpsp}"'sigfiles[${SLURM_ARRAY_TASK_ID}]}.re.sort '"$(eval "echo \$"${!Gfpsp}"genomechr")"' ${'"${!Gfpsp}"'sigfiles[${SLURM_ARRAY_TASK_ID}]}.re.sort.clip' >> "${!Gfpsp}"'_sigtrack.sh'
  echo 'bedGraphToBigWig ${'"${!Gfpsp}"'sigfiles[${SLURM_ARRAY_TASK_ID}]}.re.sort.clip '"$(eval "echo \$"${!Gfpsp}"genomechr")"' ${'"${!Gfpsp}"'sigfiles[${SLURM_ARRAY_TASK_ID}]}.bw' >> "${!Gfpsp}"'_sigtrack.sh'
  echo 'rm -f ${'"${!Gfpsp}"'sigfiles[${SLURM_ARRAY_TASK_ID}]}.sort ${'"${!Gfpsp}"'sigfiles[${SLURM_ARRAY_TASK_ID}]}.re.sort ${'"${!Gfpsp}"'sigfiles[${SLURM_ARRAY_TASK_ID}]}.re.sort.clip' >> "${!Gfpsp}"'_sigtrack.sh'
done


# # collate all bigwig files for copying locally, then delete the copied files
# mkdir $scripts/3a.bigwigs_collated
# cp /ei/projects/9/9e238063-c905-4076-a975-f7c7f85dbd56/scratch/ATACseq/3.run2/*_*_ATAC/5.peak_calling/*.bw $scripts/3a.bigwigs_collated
# rm -r $scripts/3a.bigwigs_collated

echo '# -- 3a. TF footprinting preparation has completed - bioMart alias, annotations and data.config prep -- #'

echo '# -- 3b. TF footprinting and creation of signal tracks started -- #'

## This will need six (x4) jobs (so 24 in total for six species) - put in a while loop using fpsp
for Efpsp in "${!fpsp@}"; do
  jobidadd=$(echo $Efpsp | grep -Eo '[0-9]')
  jobidadd2=`expr $j + $jobidadd`
  # echo $jobidadd
  # echo $jobidadd2
  JOBID"${jobidadd2}"=$( sbatch -W --dependency=afterok:${JOBID9} "${!Efpsp}"'_TFfp.sh' | awk '{print $4}' ) # JOB10-JOB15 - this runs the footprinting
done

for Efpsp in "${!fpsp@}"; do
  jobidadd3=$(echo $Efpsp | grep -Eo '[0-9]')
  jobidadd4=`expr $j + $jobidadd`
  # echo $jobidadd3
  # echo $jobidadd4
  JOBID"${jobidadd4}"=$( sbatch -W --dependency=afterok:${JOBID15} "${!Efpsp}"'_TFfp_b.sh' | awk '{print $4}' ) # JOB16-JOB21 - this runs the motif matching of footprinting
done

for Efpsp in "${!fpsp@}"; do
  jobidadd5=$(echo $Efpsp | grep -Eo '[0-9]')
  jobidadd6=`expr $j + $jobidadd`
  # echo $jobidadd5
  # echo $jobidadd6
  JOBID"${jobidadd6}"=$( sbatch -W --dependency=afterok:${JOBID21} "${!Efpsp}"'_TFfp_c.sh' | awk '{print $4}' ) # JOB21-JOB26 - this runs the footprinting lineplot generation
done

for Efpsp in "${!fpsp@}"; do
  jobidadd7=$(echo $Efpsp | grep -Eo '[0-9]')
  jobidadd8=`expr $j + $jobidadd`
  # echo $jobidadd7
  # echo $jobidadd8
  JOBID"${jobidadd8}"=$( sbatch -W --dependency=afterok:${JOBID26} "${!Efpsp}"'_sigtrack.sh' | awk '{print $4}' ) # JOB26-JOB31 - this will generate the signal tracks and place them in $scripts/*_*_ATAC/5.peak_calling
done

# Check the word count on each footprinting out bed file
echo 'Word count on each footprinting out bed file:'
for i in *_fp/*/*.bed; do wc -l $i; done
# 132867 ab_fp/Ab5_B_ATAC/Ab5_B_ATAC.bed
# 742930 ab_fp/Ab5_E_ATAC/Ab5_E_ATAC.bed
# 1691522 ab_fp/Ab5_L_ATAC/Ab5_L_ATAC.bed
# 1465168 ab_fp/Ab5_T_ATAC/Ab5_T_ATAC.bed
# 206181 ab_fp/Ab6_B_ATAC/Ab6_B_ATAC.bed
# 1611707 ab_fp/Ab6_E_ATAC/Ab6_E_ATAC.bed
# 1035342 ab_fp/Ab6_L_ATAC/Ab6_L_ATAC.bed
# 1542899 ab_fp/Ab6_T_ATAC/Ab6_T_ATAC.bed
# 1797640 ac_fp/1aAc_3dpf_ATAC/1aAc_3dpf_ATAC.bed
# 1075030 ac_fp/1bAc_3dpf_ATAC/1bAc_3dpf_ATAC.bed
# 1022180 ac_fp/2aAc_7dpf_ATAC/2aAc_7dpf_ATAC.bed
# 741576 ac_fp/2bAc_7dpf_ATAC/2bAc_7dpf_ATAC.bed
# 1429942 ac_fp/3aAc_12dpf_ATAC/3aAc_12dpf_ATAC.bed
# 1488086 ac_fp/3bAc_12dpf_ATAC/3bAc_12dpf_ATAC.bed
# 2750326 mz_fp/Mz1_B_ATAC/Mz1_B_ATAC.bed
# 883811 mz_fp/Mz1_E_ATAC/Mz1_E_ATAC.bed
# 1403796 mz_fp/Mz1_L_ATAC/Mz1_L_ATAC.bed
# 1919127 mz_fp/Mz1_T_ATAC/Mz1_T_ATAC.bed
# 934004 mz_fp/Mz2_B_ATAC/Mz2_B_ATAC.bed
# 964930 mz_fp/Mz2_E_ATAC/Mz2_E_ATAC.bed
# 1216842 mz_fp/Mz2_L_ATAC/Mz2_L_ATAC.bed
# 1675454 mz_fp/Mz2_T_ATAC/Mz2_T_ATAC.bed
# 1301291 nb_fp/Nb4_B_ATAC/Nb4_B_ATAC.bed
# 1678525 nb_fp/Nb4_E_ATAC/Nb4_E_ATAC.bed
# 1528449 nb_fp/Nb4_L_ATAC/Nb4_L_ATAC.bed
# 2396335 nb_fp/Nb4_T_ATAC/Nb4_T_ATAC.bed
# 1396611 nb_fp/Nb5_B_ATAC/Nb5_B_ATAC.bed
# 1616953 nb_fp/Nb5_E_ATAC/Nb5_E_ATAC.bed
# 1833427 nb_fp/Nb5_L_ATAC/Nb5_L_ATAC.bed
# 1971488 nb_fp/Nb5_T_ATAC/Nb5_T_ATAC.bed
# 1137721 on_fp/On1_B_ATAC/On1_B_ATAC.bed
# 1735366 on_fp/On1_E_ATAC/On1_E_ATAC.bed
# 2081502 on_fp/On1_G_ATAC/On1_G_ATAC.bed
# 1716098 on_fp/On1_L_ATAC/On1_L_ATAC.bed
# 1010130 on_fp/On1_T_ATAC/On1_T_ATAC.bed
# 1135606 on_fp/On2_B_ATAC/On2_B_ATAC.bed
# 824709 on_fp/On2_E_ATAC/On2_E_ATAC.bed
# 3105424 on_fp/On2_G_ATAC/On2_G_ATAC.bed
# 1603638 on_fp/On2_L_ATAC/On2_L_ATAC.bed
# 1274977 on_fp/On2_T_ATAC/On2_T_ATAC.bed
# 1384413 on_fp/On3_B_ATAC/On3_B_ATAC.bed
# 1628421 on_fp/On3_E_ATAC/On3_E_ATAC.bed
# 1837893 on_fp/On3_G_ATAC/On3_G_ATAC.bed
# 1154997 on_fp/On3_L_ATAC/On3_L_ATAC.bed
# 1781584 on_fp/On3_T_ATAC/On3_T_ATAC.bed
# 827611 pn_fp/Pnm1_B_ATAC/Pnm1_B_ATAC.bed
# 1798549 pn_fp/Pnm1_L_ATAC/Pnm1_L_ATAC.bed
# 1021005 pn_fp/Pnm1_T_ATAC/Pnm1_T_ATAC.bed
# 727600 pn_fp/Pnm2_B_ATAC/Pnm2_B_ATAC.bed
# 1403290 pn_fp/Pnm2_E_ATAC/Pnm2_E_ATAC.bed
# 760949 pn_fp/Pnm2_L_ATAC/Pnm2_L_ATAC.bed
# 1029351 pn_fp/Pnm2_T_ATAC/Pnm2_T_ATAC.bed
# 956980 pn_fp/Pnm3_B_ATAC/Pnm3_B_ATAC.bed
# 373402 pn_fp/Pnm3_E_ATAC/Pnm3_E_ATAC.bed
# 161 pn_fp/Pnm3_L_ATAC/Pnm3_L_ATAC.bed
# 1021517 pn_fp/Pnm3_T_ATAC/Pnm3_T_ATAC.bed
# 815213 pn_fp/Pnm4_B_ATAC/Pnm4_B_ATAC.bed
# 1232728 pn_fp/Pnm4_E_ATAC/Pnm4_E_ATAC.bed
# 1005072 pn_fp/Pnm4_L_ATAC/Pnm4_L_ATAC.bed
# 734552 pn_fp/Pnm4_T_ATAC/Pnm4_T_ATAC.bed

# check the output of the lineplots
linp=$(cat repdiffmpbs_paths_*.txt | wc -l)
lout=$(ls -1 *_*_*__*_*_*/differential_statistics.pdf | wc -l)
lfail="$(($linp-$lout))"
echo "Number of input comparisons for rgt-hint differential: $linp" # 51
echo "Number of folders with lineplot differential stats: $lout" # 42
echo "Number of failed comparisons not creating differential stats: $lfail" # 9

for i in *_*_*__*_*_*/Lineplots; do
  if [[ "$(ls -A $i)" ]]; then
    echo -e "$i:\tDir not empty - Lineplots have been generated"
  else
    echo -e "$i:\tDir is empty - Lineplots have NOT been generated, check the stdout for the run"
  fi
done

# 1aAc_3dpf_ATAC__1bAc_3dpf_ATAC/Lineplots:	Dir not empty - Lineplots have been generated
# 2aAc_7dpf_ATAC__2bAc_7dpf_ATAC/Lineplots:	Dir not empty - Lineplots have been generated
# 3aAc_12dpf_ATAC__3bAc_12dpf_ATAC/Lineplots:	Dir not empty - Lineplots have been generated
# Ab5_B_ATAC__Ab6_B_ATAC/Lineplots:	Dir not empty - Lineplots have been generated
# Ab5_E_ATAC__Ab6_E_ATAC/Lineplots:	Dir not empty - Lineplots have been generated
# Ab5_L_ATAC__Ab6_L_ATAC/Lineplots:	Dir not empty - Lineplots have been generated
# Ab5_T_ATAC__Ab6_T_ATAC/Lineplots:	Dir not empty - Lineplots have been generated
# Mz1_B_ATAC__Mz2_B_ATAC/Lineplots:	Dir is empty - Lineplots have NOT been generated, check the stdout for the run
# Mz1_E_ATAC__Mz2_E_ATAC/Lineplots:	Dir not empty - Lineplots have been generated
# Mz1_L_ATAC__Mz2_L_ATAC/Lineplots:	Dir not empty - Lineplots have been generated
# Mz1_T_ATAC__Mz2_T_ATAC/Lineplots:	Dir is empty - Lineplots have NOT been generated, check the stdout for the run
# Nb4_B_ATAC__Nb5_B_ATAC/Lineplots:	Dir not empty - Lineplots have been generated
# Nb4_E_ATAC__Nb5_E_ATAC/Lineplots:	Dir not empty - Lineplots have been generated
# Nb4_L_ATAC__Nb5_L_ATAC/Lineplots:	Dir not empty - Lineplots have been generated
# Nb4_T_ATAC__Nb5_T_ATAC/Lineplots:	Dir is empty - Lineplots have NOT been generated, check the stdout for the run
# On1_B_ATAC__On2_B_ATAC/Lineplots:	Dir not empty - Lineplots have been generated
# On1_B_ATAC__On3_B_ATAC/Lineplots:	Dir not empty - Lineplots have been generated
# On1_E_ATAC__On2_E_ATAC/Lineplots:	Dir not empty - Lineplots have been generated
# On1_E_ATAC__On3_E_ATAC/Lineplots:	Dir not empty - Lineplots have been generated
# On1_G_ATAC__On2_G_ATAC/Lineplots:	Dir is empty - Lineplots have NOT been generated, check the stdout for the run
# On1_G_ATAC__On3_G_ATAC/Lineplots:	Dir is empty - Lineplots have NOT been generated, check the stdout for the run
# On1_L_ATAC__On2_L_ATAC/Lineplots:	Dir not empty - Lineplots have been generated
# On1_L_ATAC__On3_L_ATAC/Lineplots:	Dir not empty - Lineplots have been generated
# On1_T_ATAC__On2_T_ATAC/Lineplots:	Dir not empty - Lineplots have been generated
# On1_T_ATAC__On3_T_ATAC/Lineplots:	Dir not empty - Lineplots have been generated
# On2_B_ATAC__On3_B_ATAC/Lineplots:	Dir not empty - Lineplots have been generated
# On2_E_ATAC__On3_E_ATAC/Lineplots:	Dir not empty - Lineplots have been generated
# On2_G_ATAC__On3_G_ATAC/Lineplots:	Dir is empty - Lineplots have NOT been generated, check the stdout for the run
# On2_L_ATAC__On3_L_ATAC/Lineplots:	Dir not empty - Lineplots have been generated
# On2_T_ATAC__On3_T_ATAC/Lineplots:	Dir not empty - Lineplots have been generated
# Pnm1_B_ATAC__Pnm2_B_ATAC/Lineplots:	Dir not empty - Lineplots have been generated
# Pnm1_B_ATAC__Pnm3_B_ATAC/Lineplots:	Dir not empty - Lineplots have been generated
# Pnm1_B_ATAC__Pnm4_B_ATAC/Lineplots:	Dir not empty - Lineplots have been generated
# Pnm1_L_ATAC__Pnm2_L_ATAC/Lineplots:	Dir not empty - Lineplots have been generated
# Pnm1_L_ATAC__Pnm3_L_ATAC/Lineplots:	Dir not empty - Lineplots have been generated
# Pnm1_L_ATAC__Pnm4_L_ATAC/Lineplots:	Dir not empty - Lineplots have been generated
# Pnm1_T_ATAC__Pnm2_T_ATAC/Lineplots:	Dir not empty - Lineplots have been generated
# Pnm1_T_ATAC__Pnm3_T_ATAC/Lineplots:	Dir not empty - Lineplots have been generated
# Pnm1_T_ATAC__Pnm4_T_ATAC/Lineplots:	Dir not empty - Lineplots have been generated
# Pnm2_B_ATAC__Pnm3_B_ATAC/Lineplots:	Dir not empty - Lineplots have been generated
# Pnm2_B_ATAC__Pnm4_B_ATAC/Lineplots:	Dir not empty - Lineplots have been generated
# Pnm2_E_ATAC__Pnm3_E_ATAC/Lineplots:	Dir not empty - Lineplots have been generated
# Pnm2_E_ATAC__Pnm4_E_ATAC/Lineplots:	Dir not empty - Lineplots have been generated
# Pnm2_L_ATAC__Pnm3_L_ATAC/Lineplots:	Dir not empty - Lineplots have been generated
# Pnm2_L_ATAC__Pnm4_L_ATAC/Lineplots:	Dir not empty - Lineplots have been generated
# Pnm2_T_ATAC__Pnm3_T_ATAC/Lineplots:	Dir not empty - Lineplots have been generated
# Pnm2_T_ATAC__Pnm4_T_ATAC/Lineplots:	Dir not empty - Lineplots have been generated
# Pnm3_B_ATAC__Pnm4_B_ATAC/Lineplots:	Dir not empty - Lineplots have been generated
# Pnm3_E_ATAC__Pnm4_E_ATAC/Lineplots:	Dir not empty - Lineplots have been generated
# Pnm3_L_ATAC__Pnm4_L_ATAC/Lineplots:	Dir not empty - Lineplots have been generated
# Pnm3_T_ATAC__Pnm4_T_ATAC/Lineplots:	Dir not empty - Lineplots have been generated

## The ones that didn't run are (mostly) related to memory issues - give them 1Tb of memory each

# # parse the files to selecte those just for the re-run
# for i in repdiff*_paths_Mz.txt; do
#   sed '2,3d' ${i} > "$(basename "${i}" .txt).rerun.txt"
# done
#
# for i in repdiff*_paths_Nb.txt; do
#   tail -1 ${i} > "$(basename "${i}" .txt).rerun.txt"
# done
#
# for i in repdiff*_paths_On.txt; do
#   awk 'NR==5,NR==13' ${i} | sed '3,8d' > "$(basename "${i}" .txt).rerun.txt"
# done
#
# rerunsp1=Mz
# rerunsp4=Nb
# rerunsp5=On
#
# for Cfpsp in "${!rerunsp@}"; do
#   # echo "$Cfpsp is set to ${!Cfpsp}"
#   eval "${!Cfpsp}"motifarrayendrerun=$(wc -l repdiffmpbs_paths_"${!Cfpsp}".rerun.txt | awk -v e="$e" '{print ($1 - e)}')
# done
#
# for Dfpsp in "${!rerunsp@}"; do
#   # echo "$Dfpsp is set to ${!Dfpsp}"
#   echo '#!/bin/bash -e' > "${!Dfpsp}"'_TFfp_rerun.sh'
#   echo '#SBATCH -p ei-largemem # partition (queue)' >> "${!Dfpsp}"'_TFfp_rerun.sh'
#   echo '#SBATCH -N 1 # number of nodes' >> "${!Dfpsp}"'_TFfp_rerun.sh'
#   echo '#SBATCH -c 32 # number of cores' >> "${!Dfpsp}"'_TFfp_rerun.sh'
#   echo '#SBATCH --array=0-'"$(eval "echo \$"${!Dfpsp}"motifarrayendrerun")" >> "${!Dfpsp}"'_TFfp_rerun.sh'
#   echo '#SBATCH --mem 1012GB' >> "${!Dfpsp}"'_TFfp_rerun.sh'
#   echo '#SBATCH -t 3-23:59' >> "${!Dfpsp}"'_TFfp_rerun.sh'
#   echo '#SBATCH --constraint=intel' >> "${!Dfpsp}"'_TFfp_rerun.sh'
#   echo '#SBATCH --mail-type=ALL # notifications for job done & fail' >> "${!Dfpsp}"'_TFfp_rerun.sh'
#   echo '#SBATCH --mail-user=Tarang.Mehta@earlham.ac.uk # send-to address' >> "${!Dfpsp}"'_TFfp_rerun.sh'
#   echo '#SBATCH -o slurm.%N.%j.out # STDOUT' >> "${!Dfpsp}"'_TFfp_rerun.sh'
#   echo '#SBATCH -e slurm.%N.%j.err # STDERR' >> "${!Dfpsp}"'_TFfp_rerun.sh'
#   printf '\n' >> "${!Dfpsp}"'_TFfp_rerun.sh'
#   echo 'export PATH="$PATH:/hpc-home/mehtat/.local/bin/"' >> "${!Dfpsp}"'_TFfp_rerun.sh'
#   printf '\n' >> "${!Dfpsp}"'_TFfp_rerun.sh'
#   echo "rgtidsp1='[MzebraUMD2a]'" >> "${!Dfpsp}"'_TFfp_rerun.sh'
#   echo "rgtidsp2='[PunNye1.0]'" >> "${!Dfpsp}"'_TFfp_rerun.sh'
#   echo "rgtidsp3='[AstBur1.0]'" >> "${!Dfpsp}"'_TFfp_rerun.sh'
#   echo "rgtidsp4='[NeoBri1.0]'" >> "${!Dfpsp}"'_TFfp_rerun.sh'
#   echo "rgtidsp5='[OniloticusUMD]'" >> "${!Dfpsp}"'_TFfp_rerun.sh'
#   echo "rgtidsp6='[fAstCal1.2]'" >> "${!Dfpsp}"'_TFfp_rerun.sh'
#   echo "rgtidsp1a='MzebraUMD2a'" >> "${!Dfpsp}"'_TFfp_rerun.sh'
#   echo "rgtidsp2a='PunNye1.0'" >> "${!Dfpsp}"'_TFfp_rerun.sh'
#   echo "rgtidsp3a='AstBur1.0'" >> "${!Dfpsp}"'_TFfp_rerun.sh'
#   echo "rgtidsp4a='NeoBri1.0'" >> "${!Dfpsp}"'_TFfp_rerun.sh'
#   echo "rgtidsp5a='OniloticusUMD'" >> "${!Dfpsp}"'_TFfp_rerun.sh'
#   echo "rgtidsp6a='fAstCal1.2'" >> "${!Dfpsp}"'_TFfp_rerun.sh'
#   echo "rerunsp1=Mz" >> "${!Dfpsp}"'_TFfp_rerun.sh'
#   echo "rerunsp2=Pn" >> "${!Dfpsp}"'_TFfp_rerun.sh'
#   echo "rerunsp3=Ab" >> "${!Dfpsp}"'_TFfp_rerun.sh'
#   echo "rerunsp4=Nb" >> "${!Dfpsp}"'_TFfp_rerun.sh'
#   echo "rerunsp5=On" >> "${!Dfpsp}"'_TFfp_rerun.sh'
#   echo "rerunsp6=Ac" >> "${!Dfpsp}"'_TFfp_rerun.sh'
#   echo "pwmsp1=mz" >> "${!Dfpsp}"'_TFfp_rerun.sh'
#   echo "pwmsp2=pn" >> "${!Dfpsp}"'_TFfp_rerun.sh'
#   echo "pwmsp3=ab" >> "${!Dfpsp}"'_TFfp_rerun.sh'
#   echo "pwmsp4=nb" >> "${!Dfpsp}"'_TFfp_rerun.sh'
#   echo "pwmsp5=on" >> "${!Dfpsp}"'_TFfp_rerun.sh'
#   echo "pwmsp6=ac" >> "${!Dfpsp}"'_TFfp_rerun.sh'
#   printf '\n' >> "${!Dfpsp}"'_TFfp_rerun.sh'
#   echo 'mapfile '"${!Dfpsp}"'mpbs < repdiffmpbs_paths_'"${!Dfpsp}"'.rerun.txt' >> "${!Dfpsp}"'_TFfp_rerun.sh'
#   echo 'mapfile '"${!Dfpsp}"'read < repdiffread_paths_'"${!Dfpsp}"'.rerun.txt' >> "${!Dfpsp}"'_TFfp_rerun.sh'
#   echo 'mapfile '"${!Dfpsp}"'cond < repdiffcond_paths_'"${!Dfpsp}"'.rerun.txt' >> "${!Dfpsp}"'_TFfp_rerun.sh'
#   echo 'mapfile '"${!Dfpsp}"'out < repdiffout_paths_'"${!Dfpsp}".'rerun.txt' >> "${!Dfpsp}"'_TFfp_rerun.sh'
#   echo 'organism=\$"$(echo '"$Dfpsp | sed 's/[^0-9]//g' | sed 's/^/rgtidsp/' | sed 's/"'$/a/'"')"'"' >> "${!Dfpsp}"'_TFfp_rerun.sh'
#   echo 'output=\$"$(echo '"$Dfpsp | sed 's/[^0-9]//g' | sed 's/^/pwmsp/')"'"' >> "${!Dfpsp}"'_TFfp_rerun.sh'
#   printf '\n' >> "${!Dfpsp}"'_TFfp_rerun.sh'
#   echo 'rgt-hint differential --organism $(eval echo $organism) --bc --nc 32 --mpbs-files ${'"${!Dfpsp}"'mpbs[${SLURM_ARRAY_TASK_ID}]} --reads-files ${'"${!Dfpsp}"'read[${SLURM_ARRAY_TASK_ID}]} --conditions ${'"${!Dfpsp}"'cond[${SLURM_ARRAY_TASK_ID}]} --output-location ${'"${!Dfpsp}"'out[${SLURM_ARRAY_TASK_ID}]}' >> "${!Dfpsp}"'_TFfp_rerun.sh'
#   printf '\n' >> "${!Dfpsp}"'_TFfp_rerun.sh'
#   echo 'echo "# C. TF footprinting lineplots ~~ DONE"' >> "${!Dfpsp}"'_TFfp_rerun.sh'
# done
#
# for i in *_TFfp_rerun.sh; do sbatch $i; done

##### NOTE:
### When using the Lineplots, consider viewing/using only those where the p-val is < 0.05 in the 'differential_statistics.txt' file of each comparison
## e.g. awk '$9<0.05' $scripts/3.TFfprint_SignalTrack/Mz1_T_ATAC__Mz2_T_ATAC/differential_statistics.txt | sort -k9,9rn
# report how many of the comparisons have lineplots of motif differentials with p<0.05

for i in *_*_ATAC__*_*_ATAC/differential_statistics.txt; do
  sample=$(echo $i | sed 's|/differential_statistics.txt||g')
  total=$(wc -l $i | awk '{print $1}')
  p001=$(awk '$9<0.01' $i | wc -l)
  p005=$(awk '$9<0.05' $i | wc -l)
  echo -e "$sample\t$total\t$p001\t$p005"
done

##### ~~~~~ #####
# NOTE: for each run, the following was ran/loaded for the original footprinting
# pseudocounts: 1.0
# used database(s): cichlid{mz,pn,ab,nb,on,ac}CSsp,cichlidCW,cichlidJASPAR,jaspar_vertebrates,hocomoco
# fpr threshold for footprinting: 0.0001
# motifs loaded: 2042
##### ~~~~~ #####
# motifs outputted for differential analysis: 1719
##### ~~~~~ #####

# sample  total p<0.01  p<0.05
# 1aAc_3dpf_ATAC__1bAc_3dpf_ATAC	1719	39	110
# 2aAc_7dpf_ATAC__2bAc_7dpf_ATAC	1719	39	98
# 3aAc_12dpf_ATAC__3bAc_12dpf_ATAC	1719	53	106
# Ab5_B_ATAC__Ab6_B_ATAC	1719	41	85
# Ab5_E_ATAC__Ab6_E_ATAC	1719	16	68
# Ab5_L_ATAC__Ab6_L_ATAC	1719	27	92
# Ab5_T_ATAC__Ab6_T_ATAC	1719	50	103
# Mz1_B_ATAC__Mz2_B_ATAC	1719	49	80
# Mz1_E_ATAC__Mz2_E_ATAC	1719	51	89
# Mz1_L_ATAC__Mz2_L_ATAC	1719	42	102
# Mz1_T_ATAC__Mz2_T_ATAC	1719	43	81
# Nb4_B_ATAC__Nb5_B_ATAC	1719	24	71
# Nb4_E_ATAC__Nb5_E_ATAC	1719	26	115
# Nb4_L_ATAC__Nb5_L_ATAC	1719	31	108
# Nb4_T_ATAC__Nb5_T_ATAC	1719	6	59
# On1_B_ATAC__On2_B_ATAC	1719	52	104
# On1_B_ATAC__On3_B_ATAC	1719	20	73
# On1_E_ATAC__On2_E_ATAC	1719	37	73
# On1_E_ATAC__On3_E_ATAC	1719	38	63
# On1_G_ATAC__On2_G_ATAC	1719	52	95
# On1_G_ATAC__On3_G_ATAC	1719	34	117
# On1_L_ATAC__On2_L_ATAC	1719	27	57
# On1_L_ATAC__On3_L_ATAC	1719	44	106
# On1_T_ATAC__On2_T_ATAC	1719	53	82
# On1_T_ATAC__On3_T_ATAC	1719	46	75
# On2_B_ATAC__On3_B_ATAC	1719	27	51
# On2_E_ATAC__On3_E_ATAC	1719	29	89
# On2_G_ATAC__On3_G_ATAC	1719	30	112
# On2_L_ATAC__On3_L_ATAC	1719	49	99
# On2_T_ATAC__On3_T_ATAC	1719	43	81
# Pnm1_B_ATAC__Pnm2_B_ATAC	1719	52	96
# Pnm1_B_ATAC__Pnm3_B_ATAC	1719	31	60
# Pnm1_B_ATAC__Pnm4_B_ATAC	1719	40	77
# Pnm1_L_ATAC__Pnm2_L_ATAC	1719	43	90
# Pnm1_L_ATAC__Pnm4_L_ATAC	1719	37	96
# Pnm1_T_ATAC__Pnm2_T_ATAC	1719	45	108
# Pnm1_T_ATAC__Pnm3_T_ATAC	1719	30	94
# Pnm1_T_ATAC__Pnm4_T_ATAC	1719	28	98
# Pnm2_B_ATAC__Pnm3_B_ATAC	1719	44	86
# Pnm2_B_ATAC__Pnm4_B_ATAC	1719	45	99
# Pnm2_E_ATAC__Pnm3_E_ATAC	1719	42	60
# Pnm2_E_ATAC__Pnm4_E_ATAC	1719	38	103
# Pnm2_L_ATAC__Pnm4_L_ATAC	1719	42	84
# Pnm2_T_ATAC__Pnm3_T_ATAC	1719	30	86
# Pnm2_T_ATAC__Pnm4_T_ATAC	1719	30	85
# Pnm3_B_ATAC__Pnm4_B_ATAC	1719	57	106
# Pnm3_E_ATAC__Pnm4_E_ATAC	1719	40	97
# Pnm3_T_ATAC__Pnm4_T_ATAC	1719	42	97

################################################################################################################

### 4. Peak orthology

# A. Generate a presence and absence matrix at gene level for the peaks
# 		i. In each species, associate each peak in each tissue with a gene - this is based on the peaks being in the up to 5kb promoter region (irrespective of it's position)
# 		ii. Using gene orthology, create a unified matrix for all species. For each species, have five cols - B, E, L, T and any tissue: mark a 1 or 0 for presence or absence. Have extra cols for On G and Ac embryos.
# B. Start to analyse/subset the main tables, getting the values on
# 		i. Presence and absence of peaks in genes (in general) according to tissue and species
# 		ii. Flag peak summits falling +-100bp from TSS and their presence/absence
# C. Are the peaks preserved - use the alignment. If it's crap then run a local alignment for pairs.
# D. Get a paired nt conservation score - run phylop

################# NOTE: USE ALL SAMPLES EXCEPT FOR Pnm3_L_ATAC #################

mkdir -p $peakorth
cd $peakorth

# A. Generate a presence and absence matrix at gene level for the peaks
# 		i. In each species, associate each peak in each tissue with a gene - this is based on the peaks being in the up to 5kb promoter region (irrespective of it's position)

# parse the orthology file into a readable format: col1-orthID; col2-Mz; col3-Ac; col4-Pn; col5-Ab; col6-Nb; col7-On
# a. map the $orthmat2 to $orthid2 to extract the geneIDs and re-collate to create a new orthogroups file that has gene IDs instead

# copy orthology info here
# orthdir=(/ei/projects/9/9904ef47-97da-40a2-9cdc-f0e00f3c8378/scratch/OMAens/Output)
# orthinfo=($orthdir/OrthologousGroups.txt)
# orthmat=($orthdir/OrthologousMatrix.txt)
# orthid=($orthdir/Map-SeqNum-ID.txt)
# cp $orthinfo $peakorth
# cp $orthmat $peakorth
# cp $orthid $peakorth
orthinfo2=(OrthologousGroups.txt)
orthmat2=(OrthologousMatrix.txt)
orthid2=(Map-SeqNum-ID.txt)
orthENS=OrthologousGroups_ENSgene.txt
orthGS=OrthologousGroups_unifiedGeneSymbols.txt
orthENSGS=OrthologousGroups_ENS_GeneSymbols.txt
orthENSGScich=OrthologousGroups_ENS_GeneSymbols_6cich.txt
orthENSGS5cich=OrthologousGroups_ENS_GeneSymbols_5cich1to1.txt


cut -f1 ${orthmat2} | sed '1,5d' > Abur.${orthmat2}
cut -f2 ${orthmat2} | sed '1,5d' > Acal.${orthmat2}
cut -f3 ${orthmat2} | sed '1,5d' > Acit.${orthmat2}
cut -f4 ${orthmat2} | sed '1,5d' > Cmil.${orthmat2}
cut -f5 ${orthmat2} | sed '1,5d' > Drer.${orthmat2}
cut -f6 ${orthmat2} | sed '1,5d' > Gast.${orthmat2}
cut -f7 ${orthmat2} | sed '1,5d' > Hsap.${orthmat2}
cut -f8 ${orthmat2} | sed '1,5d' > Lcha.${orthmat2}
cut -f9 ${orthmat2} | sed '1,5d' > Locu.${orthmat2}
cut -f10 ${orthmat2} | sed '1,5d' > Mmus.${orthmat2}
cut -f11 ${orthmat2} | sed '1,5d' > Mzeb.${orthmat2}
cut -f12 ${orthmat2} | sed '1,5d' > Nbri.${orthmat2}
cut -f13 ${orthmat2} | sed '1,5d' > Oaur.${orthmat2}
cut -f14 ${orthmat2} | sed '1,5d' > Olat.${orthmat2}
cut -f15 ${orthmat2} | sed '1,5d' > Omos.${orthmat2}
cut -f16 ${orthmat2} | sed '1,5d' > Onil.${orthmat2}
cut -f17 ${orthmat2} | sed '1,5d' > Pmar.${orthmat2}
cut -f18 ${orthmat2} | sed '1,5d' > Pnye.${orthmat2}
cut -f19 ${orthmat2} | sed '1,5d' > Trub.${orthmat2}

for i in Abur Acal Acit Cmil Drer Gast Hsap Lcha Locu Mmus Mzeb Nbri Oaur Olat Omos Onil Pmar Pnye Trub; do
  grep $i $orthid2 > ${i}.${orthid2} # separate the geneIDs
done

for i in Abur Acal Acit Cmil Drer Gast Hsap Lcha Locu Mmus Mzeb Nbri Oaur Olat Omos Onil Pmar Pnye Trub; do
  awk 'BEGIN{OFS="\t"}NR==FNR{a[$2]=$0;next}{if(a[$1]){print $0,a[$1];}else{print $0,"NULL","NULL","NULL | NULL | NULL | NULL";}}' ${i}.${orthid2} ${i}.${orthmat2} | sed 's/|/\t/g' | cut -f7 > ${i}.${orthmat2}.tmp # match the matrixIDs to geneIDs - if you don't cut -f7 then you can retain other ensembl IDs
done

cut -f1 $orthinfo2 | sed '1,4d' > $orthinfo2.tmp
printf 'Orthogroup\tAbur\tAcal\tAcit\tCmil\tDrer\tGast\tHsap\tLcha\tLocu\tMmus\tMzeb\tNbri\tOaur\tOlat\tOmos\tOnil\tPmar\tPnye\tTrub\n' > Orthheaders
paste -d'\t' $orthinfo2.tmp Abur.${orthmat2}.tmp Acal.${orthmat2}.tmp Acit.${orthmat2}.tmp Cmil.${orthmat2}.tmp Drer.${orthmat2}.tmp Gast.${orthmat2}.tmp Hsap.${orthmat2}.tmp Lcha.${orthmat2}.tmp Locu.${orthmat2}.tmp Mmus.${orthmat2}.tmp Mzeb.${orthmat2}.tmp Nbri.${orthmat2}.tmp Oaur.${orthmat2}.tmp Olat.${orthmat2}.tmp Omos.${orthmat2}.tmp Onil.${orthmat2}.tmp Pmar.${orthmat2}.tmp Pnye.${orthmat2}.tmp Trub.${orthmat2}.tmp > $orthinfo2.tmp2
cat Orthheaders $orthinfo2.tmp2 | sed 's/ //g' > "$(basename "$orthinfo2.tmp2" .txt.tmp2)_ENSgene.txt"

rm *.tmp

# b. map the gene IDs to each species gene symbol

# b-i. get the gene symbols from gtf

# # get the biomart details - NOTE: originally tried to get the gene symbols from biomart but this approach yields very little gene symbols for some species, use the gtf instead
# bmsp1=hburtoni_gene_ensembl
# bmsp2=acalliptera_gene_ensembl
# bmsp3=acitrinellus_gene_ensembl
# #bmsp4=cmilii_gene_ensembl #no annotation on biomart
# bmsp5=drerio_gene_ensembl
# bmsp6=gaculeatus_gene_ensembl
# bmsp7=hsapiens_gene_ensembl
# bmsp8=lchalumnae_gene_ensembl
# bmsp9=loculatus_gene_ensembl
# bmsp10=mmusculus_gene_ensembl
# bmsp11=mzebra_gene_ensembl
# # bmsp12=nbrichardi_gene_ensembl
# bmsp13=oaureus_gene_ensembl
# bmsp14=olatipes_gene_ensembl
# # bmsp15=omossambicus_gene_ensembl
# bmsp16=oniloticus_gene_ensembl
# bmsp17=pmarinus_gene_ensembl
# bmsp18=pnyererei_gene_ensembl
# bmsp19=trubripes_gene_ensembl
#
# biomartspeciesv2=biomart_sp_all.txt
# for var in "${!bm@}"; do
#   # echo "$var is set to ${!var}"
#   echo "${!var}" >> $biomartspeciesv2
# done

# Manually downloaded the N. brichardi details from online biomart
# awk '!$5{print $0,"NA";next}1' nbrichardi_gene_ensembl_biomart1.txt | sed '1,1d' > nbrichardi_gene_ensembl_biomart1a.txt # fill the 5th column with NA if empty
# cat biomart_headers nbrichardi_gene_ensembl_biomart1a.txt > nbrichardi_gene_ensembl_biomart.txt
# awk '!$5{print $0,"NA";next}1' cmilii_gene_ensembl_biomart1.txt | sed '1,1d' > cmilii_gene_ensembl_biomart1a.txt # fill the 5th column with NA if empty
# cat biomart_headers cmilii_gene_ensembl_biomart1a.txt > cmilii_gene_ensembl_biomart.txt

# echo '#!/bin/bash -e' > 4_biomart_dl.sh
# echo '#SBATCH -p ei-short # partition (queue)' >> 4_biomart_dl.sh
# echo '#SBATCH -N 1 # number of nodes' >> 4_biomart_dl.sh
# echo '#SBATCH -c 1 # number of cores' >> 4_biomart_dl.sh
# echo '#SBATCH --mem 8000 # memory pool for all cores' >> 4_biomart_dl.sh
# echo '#SBATCH -t 0-00:45 # time (D-HH:MM)' >> 4_biomart_dl.sh
# echo '#SBATCH -o slurm.%j.out # STDOUT' >> 4_biomart_dl.sh
# echo '#SBATCH -e slurm.%j.err # STDERR' >> 4_biomart_dl.sh
# echo '#SBATCH --mail-type=END,FAIL,TIME_LIMIT_75 # notifications for job done & fail' >> 4_biomart_dl.sh
# echo '#SBATCH --mail-user=Tarang.Mehta@earlham.ac.uk # send-to addressUSERNAME=mehtat' >> 4_biomart_dl.sh
# printf '\n' >> 4_biomart_dl.sh
# echo "# this script will access the software node to download the biomart dbs" >> 4_biomart_dl.sh
# echo 'source wget-1.14' >> 4_biomart_dl.sh
# echo "USERNAME=$Usr" >> 4_biomart_dl.sh
# echo 'HOSTNAME="software"' >> 4_biomart_dl.sh
# echo "PWD=$(pwd)" >> 4_biomart_dl.sh
# printf '\n' >> 4_biomart_dl.sh
# echo 'SCRIPT="cd ${PWD}; sh 4_biomart_dl_script.sh"' >> 4_biomart_dl.sh
# printf '\n' >> 4_biomart_dl.sh
# echo "cd ${PWD}" > 4_biomart_dl_script.sh ## THIS IS PURPOSELY RENAMED DIFFERENTLY!!
# echo "while read -r i; do" >> 4_biomart_dl_script.sh
# echo -e '\twget -O ${i}_biomart1.txt '"'"'http://www.ensembl.org/biomart/martservice?query=<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE Query><Query  virtualSchemaName = "default" formatter = "TSV" header = "0" uniqueRows = "0" count = "" datasetConfigVersion = "0.6" ><Dataset name = "'"'"'${i}'"'"'" interface = "default" ><Attribute name = "ensembl_gene_id" /><Attribute name = "ensembl_gene_id_version" /><Attribute name = "ensembl_transcript_id" /><Attribute name = "ensembl_transcript_id_version" /><Attribute name = "hgnc_symbol" /></Dataset></Query>'"'" >> 4_biomart_dl_script.sh
# echo -e '\t#wget -O ${i}_biomart2.txt '"'"'http://www.ensembl.org/biomart/martservice?query=<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE Query><Query  virtualSchemaName = "default" formatter = "TSV" header = "0" uniqueRows = "0" count = "" datasetConfigVersion = "0.6" ><Dataset name = "'"'"'${i}'"'"'" interface = "default" ><Attribute name = "ensembl_transcript_id" /><Attribute name = "hgnc_symbol" /><Attribute name = "entrezgene_accession" /><Attribute name = "refseq_mrna_predicted" /></Dataset></Query>'"'" >> 4_biomart_dl_script.sh
# echo -e '\t#wget -O ${i}_biomart3.txt '"'"'http://www.ensembl.org/biomart/martservice?query=<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE Query><Query  virtualSchemaName = "default" formatter = "TSV" header = "0" uniqueRows = "0" count = "" datasetConfigVersion = "0.6" ><Dataset name = "'"'"'${i}'"'"'" interface = "default" ><Attribute name = "ensembl_transcript_id" /><Attribute name = "uniprotswissprot" /><Attribute name = "wikigene_name" /></Dataset></Query>'"'" >> 4_biomart_dl_script.sh
# echo -e '\t#wget -O ${i}_biomart4.txt '"'"'http://www.ensembl.org/biomart/martservice?query=<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE Query><Query  virtualSchemaName = "default" formatter = "TSV" header = "0" uniqueRows = "0" count = "" datasetConfigVersion = "0.6" ><Dataset name = "'"'"'${i}'"'"'" interface = "default" ><Attribute name = "ensembl_transcript_id" /><Attribute name = "zfin_id_id" /><Attribute name = "wikigene_id" /></Dataset></Query>'"'" >> 4_biomart_dl_script.sh
# echo "done < $biomartspeciesv2" >> 4_biomart_dl_script.sh
# echo 'exit' >> 4_biomart_dl_script.sh
# echo 'ssh -o StrictHostKeyChecking=no -l ${USERNAME} ${HOSTNAME} "${SCRIPT}"' >> 4_biomart_dl.sh
# printf '\n' >> 4_biomart_dl.sh
# echo "printf 'ensembl_transcript_id\thgnc_symbol\tentrezgene_accession\trefseq_mrna_predicted\tensembl_gene_id\tensembl_gene_id_version\tensembl_transcript_id\tensembl_transcript_id_version\thgnc_id\tensembl_transcript_id\tuniprotswissprot\twikigene_name\tensembl_transcript_id\tzfin_id_id\twikigene_id\n' > "'biomart_headers # NOTE - many of these cols will get removed later' >> 4_biomart_dl.sh
# echo "while read -r i; do" >> 4_biomart_dl.sh
# echo -e "\tawk '"'!$5{print $0,"NA";next}1'"' "'${i}_biomart1.txt'" | sed '1,1d' "'> ${i}_biomart1a.txt # fill the 5th column with NA if empty' >> 4_biomart_dl.sh
# echo -e "\t#awk '"'!$5{print $0,"NA";next}1'"' "'${i}_biomart1.txt > ${i}_biomart1a.txt # fill the 5th column with NA if empty' >> 4_biomart_dl.sh
# echo -e "\t#awk '"'!$2{print $0,"NA";next}1'"' "'${i}_biomart2.txt | awk '"'"'!$3{print $0,"NA";next}1'"' | awk '"'!$4{print $0,"NA";next}1'"' > "'${i}_biomart2a.txt # fill the 2nd, 3rd and 4th column with NA if empty' >> 4_biomart_dl.sh
# echo -e "\t#awk '"'!$2{print $0,"NA";next}1'"' "'${i}_biomart3.txt | awk '"'"'!$3{print $0,"NA";next}1'"' > "'${i}_biomart3a.txt # fill the 2nd and 3rd column with NA if empty' >> 4_biomart_dl.sh
# echo -e "\t#awk '"'!$2{print $0,"NA";next}1'"' "'${i}_biomart4.txt | awk '"'"'!$3{print $0,"NA";next}1'"' > "'${i}_biomart4a.txt # fill the 2nd and 3rd column with NA if empty' >> 4_biomart_dl.sh
# echo -e '\t#awk '"'BEGIN{OFS="'"\t"}NR==FNR{a[$3]=$0;next}{if(a[$1]){print $0,a[$1];}else{print $0,"NA","NA","NA","NA","NA";}}'"' "'${i}_biomart1a.txt ${i}_biomart2a.txt > ${i}_biomart1-2a.txt' >> 4_biomart_dl.sh
# echo -e '\t#awk '"'BEGIN{OFS="'"\t"}NR==FNR{a[$1]=$0;next}{if(a[$1]){print $0,a[$1];}else{print $0,"NA","NA","NA";}}'"' "'${i}_biomart3a.txt ${i}_biomart1-2a.txt > ${i}_biomart1-2-3a.txt' >> 4_biomart_dl.sh
# echo -e '\t#awk '"'BEGIN{OFS="'"\t"}NR==FNR{a[$1]=$0;next}{if(a[$1]){print $0,a[$1];}else{print $0,"NA","NA","NA";}}'"' "'${i}_biomart4a.txt ${i}_biomart1-2-3a.txt > ${i}_biomart.tmp.txt' >> 4_biomart_dl.sh
# echo -e '\tcat biomart_headers ${i}_biomart1a.txt > ${i}_biomart.txt' >> 4_biomart_dl.sh
# echo -e '\t#cat biomart_headers ${i}_biomart.tmp.txt | awk '"'{print "'$1,$2,$3,$4,$5,$6,$8,$9,$11,$12,$14,$15}'"' OFS='\t' | awk '{print "'$5,$6,$1,$7,$8,$2,$3,$4,$9,$10,$11,$12}'"' OFS='\t' > "'${i}_biomart.txt' >> 4_biomart_dl.sh
# echo -e '\t#rm ${i}_biomart.tmp.txt' >> 4_biomart_dl.sh
# echo "done < $biomartspeciesv2" >> 4_biomart_dl.sh
#
# while read -r i; do
#   awk '!$5{print $0,"NA";next}1' ${i}_biomart1.txt | sed '1,1d' > ${i}_biomart1a.txt # fill the 5th column with NA if empty
#   cat biomart_headers ${i}_biomart1a.txt > ${i}_biomart.txt
# done < $biomartspeciesv2

# for i in *_gene_ensembl_biomart.txt; do
#   count=$(awk '$5!="NA"' $i | wc -l)
#   echo -e $i'\t'$count
# done

# NOTE: the biomart approach yields very little gene symbols - instead, use the gtf's to get the gene symbols
# acalliptera_gene_ensembl_biomart.txt	2793
# acitrinellus_gene_ensembl_biomart.txt	2208
# cmilii_gene_ensembl_biomart.txt	34114
# drerio_gene_ensembl_biomart.txt	1142
# gaculeatus_gene_ensembl_biomart.txt	2036
# hburtoni_gene_ensembl_biomart.txt	2827
# hsapiens_gene_ensembl_biomart.txt	215312
# lchalumnae_gene_ensembl_biomart.txt	13582
# loculatus_gene_ensembl_biomart.txt	2205
# mmusculus_gene_ensembl_biomart.txt	4
# mzebra_gene_ensembl_biomart.txt	2553
# nbrichardi_gene_ensembl_biomart.txt	2159
# oaureus_gene_ensembl_biomart.txt	4839
# olatipes_gene_ensembl_biomart.txt	2551
# omossambicus_gene_ensembl_biomart.txt	5287
# oniloticus_gene_ensembl_biomart.txt	5245
# pmarinus_gene_ensembl_biomart.txt	749
# pnyererei_gene_ensembl_biomart.txt	2336
# trubripes_gene_ensembl_biomart.txt	3946


printf 'ensembl_gene_id_version\tensembl_gene_id\tensembl_transcript_id\tensembl_transcript_id_version\tgene_symbol\n' > biomart_headers # create a headers file for the output gene symbol annotations

# create two files to run a while read array to generate the gene symbol annotations - file1: paths to gtf and file2: output filename (make sure ordering is the same!)
ls -1 /tgac/workarea/group-vh/Tarang/Reference_Genomes/ensembl/*/*/current_gtf/*/*100.gtf.gz > gtf_paths.txt # file1

echo 'hburtoni_gene_ensembl.txt' > gs_out2.txt # file3
echo 'acalliptera_gene_ensembl.txt' >> gs_out2.txt
echo 'acitrinellus_gene_ensembl.txt' >> gs_out2.txt
echo 'mzebra_gene_ensembl.txt' >> gs_out2.txt
echo 'nbrichardi_gene_ensembl.txt' >> gs_out2.txt
echo 'oaureus_gene_ensembl.txt' >> gs_out2.txt
echo 'oniloticus_gene_ensembl.txt' >> gs_out2.txt
echo 'pnyererei_gene_ensembl.txt' >> gs_out2.txt
echo 'hsapiens_gene_ensembl.txt' >> gs_out2.txt
echo 'mmusculus_gene_ensembl.txt' >> gs_out2.txt
echo 'drerio_gene_ensembl.txt' >> gs_out2.txt
echo 'gaculeatus_gene_ensembl.txt' >> gs_out2.txt
echo 'loculatus_gene_ensembl.txt' >> gs_out2.txt
echo 'olatipes_gene_ensembl.txt' >> gs_out2.txt
echo 'trubripes_gene_ensembl.txt' >> gs_out2.txt
echo 'cmilii_gene_ensembl.txt' >> gs_out2.txt
echo 'lchalumnae_gene_ensembl.txt' >> gs_out2.txt
echo 'pmarinus_gene_ensembl.txt' >> gs_out2.txt

sed 's/.txt/.txt.tmp/g' gs_out2.txt > gs_out1.txt # file2

while read -u 3 -r file1 && read -u 4 -r file2 && read -u 5 -r file3
do
  zcat ${file1} | awk '$3=="transcript"' | cut -f9 | awk -F';' '{print $1,$2,$3,$4,$5}' OFS='\t' | sed 's/"//g' | sed 's/gene_id //g' | sed 's/gene_name //g' | sed 's/gene_source //g' | sed 's/ensembl/NA/g' | sed 's/gene_version //g' | sed 's/transcript_id //g' | sed 's/transcript_version //g' | awk '{print $1,$1"."$2,$3,$3"."$4,$5}' OFS='\t' > ${file2}
  cat biomart_headers ${file2} > ${file3}
  rm ${file2}
done 3<gtf_paths.txt 4<gs_out1.txt 5<gs_out2.txt

# these are example individual ones
# cmgtf=/tgac/workarea/group-vh/Tarang/Reference_Genomes/ensembl/vertebrates/Cmilii/current_gtf/callorhinchus_milii/Callorhinchus_milii.Callorhinchus_milii-6.1.3.100.gtf.gz
# zcat $cmgtf | awk '$3=="transcript"' | cut -f9 | awk -F';' '{print $1,$2,$3,$4,$5}' OFS='\t' | sed 's/"//g' | sed 's/gene_id //g' | sed 's/gene_name //g' | sed 's/gene_source //g' | sed 's/ensembl/NA/g' | sed 's/gene_version //g' | sed 's/transcript_id //g' | sed 's/transcript_version //g' | awk '{print $1,$1"."$2,$3,$3"."$4,$5}' OFS='\t' > cmilii_gene_ensembl_biomart.txt.tmp
# cat biomart_headers cmilii_gene_ensembl_biomart.txt.tmp > cmilii_gene_ensembl_biomart.txt
# rm cmilii_gene_ensembl_biomart.txt.tmp
#
# hsgtf=/tgac/workarea/group-vh/Tarang/Reference_Genomes/ensembl/mammals/Hsapiens/current_gtf/homo_sapiens/Homo_sapiens.GRCh38.100.gtf.gz
# zcat $hsgtf | awk '$3=="transcript"' | cut -f9 | awk -F';' '{print $1,$2,$3,$4,$5}' OFS='\t' | sed 's/"//g' | sed 's/gene_id //g' | sed 's/gene_name //g' | sed 's/gene_source //g' | sed 's/ensembl/NA/g' | sed 's/gene_version //g' | sed 's/transcript_id //g' | sed 's/transcript_version //g' | awk '{print $1,$1"."$2,$3,$3"."$4,$5}' OFS='\t' > hsapiens_gene_ensembl_biomart.txt.tmp
# cat biomart_headers hsapiens_gene_ensembl_biomart.txt.tmp > hsapiens_gene_ensembl_biomart.txt
# rm hsapiens_gene_ensembl_biomart.txt
#
# mmgtf=/tgac/workarea/group-vh/Tarang/Reference_Genomes/ensembl/mammals/Mmusculus/current_gtf/mus_musculus/Mus_musculus.GRCm38.100.gtf.gz
# zcat $mmgtf | awk '$3=="transcript"' | cut -f9 | awk -F';' '{print $1,$2,$3,$4,$5}' OFS='\t' | sed 's/"//g' | sed 's/gene_id //g' | sed 's/gene_name //g' | sed 's/gene_source //g' | sed 's/ensembl/NA/g' | sed 's/gene_version //g' | sed 's/transcript_id //g' | sed 's/transcript_version //g' | awk '{print $1,$1"."$2,$3,$3"."$4,$5}' OFS='\t' > mmusculus_gene_ensembl_biomart.txt.tmp
# cat biomart_headers mmusculus_gene_ensembl_biomart.txt.tmp > mmusculus_gene_ensembl_biomart.txt
# rm mmusculus_gene_ensembl_biomart.txt


# # b-ii. process the O. mossamibicus (they're mapped to ENSONIP IDs so use those gene symbols) and C. milii gene IDs separately based on annotation
omfuncannot=/ei/projects/f/fabef620-281f-4a74-beb6-9adbe4f03af8/data/results/CB-GENANNO-466_Oreochromis_mossambicus_annotation/Data_Package/OREMO8127_EIv1.0_Frozen_release_11May2020/EIv1.0/annotation/OREMO8127_EIv1.0.annotation.gff3.pep.fasta.functional_annotation.tsv
awk '{print $2,$1,$2,$1,$6}' OFS='\t' $omfuncannot | sed '1,1d' | sed 's/\.1//g' > OREMO8127_EIv1.0.annotation.gff3.Onorth.txt
# sed 's/ENSONIG/ENSONIP/g' oniloticus_gene_ensembl_biomart.txt | cut -f1,5 > oniloticus_gene_ensembl_biomart.txt.tmp
## NOTE: the above mapping is very poor - try to use the On gtf instead to generate a mapping file
ongtf=/tgac/workarea/group-vh/Tarang/Reference_Genomes/ensembl/cichlids/Oniloticus/current_gtf/oreochromis_niloticus/Oreochromis_niloticus.O_niloticus_UMD_NMBU.100.gtf.gz
zcat $ongtf | awk '$3=="transcript"' | cut -f9 | awk -F';' '{print $1,$2,$3,$4,$5}' OFS='\t' | sed 's/"//g' | sed 's/gene_id //g' | sed 's/gene_name //g' | sed 's/gene_source //g' | sed 's/ensembl/NA/g' | sed 's/gene_version //g' | sed 's/transcript_id //g' | sed 's/transcript_version //g' | cut -f1,5 | sed 's/ENSONIG/ENSONIP/g' > oniloticus_gene_ensembl_biomart.txt.tmp2
awk 'BEGIN{OFS="\t"}NR==FNR{a[$1]=$0;next}{if(a[$5]){print $0,a[$5];}else{print $0,"NA","NA","NA","NA";}}' oniloticus_gene_ensembl_biomart.txt.tmp2 OREMO8127_EIv1.0.annotation.gff3.Onorth.txt | awk '{print $1,$2,$3,$4,$7}' OFS='\t' > omossambicus_gene_ensembl_biomart.txt.tmp
cat biomart_headers omossambicus_gene_ensembl_biomart.txt.tmp > omossambicus_gene_ensembl.txt
rm omossambicus_gene_ensembl_biomart.txt.tmp oniloticus_gene_ensembl_biomart.txt.tmp2

for i in *_gene_ensembl.txt; do
  count=$(awk '$5!="NA"' $i | wc -l)
  echo -e $i'\t'$count
done

## This is much better for gene symbols so USE these!!
# acalliptera_gene_ensembl.txt	27701
# acitrinellus_gene_ensembl.txt	21040
# cmilii_gene_ensembl.txt	34114
# drerio_gene_ensembl.txt	59847
# gaculeatus_gene_ensembl.txt	21515
# hburtoni_gene_ensembl.txt	25659
# hsapiens_gene_ensembl.txt	227955
# lchalumnae_gene_ensembl.txt	18016
# loculatus_gene_ensembl.txt	19850
# mmusculus_gene_ensembl.txt	142700
# mzebra_gene_ensembl.txt	25651
# nbrichardi_gene_ensembl.txt	21250
# oaureus_gene_ensembl.txt	44882
# olatipes_gene_ensembl.txt	26270
# omossambicus_gene_ensembl.txt	5288
# oniloticus_gene_ensembl.txt	55956
# pmarinus_gene_ensembl.txt	6276
# pnyererei_gene_ensembl.txt	22018
# trubripes_gene_ensembl.txt	41879

# # b-iii. map each species gene symbol to gene ID
awk 'BEGIN{OFS="\t"}NR==FNR{a[$2]=$5;next}{if(a[$2]){print $0,a[$2];}else{print $0,"NA";}}' hburtoni_gene_ensembl.txt $orthENS > $orthENS.tmp1
awk 'BEGIN{OFS="\t"}NR==FNR{a[$2]=$5;next}{if(a[$3]){print $0,a[$3];}else{print $0,"NA";}}' acalliptera_gene_ensembl.txt $orthENS.tmp1 > $orthENS.tmp2
awk 'BEGIN{OFS="\t"}NR==FNR{a[$2]=$5;next}{if(a[$4]){print $0,a[$4];}else{print $0,"NA";}}' acitrinellus_gene_ensembl.txt $orthENS.tmp2 > $orthENS.tmp3
awk 'BEGIN{OFS="\t"}NR==FNR{a[$2]=$5;next}{if(a[$5]){print $0,a[$5];}else{print $0,"NA";}}' cmilii_gene_ensembl.txt $orthENS.tmp3 > $orthENS.tmp4
awk 'BEGIN{OFS="\t"}NR==FNR{a[$2]=$5;next}{if(a[$6]){print $0,a[$6];}else{print $0,"NA";}}' drerio_gene_ensembl.txt $orthENS.tmp4 > $orthENS.tmp5
awk 'BEGIN{OFS="\t"}NR==FNR{a[$2]=$5;next}{if(a[$7]){print $0,a[$7];}else{print $0,"NA";}}' gaculeatus_gene_ensembl.txt $orthENS.tmp5 > $orthENS.tmp6
awk 'BEGIN{OFS="\t"}NR==FNR{a[$2]=$5;next}{if(a[$8]){print $0,a[$8];}else{print $0,"NA";}}' hsapiens_gene_ensembl.txt $orthENS.tmp6 > $orthENS.tmp7
awk 'BEGIN{OFS="\t"}NR==FNR{a[$2]=$5;next}{if(a[$9]){print $0,a[$9];}else{print $0,"NA";}}' lchalumnae_gene_ensembl.txt $orthENS.tmp7 > $orthENS.tmp8
awk 'BEGIN{OFS="\t"}NR==FNR{a[$2]=$5;next}{if(a[$10]){print $0,a[$10];}else{print $0,"NA";}}' loculatus_gene_ensembl.txt $orthENS.tmp8 > $orthENS.tmp9
awk 'BEGIN{OFS="\t"}NR==FNR{a[$2]=$5;next}{if(a[$11]){print $0,a[$11];}else{print $0,"NA";}}' mmusculus_gene_ensembl.txt $orthENS.tmp9 > $orthENS.tmp10
awk 'BEGIN{OFS="\t"}NR==FNR{a[$2]=$5;next}{if(a[$12]){print $0,a[$12];}else{print $0,"NA";}}' mzebra_gene_ensembl.txt $orthENS.tmp10 > $orthENS.tmp11
awk 'BEGIN{OFS="\t"}NR==FNR{a[$2]=$5;next}{if(a[$13]){print $0,a[$13];}else{print $0,"NA";}}' nbrichardi_gene_ensembl.txt $orthENS.tmp11 > $orthENS.tmp12
awk 'BEGIN{OFS="\t"}NR==FNR{a[$2]=$5;next}{if(a[$14]){print $0,a[$14];}else{print $0,"NA";}}' oaureus_gene_ensembl.txt $orthENS.tmp12 > $orthENS.tmp13
awk 'BEGIN{OFS="\t"}NR==FNR{a[$2]=$5;next}{if(a[$15]){print $0,a[$15];}else{print $0,"NA";}}' olatipes_gene_ensembl.txt $orthENS.tmp13 > $orthENS.tmp14
awk 'BEGIN{OFS="\t"}NR==FNR{a[$2]=$5;next}{if(a[$16]){print $0,a[$16];}else{print $0,"NA";}}' omossambicus_gene_ensembl.txt $orthENS.tmp14 > $orthENS.tmp15
awk 'BEGIN{OFS="\t"}NR==FNR{a[$2]=$5;next}{if(a[$17]){print $0,a[$17];}else{print $0,"NA";}}' oniloticus_gene_ensembl.txt $orthENS.tmp15 > $orthENS.tmp16
awk 'BEGIN{OFS="\t"}NR==FNR{a[$2]=$5;next}{if(a[$18]){print $0,a[$18];}else{print $0,"NA";}}' pmarinus_gene_ensembl.txt $orthENS.tmp16 > $orthENS.tmp17
awk 'BEGIN{OFS="\t"}NR==FNR{a[$2]=$5;next}{if(a[$19]){print $0,a[$19];}else{print $0,"NA";}}' pnyererei_gene_ensembl.txt $orthENS.tmp17 > $orthENS.tmp18
awk 'BEGIN{OFS="\t"}NR==FNR{a[$2]=$5;next}{if(a[$20]){print $0,a[$20];}else{print $0,"NA";}}' trubripes_gene_ensembl.txt $orthENS.tmp18 > $orthENS.tmp19

# b-iv. create a unified (best) gene symbol column (so that there is no NA), reorder cols (so that a. phylo order, and b. best gene symbol is first after orth) and add headers
# NOTE: the unified best gene symbol column will be a combination of all unique gene symbols separated with ',' e.g. geneAa,geneAb
cut -f1,21-39 $orthENS.tmp19 | sed '1,1d' | sed $'s/NA\t//g' | sed $'s/\tNA//g' | awk '{print tolower($0)}' | awk '$1=toupper($1)' OFS='\t' | awk '{ n=split($0,a,FS); $0=""; j=1; delete u; for (i=1; i<=n; i++) if (!u[a[i]]++) $(j++) = a[i]; print }' OFS='\t' | awk '!$2{print $0,"NA";next}1' OFS='\t' | sed $'s/\t/,/g' | sed $'s/,/\t/' > $orthGS # this creates a two column file with OG and unique genes symbols separated by comma
awk 'BEGIN{OFS="\t"}NR==FNR{a[$1]=$2;next}{if(a[$1]){print $0,a[$1];}else{print $0,"NA";}}' $orthGS $orthENS.tmp19 | sed '1,1d' | awk '{print $1,$8,$11,$9,$3,$12,$19,$2,$13,$14,$17,$16,$4,$15,$7,$20,$6,$10,$5,$18,$40,$27,$30,$28,$22,$31,$38,$21,$32,$33,$36,$35,$23,$34,$26,$39,$25,$29,$24,$37}' OFS='\t' > $orthENSGS.tmp # this creates the penultimate file (no headers)
printf 'Orthogroup\tHsap_ENS\tMmus_ENS\tLcha_ENS\tAcal_ENS\tMzeb_ENS\tPnye_ENS\tAbur_ENS\tNbri_ENS\tOaur_ENS\tOnil_ENS\tOmos_ENS\tAcit_ENS\tOlat_ENS\tGacu_ENS\tTrub_ENS\tDrer_ENS\tLocu_ENS\tCmil_ENS\tPmar_ENS\tUnified_GeneSymbol\tHsap_GS\tMmus_GS\tLcha_GS\tAcal_GS\tMzeb_GS\tPnye_GS\tAbur_GS\tNbri_GS\tOaur_GS\tOnil_GS\tOmos_GS\tAcit_GS\tOlat_GS\tGacu_GS\tTrub_GS\tDrer_GS\tLocu_GS\tCmil_GS\tPmar_GS\n' > Orthheaders2
cat Orthheaders2 $orthENSGS.tmp > $orthENSGS

# c. prepare the file so that it is 6 sp cichlid species (and remove all the transcript versions) and orthogroups with NULL for any
cut -f1,5-9,11,21,25-29,31 $orthENSGS | awk -F '\t' 'function GSUB(F) {gsub("\\..*","",$F)} {GSUB(2);GSUB(3);GSUB(4);GSUB(5);GSUB(6);GSUB(7)}1' OFS='\t' | awk '$2!="NULL" || $3!="NULL" || $4!="NULL" || $5!="NULL" || $6!="NULL" || $7!="NULL"' > $orthENSGScich

# d. overlap IDR (narrow) peaks with 5kb promoter regions for each species
# i. overlaps do not have to be fully inside the promoter (can extend 5' or 3')
# ii. report amount (bp's) of promoter that have the peak using the -wao option in bedtools
# iii. use the IDR peak files - T (True) or F (False) indicate peaks passing IDR
# iv. in the final outputted file, remove peaks not overlapping a promoter (and report numbers - input > output)
Ac5kbpromannot=$Acg/current_gtf/astatotilapia_calliptera/Astatotilapia_calliptera.fAstCal1.2.101.5kb_promoters.bed
Mz5kbpromannot=$Mzg/current_gtf/maylandia_zebra/Maylandia_zebra.M_zebra_UMD2a.101.5kb_promoters.bed
Pn5kbpromannot=$Png/current_gtf/pundamilia_nyererei/Pundamilia_nyererei.PunNye1.0.101.5kb_promoters.bed
Ab5kbpromannot=$Abg/current_gtf/haplochromis_burtoni/Haplochromis_burtoni.AstBur1.0.101.5kb_promoters.bed
Nb5kbpromannot=$Nbg/current_gtf/neolamprologus_brichardi/Neolamprologus_brichardi.NeoBri1.0.101.5kb_promoters.bed
On5kbpromannot=$Ong/current_gtf/oreochromis_niloticus/Oreochromis_niloticus.O_niloticus_UMD_NMBU.101.5kb_promoters.bed


ml bedtools/2.25.0

for i in $idrdir/*Ac*ATAC_peaks.final.narrowPeak; do
  bedtools intersect -a ${i} -b $Ac5kbpromannot -wao | awk '$13!="-1"' > "$(basename "${i}" ).promoverlap"
done

for i in $idrdir/Mz*ATAC_peaks.final.narrowPeak; do
  bedtools intersect -a ${i} -b $Mz5kbpromannot -wao | awk '$13!="-1"' > "$(basename "${i}" ).promoverlap"
done

for i in $idrdir/Pn*ATAC_peaks.final.narrowPeak; do
  bedtools intersect -a ${i} -b $Pn5kbpromannot -wao | awk '$13!="-1"' > "$(basename "${i}" ).promoverlap"
done

for i in $idrdir/Ab*ATAC_peaks.final.narrowPeak; do
  bedtools intersect -a ${i} -b $Ab5kbpromannot -wao | awk '$13!="-1"' > "$(basename "${i}" ).promoverlap"
done

for i in $idrdir/Nb*ATAC_peaks.final.narrowPeak; do
  bedtools intersect -a ${i} -b $Nb5kbpromannot -wao | awk '$13!="-1"' > "$(basename "${i}" ).promoverlap"
done

for i in $idrdir/On*ATAC_peaks.final.narrowPeak; do
  bedtools intersect -a ${i} -b $On5kbpromannot -wao | awk '$13!="-1"' > "$(basename "${i}" ).promoverlap"
done

# get promoter mapping stats
echo 'Peak-Promoter mapping stats outputted to: PeakProm_overlap_stats.txt'
for i in *.promoverlap; do
  sample=$(echo $i | sed 's/_peaks.final.narrowPeak.promoverlap//g')
  total=$(wc -l ${i} | awk '{print $1}')
  true=$(awk '$11=="T"' ${i} | wc -l)
  false=$(awk '$11=="F"' ${i} | wc -l)
  echo -e "$sample\t$total\t$true\t$false" >> PeakProm_overlap_stats.txt
done


# e. Map gene promoter bed files to orthology info
# the native awk output + amendments for cols will be:
printf 'Orthogroup\tAc_ENS\tMz_ENS\tPn_ENS\tAb_ENS\tNb_ENS\tOn_ENS\tUnified_GeneSymbol\tAc_GS\tMz_GS\tPn_GS\tAb_GS\tNb_GS\tOn_GS\tPeak_scaff\tPeak_start\tPeak_end\tPeak_ID\tMACS2_integer_score\tstrand\tFC_peaksummit\tpval\tqval\tSummit_to_PeakStart\tIDR\tProm_scaff\tProm_start\tProm_end\tProm_geneENS\tProm_geneENS\tProm_strand\tPeak_Prom_overlap\tTSS_start\n' > promheaders1

for i in *Ac*_peaks.final.narrowPeak.promoverlap; do
  awk 'BEGIN{OFS="\t"}NR==FNR{a[$2]=$0;next}{if(a[$15]){print $0,a[$15];}else{print $0,"NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL";}}' $orthENSGScich ${i} | sed '1,1d' | sed 's|/ei/projects/.*5.peak_calling/||g' | awk '{print $19,$20,$21,$22,$23,$24,$25,$26,$27,$28,$29,$30,$31,$32,$1,$2,$3,$4,$5,$6,$7,$8,$9,$10,$11,$12,$13,$14,$15,$16,$17,$18}' OFS='\t' | awk '{print $0,$28+1}' OFS='\t' > ${i}.orth.tmp
  cat promheaders1 ${i}.orth.tmp > ${i}.orth1
  rm ${i}.orth.tmp
done

for i in Mz*_peaks.final.narrowPeak.promoverlap; do
  awk 'BEGIN{OFS="\t"}NR==FNR{a[$3]=$0;next}{if(a[$15]){print $0,a[$15];}else{print $0,"NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL";}}' $orthENSGScich ${i} | sed '1,1d' | sed 's|/ei/projects/.*5.peak_calling/||g' | awk '{print $19,$20,$21,$22,$23,$24,$25,$26,$27,$28,$29,$30,$31,$32,$1,$2,$3,$4,$5,$6,$7,$8,$9,$10,$11,$12,$13,$14,$15,$16,$17,$18}' OFS='\t' | awk '{print $0,$28+1}' OFS='\t' > ${i}.orth.tmp
  cat promheaders1 ${i}.orth.tmp > ${i}.orth1
  rm ${i}.orth.tmp
done

for i in Pn*_peaks.final.narrowPeak.promoverlap; do
  awk 'BEGIN{OFS="\t"}NR==FNR{a[$4]=$0;next}{if(a[$15]){print $0,a[$15];}else{print $0,"NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL";}}' $orthENSGScich ${i} | sed '1,1d' | sed 's|/ei/projects/.*5.peak_calling/||g' | awk '{print $19,$20,$21,$22,$23,$24,$25,$26,$27,$28,$29,$30,$31,$32,$1,$2,$3,$4,$5,$6,$7,$8,$9,$10,$11,$12,$13,$14,$15,$16,$17,$18}' OFS='\t' | awk '{print $0,$28+1}' OFS='\t' > ${i}.orth.tmp
  cat promheaders1 ${i}.orth.tmp > ${i}.orth1
  rm ${i}.orth.tmp
done

for i in Ab*_peaks.final.narrowPeak.promoverlap; do
  awk 'BEGIN{OFS="\t"}NR==FNR{a[$5]=$0;next}{if(a[$15]){print $0,a[$15];}else{print $0,"NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL";}}' $orthENSGScich ${i} | sed '1,1d' | sed 's|/ei/projects/.*5.peak_calling/||g' | awk '{print $19,$20,$21,$22,$23,$24,$25,$26,$27,$28,$29,$30,$31,$32,$1,$2,$3,$4,$5,$6,$7,$8,$9,$10,$11,$12,$13,$14,$15,$16,$17,$18}' OFS='\t' | awk '{print $0,$28+1}' OFS='\t' > ${i}.orth.tmp
  cat promheaders1 ${i}.orth.tmp > ${i}.orth1
  rm ${i}.orth.tmp
done

for i in Nb*_peaks.final.narrowPeak.promoverlap; do
  awk 'BEGIN{OFS="\t"}NR==FNR{a[$6]=$0;next}{if(a[$15]){print $0,a[$15];}else{print $0,"NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL";}}' $orthENSGScich ${i} | sed '1,1d' | sed 's|/ei/projects/.*5.peak_calling/||g' | awk '{print $19,$20,$21,$22,$23,$24,$25,$26,$27,$28,$29,$30,$31,$32,$1,$2,$3,$4,$5,$6,$7,$8,$9,$10,$11,$12,$13,$14,$15,$16,$17,$18}' OFS='\t' | awk '{print $0,$28+1}' OFS='\t' > ${i}.orth.tmp
  cat promheaders1 ${i}.orth.tmp > ${i}.orth1
  rm ${i}.orth.tmp
done

for i in On*_peaks.final.narrowPeak.promoverlap; do
  awk 'BEGIN{OFS="\t"}NR==FNR{a[$7]=$0;next}{if(a[$15]){print $0,a[$15];}else{print $0,"NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL";}}' $orthENSGScich ${i} | sed '1,1d' | sed 's|/ei/projects/.*5.peak_calling/||g' | awk '{print $19,$20,$21,$22,$23,$24,$25,$26,$27,$28,$29,$30,$31,$32,$1,$2,$3,$4,$5,$6,$7,$8,$9,$10,$11,$12,$13,$14,$15,$16,$17,$18}' OFS='\t' | awk '{print $0,$28+1}' OFS='\t' > ${i}.orth.tmp
  cat promheaders1 ${i}.orth.tmp > ${i}.orth1
  rm ${i}.orth.tmp
done

# 1.simplify cols; 2.remove peaks that did not map to an OG; 3. sort based on orthogroup (ignoring header line)
for i in *Ac*.orth1; do
  cut -f1,2,8,9,15-28,32,33 ${i} | awk '$1!="NULL"' > "$(basename "${i}" .orth1).orth2" # Ac
done

for i in Mz*.orth1; do
  cut -f1,3,8,10,15-28,32,33 ${i} | awk '$1!="NULL"' > "$(basename "${i}" .orth1).orth2" # Mz
done

for i in Pn*.orth1; do
  cut -f1,4,8,11,15-28,32,33 ${i} | awk '$1!="NULL"' > "$(basename "${i}" .orth1).orth2" # Pn
done

for i in Ab*.orth1; do
  cut -f1,5,8,12,15-28,32,33 ${i} | awk '$1!="NULL"' > "$(basename "${i}" .orth1).orth2" # Ab
done

for i in Nb*.orth1; do
  cut -f1,6,8,13,15-28,32,33 ${i} | awk '$1!="NULL"' > "$(basename "${i}" .orth1).orth2" # Nb
done

for i in On*.orth1; do
  cut -f1,7,8,14,15-28,32,33 ${i} | awk '$1!="NULL"' > "$(basename "${i}" .orth1).orth2" # On
done


# for i in *Ac*.orth1; do
#   cut -f1,2,8,9,15-28,31,32 ${i} | awk '{if($20 == "1") print $1,$2,$3,$4,$5,$6,$7,$8,$9,$10,$11,$12,$13,$14,$15,$16,$17,$18,$19,"NULL"; else print $0;}' OFS='\t' > "$(basename "${i}" .orth1).orth2" # Ac
# done
#
# for i in Mz*.orth1; do
#   cut -f1,3,8,10,15-28,31,32 ${i} | awk '{if($20 == "1") print $1,$2,$3,$4,$5,$6,$7,$8,$9,$10,$11,$12,$13,$14,$15,$16,$17,$18,$19,"NULL"; else print $0;}' OFS='\t' > "$(basename "${i}" .orth1).orth2" # Mz
# done
#
# for i in Pn*.orth1; do
#   cut -f1,4,8,11,15-28,31,32 ${i} | awk '{if($20 == "1") print $1,$2,$3,$4,$5,$6,$7,$8,$9,$10,$11,$12,$13,$14,$15,$16,$17,$18,$19,"NULL"; else print $0;}' OFS='\t' > "$(basename "${i}" .orth1).orth2" # Pn
# done
#
# for i in Ab*.orth1; do
#   cut -f1,5,8,12,15-28,31,32 ${i} | awk '{if($20 == "1") print $1,$2,$3,$4,$5,$6,$7,$8,$9,$10,$11,$12,$13,$14,$15,$16,$17,$18,$19,"NULL"; else print $0;}' OFS='\t' > "$(basename "${i}" .orth1).orth2" # Ab
# done
#
# for i in Nb*.orth1; do
#   cut -f1,6,8,13,15-28,31,32 ${i} | awk '{if($20 == "1") print $1,$2,$3,$4,$5,$6,$7,$8,$9,$10,$11,$12,$13,$14,$15,$16,$17,$18,$19,"NULL"; else print $0;}' OFS='\t' > "$(basename "${i}" .orth1).orth2" # Nb
# done
#
# for i in On*.orth1; do
#   cut -f1,7,8,14,15-28,31,32 ${i} | awk '{if($20 == "1") print $1,$2,$3,$4,$5,$6,$7,$8,$9,$10,$11,$12,$13,$14,$15,$16,$17,$18,$19,"NULL"; else print $0;}' OFS='\t' > "$(basename "${i}" .orth1).orth2" # On
# done

## Using the simplified cols:
# first, sort the peaks based on 1. Orthogroup; 2. True for IDR, then 3. Summit of peak distance from TSS (but will numeric sort negative numbers at top e.g. -100, -20, 0, 10, 20 etc.), then 4. lowest qval > *.orth3
# second, pick the best 'representative' peak for each orthogroup by sorting based on orthogroup and then selecting the top based on the sort of *.orth3 > *.orth4

printf 'Orthogroup\tSp_ENS\tUnified_GeneSymbol\tSp_GS\tPeak_scaff\tPeak_start\tPeak_end\tPeak_ID\tMACS2_integer_score\tstrand\tFC_peaksummit\tpval\tqval\tSummit_to_PeakStart\tIDR\tProm_scaff\tProm_start\tProm_end\tPeak_Prom_overlap\tTSS_start\tPeak_summit_pos\tSummit_to_TSS\n' > orth3_4_header

for i in *.orth2; do
  sed '1,1d' ${i} | awk '$1!="NULL"' | awk '{print $0,$6+$14}' OFS='\t' > ${i}.tmp
  awk '{print $0,$20-$21}' OFS='\t' ${i}.tmp | sort -k1,1 -k15,15r -k22,22g -k13,13r > "$(basename "${i}" .orth2).orth3.tmp"
  cat orth3_4_header "$(basename "${i}" .orth2).orth3.tmp" > "$(basename "${i}" .orth2).orth3"
  sed '1,1d' "$(basename "${i}" .orth2).orth3" | sort -k1,1 -u  > "$(basename "${i}" .orth2).orth4.tmp"
  cat orth3_4_header "$(basename "${i}" .orth2).orth4.tmp" > "$(basename "${i}" .orth2).orth4"
  rm ${i}.tmp
  rm "$(basename "${i}" .orth2).orth3.tmp"
  rm "$(basename "${i}" .orth2).orth4.tmp"
done

# second, map the 'representative' peaks to all orthogroups, inserting NULL if no peaks present - this will be used for the PA matrix > *.orth5

for i in *Ac*.orth4; do
  awk 'BEGIN{OFS="\t"}NR==FNR{a[$1]=$0;next}{if(a[$1]){print $0,a[$1];}else{print $0,"NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL";}}' ${i} $orthENSGScich | awk '{print $1,$2,$8,$9,$19,$20,$21,$22,$23,$24,$25,$26,$27,$28,$29,$30,$31,$32,$33,$34,$35,$36}' OFS='\t' > "$(basename "${i}" .orth4).orth5"
done

for i in Mz*.orth4; do
  awk 'BEGIN{OFS="\t"}NR==FNR{a[$1]=$0;next}{if(a[$1]){print $0,a[$1];}else{print $0,"NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL";}}' ${i} $orthENSGScich | awk '{print $1,$3,$8,$10,$19,$20,$21,$22,$23,$24,$25,$26,$27,$28,$29,$30,$31,$32,$33,$34,$35,$36}' OFS='\t' > "$(basename "${i}" .orth4).orth5"
done

for i in Pn*.orth4; do
  awk 'BEGIN{OFS="\t"}NR==FNR{a[$1]=$0;next}{if(a[$1]){print $0,a[$1];}else{print $0,"NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL";}}' ${i} $orthENSGScich | awk '{print $1,$4,$8,$11,$19,$20,$21,$22,$23,$24,$25,$26,$27,$28,$29,$30,$31,$32,$33,$34,$35,$36}' OFS='\t' > "$(basename "${i}" .orth4).orth5"
done

for i in Ab*.orth4; do
  awk 'BEGIN{OFS="\t"}NR==FNR{a[$1]=$0;next}{if(a[$1]){print $0,a[$1];}else{print $0,"NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL";}}' ${i} $orthENSGScich | awk '{print $1,$5,$8,$12,$19,$20,$21,$22,$23,$24,$25,$26,$27,$28,$29,$30,$31,$32,$33,$34,$35,$36}' OFS='\t' > "$(basename "${i}" .orth4).orth5"
done

for i in Nb*.orth4; do
  awk 'BEGIN{OFS="\t"}NR==FNR{a[$1]=$0;next}{if(a[$1]){print $0,a[$1];}else{print $0,"NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL";}}' ${i} $orthENSGScich | awk '{print $1,$6,$8,$13,$19,$20,$21,$22,$23,$24,$25,$26,$27,$28,$29,$30,$31,$32,$33,$34,$35,$36}' OFS='\t' > "$(basename "${i}" .orth4).orth5"
done

for i in On*.orth4; do
  awk 'BEGIN{OFS="\t"}NR==FNR{a[$1]=$0;next}{if(a[$1]){print $0,a[$1];}else{print $0,"NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL";}}' ${i} $orthENSGScich | awk '{print $1,$7,$8,$14,$19,$20,$21,$22,$23,$24,$25,$26,$27,$28,$29,$30,$31,$32,$33,$34,$35,$36}' OFS='\t' > "$(basename "${i}" .orth4).orth5"
done

# final files to use for presence/absence mapping are *.orth5

# 		ii. Using gene orthology, create a unified matrix for all species (only Mz, Pn, Ab, Nb, and On). For each species, have five cols - B, E, L, T and any tissue: mark a 1 or 0 for presence or absence. Have an extra col for On G.
#     At this stage, create a separate presence-absence matrix for the Ac embryos (3, 7 and 12 dpf)

# create two unified matrices - one for IDR True and another for IDR False peaks
# col1:Orthogroup, col2:Unified_GeneSymbol, col3-n:Samples

Tmat=MzPnAbNbOn_BELT_G_ATAC_TrueIDR_PAmat_1.txt
Fmat=MzPnAbNbOn_BELT_G_ATAC_FalseIDR_PAmat_1.txt
AcTmat=Ac_3_7_12dpf_ATAC_TrueIDR_PAmat_1.txt
AcFmat=Ac_3_7_12dpf_ATAC_FalseIDR_PAmat_1.txt

for i in *.orth5; do
  sample=$(echo ${i} | sed 's/_ATAC_peaks.final.narrowPeak.promoverlap.orth5//g')
  printf "Orthogroup\tUnified_GeneSymbol\t$sample\n" > ${i}.True
  awk '{if($8!="NULL" && $15 == "T") print $1,$3,"1"; else print $1,$3,"0"}' OFS='\t' ${i} | sed '1,1d' >> ${i}.True
  printf "Orthogroup\tUnified_GeneSymbol\t$sample\n" > ${i}.False
  awk '{if($8!="NULL" && $15 == "F") print $1,$3,"1"; else print $1,$3,"0"}' OFS='\t' ${i} | sed '1,1d' >> ${i}.False
done # for loop to generate intermediate matrix files for each sample - one for true IDR and one for false IDR

# for loop over all true and all false files to create the unified matrix
i=0
cut -f1,2 Ab5_B_ATAC_peaks.final.narrowPeak.promoverlap.orth5.True > delim   ## use first two columns as delimiter (as they will be the same for all files)
for file in {Mz,Pn,Ab,Nb,On}*_*_ATAC_peaks*.True; do
  i=$(($i+1))  ## for adding count to distinguish files from original ones
  cut -f3 $file > ${file}__${i}.temp
done
paste -d'\t' delim {Mz,Pn,Ab,Nb,On}*orth5.True__*.temp > $Tmat # do the join

i=0
for file in {Mz,Pn,Ab,Nb,On}*_*_ATAC_peaks*.False; do
  i=$(($i+1))  ## for adding count to distinguish files from original ones
  cut -f3 $file > ${file}__${i}.temp
done
paste -d'\t' delim {Mz,Pn,Ab,Nb,On}*orth5.False__*.temp > $Fmat # do the join

i=0
for file in *Ac_*_ATAC_peaks*.True; do
  i=$(($i+1))  ## for adding count to distinguish files from original ones
  cut -f3 $file > ${file}__${i}.temp
done
paste -d'\t' delim *Ac_*_ATAC_peaks*.True__*.temp > $AcTmat # do the join

i=0
for file in *Ac_*_ATAC_peaks*.False; do
  i=$(($i+1))  ## for adding count to distinguish files from original ones
  cut -f3 $file > ${file}__${i}.temp
done
paste -d'\t' delim *Ac_*_ATAC_peaks*.False__*.temp > $AcFmat # do the join

rm *orth5.True *orth5.False *__*.temp delim
#### AT THIS POINT, YOU STOPPED WORKING WITH THE Ac DATA


# B. Start to analyse/subset the main tables, getting the values on (remember, this is generic presence/absence - any peak within the promoter is a 1)

#     i. Presence and absence of peaks in 1-to-1 (5 sp) orthologs only
awk '$3!="NULL" && $4!="NULL" && $5!="NULL" && $6!="NULL" && $7!="NULL"' $orthENSGScich | cut -f1,3-8,10-14 > $orthENSGS5cich # 13,997 1-to-1 orthologs between the 5 species
awk 'BEGIN{OFS="\t"}NR==FNR{a[$1]=$1;next}{if(a[$1]){print $0,a[$1];}else{print $0,"REMOVEME";}}' $orthENSGS5cich $Tmat | grep -v 'REMOVEME' | cut -f1-56 > "$(basename "$Tmat" 1.txt)2.txt" # 13,997
awk 'BEGIN{OFS="\t"}NR==FNR{a[$1]=$1;next}{if(a[$1]){print $0,a[$1];}else{print $0,"REMOVEME";}}' $orthENSGS5cich $Fmat | grep -v 'REMOVEME' | cut -f1-56 > "$(basename "$Fmat" 1.txt)2.txt" # 13,997

# 		ii. Presence and absence of peaks in genes (in general) according to tissue and species - run on 1-to-1 above and first filter out for replicates with inconsistent presence or absence e.g. present in one not absent in other replicates, but only needs to be present in at least 2 replicates
################# NOTE: USE ALL SAMPLES EXCEPT FOR Pnm3_L_ATAC #################

# first, filter out for replicates with inconsistent presence or absence e.g. present in one and not absent in other replicates, but only needs to be present in at least 2 replicates

cd /ei/projects/9/9e238063-c905-4076-a975-f7c7f85dbd56/scratch/ATACseq/3.run2/4.Peak_Orth

#### TO DO THIS CORRECTLY, YOU NEED TO ..
# 1. check that each replicate is 1 e.g. Mz1_B = 1 (col3) AND Mz2_B = 1 (col7)
# 2. You then need to run this (and not pipe) individually for each species, and then join the output

awk '$3==1 && $7==1 || $4==1 && $8==1 || $5==1 && $9==1 || $6==1 && $10==1' "$(basename "$Tmat" 1.txt)2.txt" > "$(basename "$Tmat" 1.txt)Mz_tojoin_3.txt"
awk '$11==1 && $14==1 || $11==1 && $18==1 || $11==1 && $22==1 || $14==1 && $18==1 || $14==1 && $22==1 || $12==1 && $16==1 || $12==1 && $24==1 || $16==1 && $24==1 || $13==1 && $17==1 || $13==1 && $21==1 || $13==1 && $25==1 || $17==1 && $21==1 || $17==1 && $25==1 || $21==1 && $25==1 || $15==1 && $19==1 || $15==1 && $23==1 || $19==1 && $23==1' "$(basename "$Tmat" 1.txt)2.txt" > "$(basename "$Tmat" 1.txt)Pn_tojoin_3.txt"
awk '$26==1 && $30==1 || $27==1 && $31==1 || $28==1 && $32==1 || $29==1 && $33==1' "$(basename "$Tmat" 1.txt)2.txt" > "$(basename "$Tmat" 1.txt)Ab_tojoin_3.txt"
awk '$34==1 && $38==1 || $35==1 && $39==1 || $36==1 && $40==1 || $37==1 && $41==1' "$(basename "$Tmat" 1.txt)2.txt" > "$(basename "$Tmat" 1.txt)Nb_tojoin_3.txt"
awk '$42==1 && $47==1 || $42==1 && $52==1 || $47==1 && $52==1 || $43==1 && $48==1 || $43==1 && $53==1 || $48==1 && $53==1 || $44==1 && $49==1 || $44==1 && $54==1 || $49==1 && $54==1 || $45==1 && $50==1 || $45==1 && $55==1 || $50==1 && $55==1 || $46==1 && $51==1 || $46==1 && $56==1 || $51==1 && $56==1' "$(basename "$Tmat" 1.txt)2.txt" > "$(basename "$Tmat" 1.txt)On_tojoin_3.txt"

awk '$3==1 && $7==1 || $4==1 && $8==1 || $5==1 && $9==1 || $6==1 && $10==1' "$(basename "$Fmat" 1.txt)2.txt" > "$(basename "$Fmat" 1.txt)Mz_tojoinF_3.txt"
awk '$11==1 && $14==1 || $11==1 && $18==1 || $11==1 && $22==1 || $14==1 && $18==1 || $14==1 && $22==1 || $12==1 && $16==1 || $12==1 && $24==1 || $16==1 && $24==1 || $13==1 && $17==1 || $13==1 && $21==1 || $13==1 && $25==1 || $17==1 && $21==1 || $17==1 && $25==1 || $21==1 && $25==1 || $15==1 && $19==1 || $15==1 && $23==1 || $19==1 && $23==1' "$(basename "$Fmat" 1.txt)2.txt" > "$(basename "$Fmat" 1.txt)Pn_tojoinF_3.txt"
awk '$26==1 && $30==1 || $27==1 && $31==1 || $28==1 && $32==1 || $29==1 && $33==1' "$(basename "$Fmat" 1.txt)2.txt" > "$(basename "$Fmat" 1.txt)Ab_tojoinF_3.txt"
awk '$34==1 && $38==1 || $35==1 && $39==1 || $36==1 && $40==1 || $37==1 && $41==1' "$(basename "$Fmat" 1.txt)2.txt" > "$(basename "$Fmat" 1.txt)Nb_tojoinF_3.txt"
awk '$42==1 && $47==1 || $42==1 && $52==1 || $47==1 && $52==1 || $43==1 && $48==1 || $43==1 && $53==1 || $48==1 && $53==1 || $44==1 && $49==1 || $44==1 && $54==1 || $49==1 && $54==1 || $45==1 && $50==1 || $45==1 && $55==1 || $50==1 && $55==1 || $46==1 && $51==1 || $46==1 && $56==1 || $51==1 && $56==1' "$(basename "$Fmat" 1.txt)2.txt" > "$(basename "$Fmat" 1.txt)On_tojoinF_3.txt"

# get counts - note that these are all lines, not unique
# 9319 MzPnAbNbOn_BELT_G_ATAC_TrueIDR_PAmat_Ab_tojoin_3.txt
# 10398 MzPnAbNbOn_BELT_G_ATAC_TrueIDR_PAmat_Mz_tojoin_3.txt
# 9319 MzPnAbNbOn_BELT_G_ATAC_TrueIDR_PAmat_Nb_tojoin_3.txt
# 12149 MzPnAbNbOn_BELT_G_ATAC_TrueIDR_PAmat_On_tojoin_3.txt
# 11071 MzPnAbNbOn_BELT_G_ATAC_TrueIDR_PAmat_Pn_tojoin_3.txt
#
# 4446 MzPnAbNbOn_BELT_G_ATAC_FalseIDR_PAmat_Ab_tojoinF_3.txt
# 1688 MzPnAbNbOn_BELT_G_ATAC_FalseIDR_PAmat_Mz_tojoinF_3.txt
# 9946 MzPnAbNbOn_BELT_G_ATAC_FalseIDR_PAmat_Nb_tojoinF_3.txt
# 4609 MzPnAbNbOn_BELT_G_ATAC_FalseIDR_PAmat_On_tojoinF_3.txt
# 2941 MzPnAbNbOn_BELT_G_ATAC_FalseIDR_PAmat_Pn_tojoinF_3.txt

cat *_tojoin_3.txt | sort -u > "$(basename "$Tmat" 1.txt)3.txt" # 13,618 - 13,618/13,997
cat *_tojoinF_3.txt | sort -u > "$(basename "$Fmat" 1.txt)3.txt" # 11,740 - 11,740/13,997

head -1 $Tmat > MzPnAbNbOn_BELT_G_ATAC_header.txt
for i in MzPnAbNbOn_BELT_G_ATAC_{True,False}IDR_PAmat_3.txt; do
  cat MzPnAbNbOn_BELT_G_ATAC_header.txt $i > ${i}.tmp
  rm ${i}
  mv ${i}.tmp ${i}
done

for i in MzPnAbNbOn_BELT_G_ATAC_{True,False}IDR_PAmat_2.txt; do
  sed '1,1d' $i > ${i}.tmp
  rm ${i}
  mv ${i}.tmp ${i}
done

# second, create a general presence and absence of peaks in genes according to tissue and species

for i in MzPnAbNbOn_BELT_G_ATAC_*IDR_PAmat_3.txt; do
  awk '{print $1,$2,$3"|"$7,$4"|"$8,$5"|"$9,$6"|"$10,$11"|"$14"|"$18"|"$22,$12"|"$16"|"$24,$13"|"$17"|"$21"|"$25,$15"|"$19"|"$23,$26"|"$30,$27"|"$31,$28"|"$32,$29"|"$33,$34"|"$38,$35"|"$39,$36"|"$40,$37"|"$41,$42"|"$47"|"$52,$43"|"$48"|"$53,$44"|"$49"|"$54,$45"|"$50"|"$55,$46"|"$51"|"$56}' OFS='\t' ${i} > "$(basename "${i}" 3.txt)4.txt"
done

printf 'Orthogroup\tUnified_GeneSymbol\tMz_B\tMz_E\tMz_L\tMz_T\tPnm_B\tPnm_L\tPnm_T\tPnm_E\tAb_B\tAb_E\tAb_L\tAb_T\tNb_B\tNb_E\tNb_L\tNb_T\tOn_B\tOn_E\tOn_G\tOn_L\tOn_T\n' > MzPnAbNbOn_BELT_G_ATAC_header # create a header

for i in MzPnAbNbOn_BELT_G_ATAC_*IDR_PAmat_4.txt; do
  awk '{if($3 == "0|0")print $1,$2,"0",$4,$5,$6,$7,$8,$9,$10,$11,$12,$13,$14,$15,$16,$17,$18,$19,$20,$21,$22,$23;else print $1,$2,"1",$4,$5,$6,$7,$8,$9,$10,$11,$12,$13,$14,$15,$16,$17,$18,$19,$20,$21,$22,$23;}' OFS='\t' ${i} | awk '{if($4 == "0|0")print $1,$2,$3,"0",$5,$6,$7,$8,$9,$10,$11,$12,$13,$14,$15,$16,$17,$18,$19,$20,$21,$22,$23;else print $1,$2,$3,"1",$5,$6,$7,$8,$9,$10,$11,$12,$13,$14,$15,$16,$17,$18,$19,$20,$21,$22,$23;}' OFS='\t' | awk '{if($5 == "0|0")print $1,$2,$3,$4,"0",$6,$7,$8,$9,$10,$11,$12,$13,$14,$15,$16,$17,$18,$19,$20,$21,$22,$23;else print $1,$2,$3,$4,"1",$6,$7,$8,$9,$10,$11,$12,$13,$14,$15,$16,$17,$18,$19,$20,$21,$22,$23;}' OFS='\t' | awk '{if($6 == "0|0")print $1,$2,$3,$4,$5,"0",$7,$8,$9,$10,$11,$12,$13,$14,$15,$16,$17,$18,$19,$20,$21,$22,$23;else print $1,$2,$3,$4,$5,"1",$7,$8,$9,$10,$11,$12,$13,$14,$15,$16,$17,$18,$19,$20,$21,$22,$23;}' OFS='\t' | awk '{if($7 == "0|0|0|0")print $1,$2,$3,$4,$5,$6,"0",$8,$9,$10,$11,$12,$13,$14,$15,$16,$17,$18,$19,$20,$21,$22,$23;if($7 == "1|0|0|0")print $1,$2,$3,$4,$5,$6,"0",$8,$9,$10,$11,$12,$13,$14,$15,$16,$17,$18,$19,$20,$21,$22,$23;if($7 == "0|1|0|0")print $1,$2,$3,$4,$5,$6,"0",$8,$9,$10,$11,$12,$13,$14,$15,$16,$17,$18,$19,$20,$21,$22,$23;if($7 == "0|0|1|0")print $1,$2,$3,$4,$5,$6,"0",$8,$9,$10,$11,$12,$13,$14,$15,$16,$17,$18,$19,$20,$21,$22,$23;if($7 == "0|0|0|1")print $1,$2,$3,$4,$5,$6,"0",$8,$9,$10,$11,$12,$13,$14,$15,$16,$17,$18,$19,$20,$21,$22,$23;if($7 == "1|0|0|1")print $1,$2,$3,$4,$5,$6,"1",$8,$9,$10,$11,$12,$13,$14,$15,$16,$17,$18,$19,$20,$21,$22,$23;if($7 == "1|1|0|0")print $1,$2,$3,$4,$5,$6,"1",$8,$9,$10,$11,$12,$13,$14,$15,$16,$17,$18,$19,$20,$21,$22,$23;if($7 == "0|1|1|0")print $1,$2,$3,$4,$5,$6,"1",$8,$9,$10,$11,$12,$13,$14,$15,$16,$17,$18,$19,$20,$21,$22,$23;if($7 == "0|0|1|1")print $1,$2,$3,$4,$5,$6,"1",$8,$9,$10,$11,$12,$13,$14,$15,$16,$17,$18,$19,$20,$21,$22,$23;if($7 == "0|1|0|1")print $1,$2,$3,$4,$5,$6,"1",$8,$9,$10,$11,$12,$13,$14,$15,$16,$17,$18,$19,$20,$21,$22,$23;if($7 == "1|0|1|0")print $1,$2,$3,$4,$5,$6,"1",$8,$9,$10,$11,$12,$13,$14,$15,$16,$17,$18,$19,$20,$21,$22,$23;if($7 == "1|1|1|0")print $1,$2,$3,$4,$5,$6,"1",$8,$9,$10,$11,$12,$13,$14,$15,$16,$17,$18,$19,$20,$21,$22,$23;if($7 == "0|1|1|1")print $1,$2,$3,$4,$5,$6,"1",$8,$9,$10,$11,$12,$13,$14,$15,$16,$17,$18,$19,$20,$21,$22,$23;if($7 == "1|1|0|1")print $1,$2,$3,$4,$5,$6,"1",$8,$9,$10,$11,$12,$13,$14,$15,$16,$17,$18,$19,$20,$21,$22,$23;if($7 == "1|0|1|1")print $1,$2,$3,$4,$5,$6,"1",$8,$9,$10,$11,$12,$13,$14,$15,$16,$17,$18,$19,$20,$21,$22,$23;if($7 == "1|1|1|1")print $1,$2,$3,$4,$5,$6,"1",$8,$9,$10,$11,$12,$13,$14,$15,$16,$17,$18,$19,$20,$21,$22,$23;}' OFS='\t' | awk '{if($8 == "0|0|0")print $1,$2,$3,$4,$5,$6,$7,"0",$9,$10,$11,$12,$13,$14,$15,$16,$17,$18,$19,$20,$21,$22,$23;if($8 == "1|0|0")print $1,$2,$3,$4,$5,$6,$7,"0",$9,$10,$11,$12,$13,$14,$15,$16,$17,$18,$19,$20,$21,$22,$23;if($8 == "0|1|0")print $1,$2,$3,$4,$5,$6,$7,"0",$9,$10,$11,$12,$13,$14,$15,$16,$17,$18,$19,$20,$21,$22,$23;if($8 == "0|0|1")print $1,$2,$3,$4,$5,$6,$7,"0",$9,$10,$11,$12,$13,$14,$15,$16,$17,$18,$19,$20,$21,$22,$23;if($8 == "0|1|1")print $1,$2,$3,$4,$5,$6,$7,"1",$9,$10,$11,$12,$13,$14,$15,$16,$17,$18,$19,$20,$21,$22,$23;if($8 == "1|1|0")print $1,$2,$3,$4,$5,$6,$7,"1",$9,$10,$11,$12,$13,$14,$15,$16,$17,$18,$19,$20,$21,$22,$23;if($8 == "1|0|1")print $1,$2,$3,$4,$5,$6,$7,"1",$9,$10,$11,$12,$13,$14,$15,$16,$17,$18,$19,$20,$21,$22,$23;if($8 == "1|1|1")print $1,$2,$3,$4,$5,$6,$7,"1",$9,$10,$11,$12,$13,$14,$15,$16,$17,$18,$19,$20,$21,$22,$23;}' OFS='\t' | awk '{if($9 == "0|0|0|0")print $1,$2,$3,$4,$5,$6,$7,$8,"0",$10,$11,$12,$13,$14,$15,$16,$17,$18,$19,$20,$21,$22,$23;if($9 == "1|0|0|0")print $1,$2,$3,$4,$5,$6,$7,$8,"0",$10,$11,$12,$13,$14,$15,$16,$17,$18,$19,$20,$21,$22,$23;if($9 == "0|1|0|0")print $1,$2,$3,$4,$5,$6,$7,$8,"0",$10,$11,$12,$13,$14,$15,$16,$17,$18,$19,$20,$21,$22,$23;if($9 == "0|0|1|0")print $1,$2,$3,$4,$5,$6,$7,$8,"0",$10,$11,$12,$13,$14,$15,$16,$17,$18,$19,$20,$21,$22,$23;if($9 == "0|0|0|1")print $1,$2,$3,$4,$5,$6,$7,$8,"0",$10,$11,$12,$13,$14,$15,$16,$17,$18,$19,$20,$21,$22,$23;if($9 == "1|0|0|1")print $1,$2,$3,$4,$5,$6,$7,$8,"1",$10,$11,$12,$13,$14,$15,$16,$17,$18,$19,$20,$21,$22,$23;if($9 == "1|1|0|0")print $1,$2,$3,$4,$5,$6,$7,$8,"1",$10,$11,$12,$13,$14,$15,$16,$17,$18,$19,$20,$21,$22,$23;if($9 == "0|1|1|0")print $1,$2,$3,$4,$5,$6,$7,$8,"1",$10,$11,$12,$13,$14,$15,$16,$17,$18,$19,$20,$21,$22,$23;if($9 == "0|0|1|1")print $1,$2,$3,$4,$5,$6,$7,$8,"1",$10,$11,$12,$13,$14,$15,$16,$17,$18,$19,$20,$21,$22,$23;if($9 == "0|1|0|1")print $1,$2,$3,$4,$5,$6,$7,$8,"1",$10,$11,$12,$13,$14,$15,$16,$17,$18,$19,$20,$21,$22,$23;if($9 == "1|0|1|0")print $1,$2,$3,$4,$5,$6,$7,$8,"1",$10,$11,$12,$13,$14,$15,$16,$17,$18,$19,$20,$21,$22,$23;if($9 == "1|1|1|0")print $1,$2,$3,$4,$5,$6,$7,$8,"1",$10,$11,$12,$13,$14,$15,$16,$17,$18,$19,$20,$21,$22,$23;if($9 == "0|1|1|1")print $1,$2,$3,$4,$5,$6,$7,$8,"1",$10,$11,$12,$13,$14,$15,$16,$17,$18,$19,$20,$21,$22,$23;if($9 == "1|1|0|1")print $1,$2,$3,$4,$5,$6,$7,$8,"1",$10,$11,$12,$13,$14,$15,$16,$17,$18,$19,$20,$21,$22,$23;if($9 == "1|0|1|1")print $1,$2,$3,$4,$5,$6,$7,$8,"1",$10,$11,$12,$13,$14,$15,$16,$17,$18,$19,$20,$21,$22,$23;if($9 == "1|1|1|1")print $1,$2,$3,$4,$5,$6,$7,$8,"1",$10,$11,$12,$13,$14,$15,$16,$17,$18,$19,$20,$21,$22,$23;}' OFS='\t' | awk '{if($10 == "0|0|0")print $1,$2,$3,$4,$5,$6,$7,$8,$9,"0",$11,$12,$13,$14,$15,$16,$17,$18,$19,$20,$21,$22,$23;if($10 == "1|0|0")print $1,$2,$3,$4,$5,$6,$7,$8,$9,"0",$11,$12,$13,$14,$15,$16,$17,$18,$19,$20,$21,$22,$23;if($10 == "0|1|0")print $1,$2,$3,$4,$5,$6,$7,$8,$9,"0",$11,$12,$13,$14,$15,$16,$17,$18,$19,$20,$21,$22,$23;if($10 == "0|0|1")print $1,$2,$3,$4,$5,$6,$7,$8,$9,"0",$11,$12,$13,$14,$15,$16,$17,$18,$19,$20,$21,$22,$23;if($10 == "0|1|1")print $1,$2,$3,$4,$5,$6,$7,$8,$9,"1",$11,$12,$13,$14,$15,$16,$17,$18,$19,$20,$21,$22,$23;if($10 == "1|1|0")print $1,$2,$3,$4,$5,$6,$7,$8,$9,"1",$11,$12,$13,$14,$15,$16,$17,$18,$19,$20,$21,$22,$23;if($10 == "1|0|1")print $1,$2,$3,$4,$5,$6,$7,$8,$9,"1",$11,$12,$13,$14,$15,$16,$17,$18,$19,$20,$21,$22,$23;if($10 == "1|1|1")print $1,$2,$3,$4,$5,$6,$7,$8,$9,"1",$11,$12,$13,$14,$15,$16,$17,$18,$19,$20,$21,$22,$23;}' OFS='\t' | awk '{if($11 == "0|0")print $1,$2,$3,$4,$5,$6,$7,$8,$9,$10,"0",$12,$13,$14,$15,$16,$17,$18,$19,$20,$21,$22,$23;else print $1,$2,$3,$4,$5,$6,$7,$8,$9,$10,"1",$12,$13,$14,$15,$16,$17,$18,$19,$20,$21,$22,$23;}' OFS='\t' | awk '{if($12 == "0|0")print $1,$2,$3,$4,$5,$6,$7,$8,$9,$10,$11,"0",$13,$14,$15,$16,$17,$18,$19,$20,$21,$22,$23;else print $1,$2,$3,$4,$5,$6,$7,$8,$9,$10,$11,"1",$13,$14,$15,$16,$17,$18,$19,$20,$21,$22,$23;}' OFS='\t' | awk '{if($13 == "0|0")print $1,$2,$3,$4,$5,$6,$7,$8,$9,$10,$11,$12,"0",$14,$15,$16,$17,$18,$19,$20,$21,$22,$23;else print $1,$2,$3,$4,$5,$6,$7,$8,$9,$10,$11,$12,"1",$14,$15,$16,$17,$18,$19,$20,$21,$22,$23;}' OFS='\t' | awk '{if($14 == "0|0")print $1,$2,$3,$4,$5,$6,$7,$8,$9,$10,$11,$12,$13,"0",$15,$16,$17,$18,$19,$20,$21,$22,$23;else print $1,$2,$3,$4,$5,$6,$7,$8,$9,$10,$11,$12,$13,"1",$15,$16,$17,$18,$19,$20,$21,$22,$23;}' OFS='\t' | awk '{if($15 == "0|0")print $1,$2,$3,$4,$5,$6,$7,$8,$9,$10,$11,$12,$13,$14,"0",$16,$17,$18,$19,$20,$21,$22,$23;else print $1,$2,$3,$4,$5,$6,$7,$8,$9,$10,$11,$12,$13,$14,"1",$16,$17,$18,$19,$20,$21,$22,$23;}' OFS='\t' | awk '{if($16 == "0|0")print $1,$2,$3,$4,$5,$6,$7,$8,$9,$10,$11,$12,$13,$14,$15,"0",$17,$18,$19,$20,$21,$22,$23;else print $1,$2,$3,$4,$5,$6,$7,$8,$9,$10,$11,$12,$13,$14,$15,"1",$17,$18,$19,$20,$21,$22,$23;}' OFS='\t' | awk '{if($17 == "0|0")print $1,$2,$3,$4,$5,$6,$7,$8,$9,$10,$11,$12,$13,$14,$15,$16,"0",$18,$19,$20,$21,$22,$23;else print $1,$2,$3,$4,$5,$6,$7,$8,$9,$10,$11,$12,$13,$14,$15,$16,"1",$18,$19,$20,$21,$22,$23;}' OFS='\t' | awk '{if($18 == "0|0")print $1,$2,$3,$4,$5,$6,$7,$8,$9,$10,$11,$12,$13,$14,$15,$16,$17,"0",$19,$20,$21,$22,$23;else print $1,$2,$3,$4,$5,$6,$7,$8,$9,$10,$11,$12,$13,$14,$15,$16,$17,"1",$19,$20,$21,$22,$23;}' OFS='\t' | awk '{if($19 == "0|0|0")print $1,$2,$3,$4,$5,$6,$7,$8,$9,$10,$11,$12,$13,$14,$15,$16,$17,$18,"0",$20,$21,$22,$23;if($19 == "1|0|0")print $1,$2,$3,$4,$5,$6,$7,$8,$9,$10,$11,$12,$13,$14,$15,$16,$17,$18,"0",$20,$21,$22,$23;if($19 == "0|1|0")print $1,$2,$3,$4,$5,$6,$7,$8,$9,$10,$11,$12,$13,$14,$15,$16,$17,$18,"0",$20,$21,$22,$23;if($19 == "0|0|1")print $1,$2,$3,$4,$5,$6,$7,$8,$9,$10,$11,$12,$13,$14,$15,$16,$17,$18,"0",$20,$21,$22,$23;if($19 == "0|1|1")print $1,$2,$3,$4,$5,$6,$7,$8,$9,$10,$11,$12,$13,$14,$15,$16,$17,$18,"1",$20,$21,$22,$23;if($19 == "1|1|0")print $1,$2,$3,$4,$5,$6,$7,$8,$9,$10,$11,$12,$13,$14,$15,$16,$17,$18,"1",$20,$21,$22,$23;if($19 == "1|0|1")print $1,$2,$3,$4,$5,$6,$7,$8,$9,$10,$11,$12,$13,$14,$15,$16,$17,$18,"1",$20,$21,$22,$23;if($19 == "1|1|1")print $1,$2,$3,$4,$5,$6,$7,$8,$9,$10,$11,$12,$13,$14,$15,$16,$17,$18,"1",$20,$21,$22,$23;}' OFS='\t' | awk '{if($20 == "0|0|0")print $1,$2,$3,$4,$5,$6,$7,$8,$9,$10,$11,$12,$13,$14,$15,$16,$17,$18,$19,"0",$21,$22,$23;if($20 == "1|0|0")print $1,$2,$3,$4,$5,$6,$7,$8,$9,$10,$11,$12,$13,$14,$15,$16,$17,$18,$19,"0",$21,$22,$23;if($20 == "0|1|0")print $1,$2,$3,$4,$5,$6,$7,$8,$9,$10,$11,$12,$13,$14,$15,$16,$17,$18,$19,"0",$21,$22,$23;if($20 == "0|0|1")print $1,$2,$3,$4,$5,$6,$7,$8,$9,$10,$11,$12,$13,$14,$15,$16,$17,$18,$19,"0",$21,$22,$23;if($20 == "0|1|1")print $1,$2,$3,$4,$5,$6,$7,$8,$9,$10,$11,$12,$13,$14,$15,$16,$17,$18,$19,"1",$21,$22,$23;if($20 == "1|1|0")print $1,$2,$3,$4,$5,$6,$7,$8,$9,$10,$11,$12,$13,$14,$15,$16,$17,$18,$19,"1",$21,$22,$23;if($20 == "1|0|1")print $1,$2,$3,$4,$5,$6,$7,$8,$9,$10,$11,$12,$13,$14,$15,$16,$17,$18,$19,"1",$21,$22,$23;if($20 == "1|1|1")print $1,$2,$3,$4,$5,$6,$7,$8,$9,$10,$11,$12,$13,$14,$15,$16,$17,$18,$19,"1",$21,$22,$23;}' OFS='\t' | awk '{if($21 == "0|0|0")print $1,$2,$3,$4,$5,$6,$7,$8,$9,$10,$11,$12,$13,$14,$15,$16,$17,$18,$19,$20,"0",$22,$23;if($21 == "1|0|0")print $1,$2,$3,$4,$5,$6,$7,$8,$9,$10,$11,$12,$13,$14,$15,$16,$17,$18,$19,$20,"0",$22,$23;if($21 == "0|1|0")print $1,$2,$3,$4,$5,$6,$7,$8,$9,$10,$11,$12,$13,$14,$15,$16,$17,$18,$19,$20,"0",$22,$23;if($21 == "0|0|1")print $1,$2,$3,$4,$5,$6,$7,$8,$9,$10,$11,$12,$13,$14,$15,$16,$17,$18,$19,$20,"0",$22,$23;if($21 == "0|1|1")print $1,$2,$3,$4,$5,$6,$7,$8,$9,$10,$11,$12,$13,$14,$15,$16,$17,$18,$19,$20,"1",$22,$23;if($21 == "1|1|0")print $1,$2,$3,$4,$5,$6,$7,$8,$9,$10,$11,$12,$13,$14,$15,$16,$17,$18,$19,$20,"1",$22,$23;if($21 == "1|0|1")print $1,$2,$3,$4,$5,$6,$7,$8,$9,$10,$11,$12,$13,$14,$15,$16,$17,$18,$19,$20,"1",$22,$23;if($21 == "1|1|1")print $1,$2,$3,$4,$5,$6,$7,$8,$9,$10,$11,$12,$13,$14,$15,$16,$17,$18,$19,$20,"1",$22,$23;}' OFS='\t' | awk '{if($22 == "0|0|0")print $1,$2,$3,$4,$5,$6,$7,$8,$9,$10,$11,$12,$13,$14,$15,$16,$17,$18,$19,$20,$21,"0",$23;if($22 == "1|0|0")print $1,$2,$3,$4,$5,$6,$7,$8,$9,$10,$11,$12,$13,$14,$15,$16,$17,$18,$19,$20,$21,"0",$23;if($22 == "0|1|0")print $1,$2,$3,$4,$5,$6,$7,$8,$9,$10,$11,$12,$13,$14,$15,$16,$17,$18,$19,$20,$21,"0",$23;if($22 == "0|0|1")print $1,$2,$3,$4,$5,$6,$7,$8,$9,$10,$11,$12,$13,$14,$15,$16,$17,$18,$19,$20,$21,"0",$23;if($22 == "0|1|1")print $1,$2,$3,$4,$5,$6,$7,$8,$9,$10,$11,$12,$13,$14,$15,$16,$17,$18,$19,$20,$21,"1",$23;if($22 == "1|1|0")print $1,$2,$3,$4,$5,$6,$7,$8,$9,$10,$11,$12,$13,$14,$15,$16,$17,$18,$19,$20,$21,"1",$23;if($22 == "1|0|1")print $1,$2,$3,$4,$5,$6,$7,$8,$9,$10,$11,$12,$13,$14,$15,$16,$17,$18,$19,$20,$21,"1",$23;if($22 == "1|1|1")print $1,$2,$3,$4,$5,$6,$7,$8,$9,$10,$11,$12,$13,$14,$15,$16,$17,$18,$19,$20,$21,"1",$23;}' OFS='\t' | awk '{if($23 == "0|0|0")print $1,$2,$3,$4,$5,$6,$7,$8,$9,$10,$11,$12,$13,$14,$15,$16,$17,$18,$19,$20,$21,$22,"0";if($23 == "1|0|0")print $1,$2,$3,$4,$5,$6,$7,$8,$9,$10,$11,$12,$13,$14,$15,$16,$17,$18,$19,$20,$21,$22,"0";if($23 == "0|1|0")print $1,$2,$3,$4,$5,$6,$7,$8,$9,$10,$11,$12,$13,$14,$15,$16,$17,$18,$19,$20,$21,$22,"0";if($23 == "0|0|1")print $1,$2,$3,$4,$5,$6,$7,$8,$9,$10,$11,$12,$13,$14,$15,$16,$17,$18,$19,$20,$21,$22,"0";if($23 == "0|1|1")print $1,$2,$3,$4,$5,$6,$7,$8,$9,$10,$11,$12,$13,$14,$15,$16,$17,$18,$19,$20,$21,$22,"1";if($23 == "1|1|0")print $1,$2,$3,$4,$5,$6,$7,$8,$9,$10,$11,$12,$13,$14,$15,$16,$17,$18,$19,$20,$21,$22,"1";if($23 == "1|0|1")print $1,$2,$3,$4,$5,$6,$7,$8,$9,$10,$11,$12,$13,$14,$15,$16,$17,$18,$19,$20,$21,$22,"1";if($23 == "1|1|1")print $1,$2,$3,$4,$5,$6,$7,$8,$9,$10,$11,$12,$13,$14,$15,$16,$17,$18,$19,$20,$21,$22,"1";}' OFS='\t' > ${i}.tmp
  cat MzPnAbNbOn_BELT_G_ATAC_header ${i}.tmp | awk '{print $1,$2,$3,$4,$5,$6,$7,$10,$8,$9,$11,$12,$13,$14,$15,$16,$17,$18,$19,$20,$22,$23,$21}' OFS='\t' > "$(basename "${i}" 4.txt)5.txt"
  rm ${i}.tmp
done

#### INTERMEDIATE (BASIC) PRESENCE-ABSENCE MATRIX FILES
# MzPnAbNbOn_BELT_G_ATAC_{True,False}IDR_PAmat_1.txt # 38,445 - total number of orthogroups/genes with peaks mapped in the five cichlid species
# MzPnAbNbOn_BELT_G_ATAC_{True,False}IDR_PAmat_2.txt # 13,997 - total number of 1-to-1 orthogroups/genes with peaks mapped in the five cichlid species
# MzPnAbNbOn_BELT_G_ATAC_{True,False}IDR_PAmat_3.txt # 13,618 (True) and 11,740 (False) - total number of orthogroups/genes with open chromatin peaks mapped and mapped IDR (T or F) peaks that are present in at least two replicates of each species tissue
# MzPnAbNbOn_BELT_G_ATAC_{True,False}IDR_PAmat_4.txt # 13,618 (True) and 11,740 (False) - simplified (collated '|' separated replicates), total number of orthogroups/genes with mapped IDR (T or F) peaks that are present in at least two replicates of each species tissue
# MzPnAbNbOn_BELT_G_ATAC_{True,False}IDR_PAmat_5.txt # 13,618 (True) and 11,740 (False) - simplified final (no replicates), total number of orthogroups/genes with mapped IDR (T or F) peaks that are present in at least two replicates of each species tissue

# get total numbers of unique 1-to-1 orthogroups/genes with peaks mapped in the five cichlid species
cat MzPnAbNbOn_BELT_G_ATAC_{True,False}IDR_PAmat_3.txt | grep -v 'Orthogroup' | cut -f1 | sort -u | wc -l # 13,889/13,997 (99%)

# 		iii. Flag peak summits falling +-100bp from TSS and their presence/absence (and also retain the peakID to cross check with alignments after!)- NOTE: this method is good for parsing ANYTHING from *.orth5 e.g. peak summits, peak lengths etc. to create and add to the matrices
# first, parse the *.orth5 files for orthogroups with peak summits falling +-100bp TSS (use the 'Summit_to_TSS' col - col22). This outputs Orthogroup, Unified_GeneSymbol, Summit_to_TSS and a 1 or 0 for peak +/-100bp (or equal to)
for i in *.orth5; do
  sample=$(echo ${i} | sed 's/_ATAC_peaks.final.narrowPeak.promoverlap.orth5/_peakTSS+-100/g')
  sample2=$(echo ${i} | sed 's/_ATAC_peaks.final.narrowPeak.promoverlap.orth5//g')
  printf "Orthogroup\tUnified_GeneSymbol\t${sample2}_Summit_to_TSS\t$sample\t${sample2}_peakID\n" > ${i}.True
  awk '{if($22!="NULL" && $22<=100 && $22>=-100) print $1,$3,$22,"1",$8; else print $1,$3,$22,"0",$8}' OFS='\t' ${i} | sed '1,1d' >> ${i}.True
  printf "Orthogroup\tUnified_GeneSymbol\t${sample2}_Summit_to_TSS\t$sample\t${sample2}_peakID\n" > ${i}.False
  awk '{if($22!="NULL" && $22<=100 && $22>=-100) print $1,$3,$22,"1",$8; else print $1,$3,$22,"0",$8}' OFS='\t' ${i} | sed '1,1d' >> ${i}.False
done # for loop to generate intermediate matrix files for each sample - one for true IDR and one for false IDR

# for loop over all true and all false files to create the unified matrix - at this point remove the *_Summit_to_TSS column for ease
Tmat2=MzPnAbNbOn_BELT_G_ATAC_TrueIDR_PAmatTSS_1.txt
Fmat2=MzPnAbNbOn_BELT_G_ATAC_FalseIDR_PAmatTSS_1.txt

i=0
cut -f1,2 Ab5_B_ATAC_peaks.final.narrowPeak.promoverlap.orth5.True > delim
for file in {Mz,Pn,Ab,Nb,On}*_*_ATAC_peaks*.True; do
  i=$(($i+1))  ## for adding count to distinguish files from original ones
  cut -f4 $file > ${file}__${i}.temp1
  cut -f5 $file > ${file}__${i}.temp2
done

paste -d'\t' delim {Mz,Pn,Ab,Nb,On}*orth5.True__*.temp1 {Mz,Pn,Ab,Nb,On}*orth5.True__*.temp2 > $Tmat2 # do the join

i=0
for file in {Mz,Pn,Ab,Nb,On}*_*_ATAC_peaks*.False; do
  i=$(($i+1))  ## for adding count to distinguish files from original ones
  cut -f4 $file > ${file}__${i}.temp1
  cut -f5 $file > ${file}__${i}.temp2
done
paste -d'\t' delim {Mz,Pn,Ab,Nb,On}*orth5.False__*.temp1 {Mz,Pn,Ab,Nb,On}*orth5.False__*.temp2 > $Fmat2 # do the join

rm *orth5.True *orth5.False *__*.temp* delim

#     i. Presence and absence of peaks in 1-to-1 (5 sp) orthologs only
awk 'BEGIN{OFS="\t"}NR==FNR{a[$1]=$1;next}{if(a[$1]){print $0,a[$1];}else{print $0,"REMOVEME";}}' $orthENSGS5cich $Tmat2 | grep -v 'REMOVEME' | cut -f1-110 > "$(basename "$Tmat2" 1.txt)2.txt" # 13,997
awk 'BEGIN{OFS="\t"}NR==FNR{a[$1]=$1;next}{if(a[$1]){print $0,a[$1];}else{print $0,"REMOVEME";}}' $orthENSGS5cich $Fmat2 | grep -v 'REMOVEME' | cut -f1-110 > "$(basename "$Fmat2" 1.txt)2.txt" # 13,997

# second, for each species tissue replicates, determine the orthogroups with consistent peak summits falling +-100bp TSS
# filter out for replicates with inconsistent presence or absence e.g. present in one not absent in other replicates, but only needs to be present in at least 2 replicates
## THIS IS WRONG - NOT REQUIRED AS IT CAN BE DETERMINED DIRECTLY FROM THE TABLE - if this is run then it eventaully assigns a NULL for peaks IDs that are present (but not +/-100bpTSS in all replicates), which is WRONG!!
# awk '$3==$7 && $4==$8 && $5==$9 && $6==$10' "$(basename "$Tmat2" 1.txt)2.txt" |
# awk '$11==$14 || $11==$18 || $11==$22 || $14==$18 || $14==$22' |
# awk '$12==$16 || $12==$24 || $16==$24' |
# awk '$13==$17 || $13==$21 || $13==$25 || $17==$21 || $17==$25 || $21==$25' |
# awk '$15==$19 || $15==$23 || $19==$23' |
# awk '$26==$30 && $27==$31 && $28==$32 && $29==$33 && $34==$38 && $35==$39 && $36==$40 && $37==$41' |
# awk '$42==$47 || $42==$52 || $47==$52' |
# awk '$43==$48 || $43==$53 || $48==$53' |
# awk '$44==$49 || $44==$54 || $49==$54' |
# awk '$45==$50 || $45==$55 || $50==$55' |
# awk '$46==$51 || $46==$56 || $51==$56' > "$(basename "$Tmat2" 1.txt)3.txt" # 4074
#
# awk '$3==$7 && $4==$8 && $5==$9 && $6==$10' "$(basename "$Fmat2" 1.txt)2.txt" |
# awk '$11==$14 || $11==$18 || $11==$22 || $14==$18 || $14==$22' |
# awk '$12==$16 || $12==$24 || $16==$24' |
# awk '$13==$17 || $13==$21 || $13==$25 || $17==$21 || $17==$25 || $21==$25' |
# awk '$15==$19 || $15==$23 || $19==$23' |
# awk '$26==$30 && $27==$31 && $28==$32 && $29==$33 && $34==$38 && $35==$39 && $36==$40 && $37==$41' |
# awk '$42==$47 || $42==$52 || $47==$52' |
# awk '$43==$48 || $43==$53 || $48==$53' |
# awk '$44==$49 || $44==$54 || $49==$54' |
# awk '$45==$50 || $45==$55 || $50==$55' |
# awk '$46==$51 || $46==$56 || $51==$56' > "$(basename "$Fmat2" 1.txt)3.txt" # 4074
#
# head -1 $Tmat2 > MzPnAbNbOn_BELT_G_ATAC_TSSheader.txt
# for i in MzPnAbNbOn_BELT_G_ATAC_{True,False}IDR_PAmatTSS_3.txt; do
#   cat MzPnAbNbOn_BELT_G_ATAC_TSSheader.txt $i > ${i}.tmp
#   rm ${i}
#   mv ${i}.tmp ${i}
# done
#
# for i in MzPnAbNbOn_BELT_G_ATAC_{True,False}IDR_PAmatTSS_2.txt; do
#   sed '1,1d' $i > ${i}.tmp
#   rm ${i}
#   mv ${i}.tmp ${i}
# done
#
# # Create a general presence and absence of peaks in genes according to tissue and species - don't create a unified one using the crazy awk script so that you can see if maybe one peak is near a TSS and identify which simply
# for i in MzPnAbNbOn_BELT_G_ATAC_*IDR_PAmatTSS_3.txt; do
#   awk '{print $1,$2,$3"|"$7,$4"|"$8,$5"|"$9,$6"|"$10,$11"|"$14"|"$18"|"$22,$12"|"$16"|"$24,$13"|"$17"|"$21"|"$25,$15"|"$19"|"$23,$26"|"$30,$27"|"$31,$28"|"$32,$29"|"$33,$34"|"$38,$35"|"$39,$36"|"$40,$37"|"$41,$42"|"$47"|"$52,$43"|"$48"|"$53,$44"|"$49"|"$54,$45"|"$50"|"$55,$46"|"$51"|"$56,$57"|"$61,$58"|"$62,$59"|"$63,$60"|"$64,$65"|"$68"|"$72"|"$76,$66"|"$70"|"$78,$67"|"$71"|"$75"|"$79,$69"|"$73"|"$77,$80"|"$84,$81"|"$85,$82"|"$86,$83"|"$87,$88"|"$92,$89"|"$93,$90"|"$94,$91"|"$95,$96"|"$101"|"$106,$97"|"$102"|"$107,$98"|"$103"|"$108,$99"|"$104"|"$109,$100"|"$105"|"$110}' OFS='\t' ${i} > "$(basename "${i}" 3.txt)4.txt"
# done
#
# # third (and finally), map the orthogroups (for each species tissue) that have consistent peak summits falling +-100bp TSS, otherwise, show as NULLs > MzPnAbNbOn_BELT_G_ATAC_{True,False}IDR_PAmat_6.txt
# awk 'BEGIN{OFS="\t"}NR==FNR{a[$1]=$0;next}{if(a[$1]){print $0,a[$1];}else{print $0,"NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL";}}' "$(basename "${Tmat2}" 1.txt)4.txt" "$(basename "${Tmat}" 1.txt)5.txt" | cut -f1-23,26-68 > "$(basename "${Tmat}" 1.txt)6.txt"
# awk 'BEGIN{OFS="\t"}NR==FNR{a[$1]=$0;next}{if(a[$1]){print $0,a[$1];}else{print $0,"NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL";}}' "$(basename "${Fmat2}" 1.txt)4.txt" "$(basename "${Fmat}" 1.txt)5.txt" | cut -f1-23,26-68 > "$(basename "${Fmat}" 1.txt)6.txt"
#

# Create a general presence and absence of peaks in genes according to tissue and species - don't create a unified one using the crazy awk script so that you can see if maybe one peak is near a TSS and identify which simply
for i in MzPnAbNbOn_BELT_G_ATAC_*IDR_PAmatTSS_2.txt; do
  awk '{print $1,$2,$3"|"$7,$4"|"$8,$5"|"$9,$6"|"$10,$11"|"$14"|"$18"|"$22,$12"|"$16"|"$24,$13"|"$17"|"$21"|"$25,$15"|"$19"|"$23,$26"|"$30,$27"|"$31,$28"|"$32,$29"|"$33,$34"|"$38,$35"|"$39,$36"|"$40,$37"|"$41,$42"|"$47"|"$52,$43"|"$48"|"$53,$44"|"$49"|"$54,$45"|"$50"|"$55,$46"|"$51"|"$56,$57"|"$61,$58"|"$62,$59"|"$63,$60"|"$64,$65"|"$68"|"$72"|"$76,$66"|"$70"|"$78,$67"|"$71"|"$75"|"$79,$69"|"$73"|"$77,$80"|"$84,$81"|"$85,$82"|"$86,$83"|"$87,$88"|"$92,$89"|"$93,$90"|"$94,$91"|"$95,$96"|"$101"|"$106,$97"|"$102"|"$107,$98"|"$103"|"$108,$99"|"$104"|"$109,$100"|"$105"|"$110}' OFS='\t' ${i} > "$(basename "${i}" 2.txt)3NEW.txt"
done

# third (and finally), map the orthogroups (for each species tissue) that have consistent peak summits falling +-100bp TSS, otherwise, show as NULLs > MzPnAbNbOn_BELT_G_ATAC_{True,False}IDR_PAmat_6.txt
awk 'BEGIN{OFS="\t"}NR==FNR{a[$1]=$0;next}{if(a[$1]){print $0,a[$1];}else{print $0,"NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL";}}' "$(basename "${Tmat2}" 1.txt)3NEW.txt" "$(basename "${Tmat}" 1.txt)5.txt" | cut -f1-23,26-68 > "$(basename "${Tmat}" 1.txt)6.txt"
awk 'BEGIN{OFS="\t"}NR==FNR{a[$1]=$0;next}{if(a[$1]){print $0,a[$1];}else{print $0,"NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL";}}' "$(basename "${Fmat2}" 1.txt)3NEW.txt" "$(basename "${Fmat}" 1.txt)5.txt" | cut -f1-23,26-68 > "$(basename "${Fmat}" 1.txt)6.txt"

#### FINAL (BASIC) PRESENCE-ABSENCE MATRIX FILE
# /ei/projects/9/9e238063-c905-4076-a975-f7c7f85dbd56/scratch/ATACseq/3.run2/4.Peak_Orth/MzPnAbNbOn_BELT_G_ATAC_{True,False}IDR_PAmat_6.txt # 3005 (True) and 1923 (False) - simplified final (no replicates), total number of orthogroups/genes with mapped IDR (T or F) peaks and peak summits falling +-100bp TSS that are present in at least two replicates of each species tissue (with the peak IDs shown for mapping back to original files)


# C. Are the peaks preserved - use the alignment. If it's crap then run a local alignment for pairs (but will still need a multiple alignment!)

cd $peakorth # /ei/projects/9/9e238063-c905-4076-a975-f7c7f85dbd56/scratch/ATACseq/3.run2/4.Peak_Orth/

# i. create a readable format of the MAF file
# MAF original format
# The "s" lines together with the "a" lines define a multiple alignment.
#     src -- The name of one of the source sequences for the alignment. For sequences that are resident in a browser assembly, the form 'database.chromosome' allows automatic creation of links to other assemblies. Non-browser sequences are typically reference by the species name alone.
#     start -- The start of the aligning region in the source sequence. This is a zero-based number. If the strand field is "-" then this is the start relative to the reverse-complemented source sequence (see Coordinate Transforms).
#     size -- The size of the aligning region in the source sequence. This number is equal to the number of non-dash characters in the alignment text field below.
#     strand -- Either "+" or "-". If "-", then the alignment is to the reverse-complemented source.
#     srcSize -- The size of the entire source sequence, not just the parts involved in the alignment.
#     text -- The nucleotides (or amino acids) in the alignment and any insertions (dashes) as well.

# Parse the MAF file to show
# 1. species full name
# 2. species short name (Mz,Ac,Pn,Ab,Nb,On)
# 3. alignment id e.g. a1, a2 ..aN - for each 'a' block, add a counting number
# 4. chr
# 5. chr length
# 6. start
# 7. end
# 8. length of alignment
# 9. strand
# 10. nucleotide sequence

maf=(/ei/projects/9/9e238063-c905-4076-a975-f7c7f85dbd56/data/ATACseq/6sp_cactus_MGA/out/MzAcPnAbNb_OnRef_Cactus_amend.maf)
mafsummary=(/ei/projects/9/9e238063-c905-4076-a975-f7c7f85dbd56/scratch/ATACseq/3.run2/4.Peak_Orth/MzAcPnAbNb_OnRef_Cactus_amend.maf.summary)

printf 'sp\tsp_id\talign_id\tchr\tchr_length\tstart\tend\talign_length\tstrand\talign_seq\n' > $mafsummary # create the header and add to it below

awk '/^a/ { $0=$0 "" ++i }1' $maf | # this adds a counter number to the 'a' line for each alignment
awk 'BEGIN{OFS="\t"} /^a/ {h=$0; next} {print h, $0}' | # this then adds the alignment counter as a column to each proceeding row
awk '{if($3~ /^Oreochromis_niloticus/){print "On",$0;}if($3~ /^Pundamilia_nyererei/){print "Pn",$0;}if($3~ /^Astatotilapia_calliptera/){print "Ac",$0;}if($3~ /^Metriaclima_zebra/){print "Mz",$0;}if($3~ /^Neolamprologus_brichardi/){print "Nb",$0;}if($3~ /^Astatotilapia_burtoni/){print "Ab",$0;}if($3~ /^Anc0/){print "Anc0",$0;}if($3~ /^Anc1/){print "Anc1",$0;}if($3~ /^Anc2/){print "Anc2",$0;}if($3~ /^Anc3/){print "Anc3",$0;}if($3~ /^Anc4/){print "Anc4",$0;}}' OFS='\t' | # add species short name
awk '{sub(/\./," ")}1' | # split by the first dot in the species name for chr
awk '{print $4,$1,$2,$5,$9,$6,$6+$7,$7,$8,$10}' OFS='\t' >> $mafsummary #DONE

# ii. for each orthogroup in MzPnAbNbOn_BELT_G_ATAC_{True,False}IDR_PAmat_6.txt presence/absence matrices, do the following:

# ii-a. pull out all peak IDs with orthogroup and gene name (in cols 1,2,45-65) in MzPnAbNbOn_BELT_G_ATAC_{True,False}IDR_PAmat_6.txt and get their chr, start and end in *.orth5 (output orth, gene, peakID, chr, start, end, strand, MACS2_integer_score, pval, qval)
# Change the test_TrueIDR_PAmat_6.txt file to have this format - all peakIDs, orthogroup and gene (removing those where NULL exists for peakID)

for i in MzPnAbNbOn_BELT_G_ATAC_TrueIDR_PAmat_6.txt MzPnAbNbOn_BELT_G_ATAC_FalseIDR_PAmat_6.txt; do
  cut -f1,2 ${i} > "$(basename "${i}" .txt).tmp1" # get the orthogroups and genes only
  cut -f45-65 ${i} | sed $'s/\t/|/g' > "$(basename "${i}" .txt).tmp2" # get the peaksIDs and separate all with '|' (so contain all into one column)
  paste -d'\t' "$(basename "${i}" .txt).tmp1" "$(basename "${i}" .txt).tmp2" | sed '1,1d' | awk '{n = split($3,x,"|"); for (i = 1; i <= n; ++i) {printf "%s\t%s\t%s\n", x[i], $1, $2 }}' | awk '$1!="NULL"' > "$(basename "${i}" .txt).tmp" # paste together, remove the header, awk script to turn each peakID in '|' column (col3) to a row with orthogroup and gene symbol
  rm "$(basename "${i}" .txt).tmp1" "$(basename "${i}" .txt).tmp2"
done

# cat all the *.orth5 files (removing headers)
DEST=collated.orth5

echo "" | sed '1,1d' >$DEST
for i in *.promoverlap.orth5
do
    sed -e'1d' $i >>$DEST
done

# awk match command (on peakIDs) to output (orth, spID (short name), gene, ensemblID, peakID, chr, start, end, MACS2_integer_score, pval, qval,IDR,Prom_start,Summit_to_TSS)
for i in MzPnAbNbOn_BELT_G_ATAC_TrueIDR_PAmat_6.tmp MzPnAbNbOn_BELT_G_ATAC_FalseIDR_PAmat_6.tmp; do
  awk 'BEGIN{OFS="\t"}NR==FNR{a[$8]=$0;next}{if(a[$1]){print $0,a[$1];}else{print $0,"NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL";}}' $DEST ${i} | awk '{print $2,$1,$3,$5,$1,$8,$9,$10,$12,$15,$16,$18,$23,$25}' OFS='\t' | awk '{ sub(/_.*$/, "", $2); print }' OFS='\t' | awk '{ sub(/[0-9=%]/, "", $2); print }' OFS='\t' | awk '{ sub(/Pnm/,"Pn", $2); print }' OFS='\t' > "$(basename "${i}" _6.tmp)_7.txt"
done


# ii-b. then check whether the peak coordinates overlap (in any way, even 1bp) with the corresponding species in MAF, and assign the peakID (and other deets) to it (NULL if not)
# for this, amend the chr to be sp_id'_'chr in both files, rearranging to bed format: sp_id'_'chr; start; end; other cols

nano 0.mafintersect.sh

#!/bin/bash -e
#SBATCH -p ei-medium # partition (queue)
#SBATCH -N 1 # number of nodes
#SBATCH -n 1 # number of tasks
#SBATCH --mem 88000
#SBATCH -t 0-01:59
#SBATCH --mail-type=ALL # notifications for job done & fail
#SBATCH --mail-user=Tarang.Mehta@earlham.ac.uk # send-to address
#SBATCH -o slurm.%N.%j.out # STDOUT
#SBATCH -e slurm.%N.%j.err # STDERR

mafsummary=(/ei/projects/9/9e238063-c905-4076-a975-f7c7f85dbd56/scratch/ATACseq/3.run2/4.Peak_Orth/MzAcPnAbNb_OnRef_Cactus_amend.maf.summary)

ml bedtools/2.25.0

awk '{print $2"_"$4,$6,$7,$0}' OFS='\t' $mafsummary | sort -k1,1 -k2,2n | sed -e '$ d' > $mafsummary.tmp # amend the chr col to reflect spID too and sort for intersect, then remove the last line that will be the header

for i in MzPnAbNbOn_BELT_G_ATAC_*IDR_PAmat_7.txt; do
  awk '{print $2"_"$6,$7,$8,$0}' OFS='\t' ${i} | sort -k1,1 -k2,2n > ${i}.tmp # amend the chr col to reflect spID too and sort for intersect
  bedtools intersect -a ${i}.tmp -b $mafsummary.tmp -wao > "$(basename "${i}" _7.txt)_8.txt" # intersect the maf and the present/absent peaks
done

# run the above
sbatch 0.mafintersect.sh

cut -f8 MzPnAbNbOn_BELT_G_ATAC_FalseIDR_PAmat_7.txt.tmp | sort -u | wc -l # Check if all peaks retained: 21321
cut -f8 MzPnAbNbOn_BELT_G_ATAC_FalseIDR_PAmat_8.txt | sort -u | wc -l # Checked: 21321 - all peaks have been retained
rm MzPnAbNbOn_BELT_G_ATAC_*IDR_PAmat_7.txt.tmp $mafsummary.tmp

###### Above ran successfuly and the two outputs MzPnAbNbOn_BELT_G_ATAC_*IDR_PAmat_8.txt need to be parsed

cd $peakorth # /ei/projects/9/9e238063-c905-4076-a975-f7c7f85dbd56/scratch/ATACseq/3.run2/4.Peak_Orth/

# For the parsing you need to
# 1. split MzPnAbNbOn_BELT_G_ATAC_*IDR_PAmat_8.txt by species and create a unified col4[orthogroup]_col23[align_ID]
for i in Mz Pn Ab Nb On; do
  awk -v var="$i" '$5==var' MzPnAbNbOn_BELT_G_ATAC_FalseIDR_PAmat_8.txt | awk '{print $4"_"$23,$0}' OFS='\t' > MzPnAbNbOn_BELT_G_ATAC_FalseIDR_PAmat_8_${i}.txt
  awk -v var="$i" '$5==var' MzPnAbNbOn_BELT_G_ATAC_TrueIDR_PAmat_8.txt | awk '{print $4"_"$23,$0}' OFS='\t' > MzPnAbNbOn_BELT_G_ATAC_TrueIDR_PAmat_8_${i}.txt
done

# 2. for every species pairwise combination, awk match the unified col4[orthogroup]_col23[align_ID] column, retaining non-matches with relevant number (total of 32) of NAs
# create a file with all pairwise comps and do a while loop
# NOTE: this will create duplicate lines but in a different order - this will be rectified in the next step
printf 'On\tMz\n' > sp_pair
printf 'Nb\tMz\n' >> sp_pair
printf 'Ab\tMz\n' >> sp_pair
printf 'Pn\tMz\n' >> sp_pair
printf 'On\tPn\n' >> sp_pair
printf 'Nb\tPn\n' >> sp_pair
printf 'Ab\tPn\n' >> sp_pair
printf 'Mz\tPn\n' >> sp_pair
printf 'On\tAb\n' >> sp_pair
printf 'Nb\tAb\n' >> sp_pair
printf 'Pn\tAb\n' >> sp_pair
printf 'Mz\tAb\n' >> sp_pair
printf 'On\tNb\n' >> sp_pair
printf 'Ab\tNb\n' >> sp_pair
printf 'Pn\tNb\n' >> sp_pair
printf 'Mz\tNb\n' >> sp_pair
printf 'Nb\tOn\n' >> sp_pair
printf 'Ab\tOn\n' >> sp_pair
printf 'Pn\tOn\n' >> sp_pair
printf 'Mz\tOn\n' >> sp_pair

while read -r c r; do
  awk 'BEGIN{OFS="\t"}NR==FNR{a[$1]=$0;next}{if(a[$1]){print $0,a[$1];}else{print $0,"NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL";}}' MzPnAbNbOn_BELT_G_ATAC_TrueIDR_PAmat_8_${c}.txt MzPnAbNbOn_BELT_G_ATAC_TrueIDR_PAmat_8_${r}.txt | sort -V -k1,1 > MzPnAbNbOn_BELT_G_ATAC_TrueIDR_PAmat_8_${r}${c}.txt
  awk 'BEGIN{OFS="\t"}NR==FNR{a[$1]=$0;next}{if(a[$1]){print $0,a[$1];}else{print $0,"NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL";}}' MzPnAbNbOn_BELT_G_ATAC_FalseIDR_PAmat_8_${c}.txt MzPnAbNbOn_BELT_G_ATAC_FalseIDR_PAmat_8_${r}.txt | sort -V -k1,1 > MzPnAbNbOn_BELT_G_ATAC_FalseIDR_PAmat_8_${r}${c}.txt
done < sp_pair

# get the stats on peaks that overlap based on MAF
for i in MzPnAbNbOn_BELT_G_ATAC_TrueIDR_PAmat_8_Mz*.txt MzPnAbNbOn_BELT_G_ATAC_TrueIDR_PAmat_8_Pn*.txt MzPnAbNbOn_BELT_G_ATAC_TrueIDR_PAmat_8_Ab*.txt MzPnAbNbOn_BELT_G_ATAC_TrueIDR_PAmat_8_Nb*.txt MzPnAbNbOn_BELT_G_ATAC_TrueIDR_PAmat_8_On*.txt; do
  total=$(wc -l ${i} | awk '{print $1}')
  map=$(grep -v NULL ${i} | wc -l)
  perc=$(perl -E "say ${map}/${total}*100")
  comp=$(echo ${i} | sed 's|MzPnAbNbOn_BELT_G_ATAC_TrueIDR_PAmat_8_||g' | sed 's|.txt||g')
  echo -e ${comp}'\t'${map}'\t'${total}'\t'${perc}
done

# MzAb	47707	387697	12.3052280518033
# MzNb	50249	387697	12.9608947193298
# MzOn	105700	387697	27.2635589132751
# MzPn	54426	387697	14.0382824731685
# PnAb	71808	525038	13.6767243513803
# PnMz	78636	525038	14.9772016501663
# PnNb	77671	525038	14.7934054297022
# PnOn	165991	525038	31.6150450062662
# AbMz	38713	278109	13.9200816945874
# AbNb	38328	278109	13.7816467643981
# AbOn	84706	278109	30.4578420691168
# AbPn	40894	278109	14.7043065848283
# NbAb	38750	326897	11.8538866982566
# NbMz	41782	326897	12.7813959748789
# NbOn	95248	326897	29.1370064576916
# NbPn	44736	326897	13.685044524728
# OnAb	171335	797200	21.4920973406924
# OnMz	176540	797200	22.1450075263422
# OnNb	189532	797200	23.7747114902158
# OnPn	191709	797200	24.0477922729553


for i in MzPnAbNbOn_BELT_G_ATAC_FalseIDR_PAmat_8_Mz*.txt MzPnAbNbOn_BELT_G_ATAC_FalseIDR_PAmat_8_Pn*.txt MzPnAbNbOn_BELT_G_ATAC_FalseIDR_PAmat_8_Ab*.txt MzPnAbNbOn_BELT_G_ATAC_FalseIDR_PAmat_8_Nb*.txt MzPnAbNbOn_BELT_G_ATAC_FalseIDR_PAmat_8_On*.txt; do
  total=$(wc -l ${i} | awk '{print $1}')
  map=$(grep -v NULL ${i} | wc -l)
  perc=$(perl -E "say ${map}/${total}*100")
  comp=$(echo ${i} | sed 's|MzPnAbNbOn_BELT_G_ATAC_FalseIDR_PAmat_8_||g' | sed 's|.txt||g')
  echo -e ${comp}'\t'${map}'\t'${total}'\t'${perc}
done

# MzAb	38492	318978	12.0672899071409
# MzNb	41675	318978	13.0651643687025
# MzOn	84710	318978	26.556690430061
# MzPn	44274	318978	13.8799541034178
# PnAb	60521	432185	14.0034938741511
# PnMz	63831	432185	14.7693695986672
# PnNb	64150	432185	14.8431805823895
# PnOn	134336	432185	31.0829852956489
# AbMz	31507	232838	13.5317259210266
# AbNb	32597	232838	13.9998625653888
# AbOn	69495	232838	29.8469322017884
# AbPn	34699	232838	14.9026361676359
# NbAb	32906	284360	11.5719510479674
# NbMz	35087	284360	12.338936559291
# NbOn	79062	284360	27.803488535659
# NbPn	37415	284360	13.1576171050781
# OnAb	138016	642349	21.4861391548831
# OnMz	139664	642349	21.7426975055616
# OnNb	154330	642349	24.0258800122675
# OnPn	153869	642349	23.9541121726663

# 3. join files, column-wise, based on the unified col4[orthogroup]_col23[align_ID] column to create a single file - sort the column groups by species (Mz,Pn,Ab,Nb,On) and then remove duplicated lines (sort -u)

# 3i. since the same ref species files are ordered the same (based on 1st col), cut out for every species to delete redundant ref cols

for i in MzPn PnMz AbMz NbMz OnMz; do
  cut -f1-32 MzPnAbNbOn_BELT_G_ATAC_TrueIDR_PAmat_8_${i}.txt > MzPnAbNbOn_BELT_G_ATAC_TrueIDR_PAmat_8_${i}_REFcut.txt
  cut -f1-32 MzPnAbNbOn_BELT_G_ATAC_FalseIDR_PAmat_8_${i}.txt > MzPnAbNbOn_BELT_G_ATAC_FalseIDR_PAmat_8_${i}_REFcut.txt
done

for i in MzPn MzAb MzNb MzOn PnMz PnAb PnNb PnOn AbMz AbPn AbNb AbOn NbMz NbPn NbAb NbOn OnMz OnPn OnAb OnNb; do
  cut -f33-64 MzPnAbNbOn_BELT_G_ATAC_TrueIDR_PAmat_8_${i}.txt > MzPnAbNbOn_BELT_G_ATAC_TrueIDR_PAmat_8_${i}_cut.txt
  cut -f33-64 MzPnAbNbOn_BELT_G_ATAC_FalseIDR_PAmat_8_${i}.txt > MzPnAbNbOn_BELT_G_ATAC_FalseIDR_PAmat_8_${i}_cut.txt
done

# 3ii. paste together the cut files with the main ref file but do this in the order of MzPnAbNbOn for all (to sort -u in next step) - 32 cols for each species, so 160 in total
paste -d'\t' MzPnAbNbOn_BELT_G_ATAC_TrueIDR_PAmat_8_MzPn_REFcut.txt MzPnAbNbOn_BELT_G_ATAC_TrueIDR_PAmat_8_MzPn_cut.txt MzPnAbNbOn_BELT_G_ATAC_TrueIDR_PAmat_8_MzAb_cut.txt MzPnAbNbOn_BELT_G_ATAC_TrueIDR_PAmat_8_MzNb_cut.txt MzPnAbNbOn_BELT_G_ATAC_TrueIDR_PAmat_8_MzOn_cut.txt > MzPnAbNbOn_BELT_G_ATAC_TrueIDR_PAmat_8_MzPnAbNbOn.txt
paste -d'\t' MzPnAbNbOn_BELT_G_ATAC_FalseIDR_PAmat_8_MzPn_REFcut.txt MzPnAbNbOn_BELT_G_ATAC_FalseIDR_PAmat_8_MzPn_cut.txt MzPnAbNbOn_BELT_G_ATAC_FalseIDR_PAmat_8_MzAb_cut.txt MzPnAbNbOn_BELT_G_ATAC_FalseIDR_PAmat_8_MzNb_cut.txt MzPnAbNbOn_BELT_G_ATAC_FalseIDR_PAmat_8_MzOn_cut.txt > MzPnAbNbOn_BELT_G_ATAC_FalseIDR_PAmat_8_MzPnAbNbOn.txt

paste -d'\t' MzPnAbNbOn_BELT_G_ATAC_TrueIDR_PAmat_8_PnMz_cut.txt MzPnAbNbOn_BELT_G_ATAC_TrueIDR_PAmat_8_PnMz_REFcut.txt MzPnAbNbOn_BELT_G_ATAC_TrueIDR_PAmat_8_PnAb_cut.txt MzPnAbNbOn_BELT_G_ATAC_TrueIDR_PAmat_8_PnNb_cut.txt MzPnAbNbOn_BELT_G_ATAC_TrueIDR_PAmat_8_PnOn_cut.txt > MzPnAbNbOn_BELT_G_ATAC_TrueIDR_PAmat_8_PnMzAbNbOn.txt
paste -d'\t' MzPnAbNbOn_BELT_G_ATAC_FalseIDR_PAmat_8_PnMz_cut.txt MzPnAbNbOn_BELT_G_ATAC_FalseIDR_PAmat_8_PnMz_REFcut.txt MzPnAbNbOn_BELT_G_ATAC_FalseIDR_PAmat_8_PnAb_cut.txt MzPnAbNbOn_BELT_G_ATAC_FalseIDR_PAmat_8_PnNb_cut.txt MzPnAbNbOn_BELT_G_ATAC_FalseIDR_PAmat_8_PnOn_cut.txt > MzPnAbNbOn_BELT_G_ATAC_FalseIDR_PAmat_8_PnMzAbNbOn.txt

paste -d'\t' MzPnAbNbOn_BELT_G_ATAC_TrueIDR_PAmat_8_AbMz_cut.txt MzPnAbNbOn_BELT_G_ATAC_TrueIDR_PAmat_8_AbPn_cut.txt MzPnAbNbOn_BELT_G_ATAC_TrueIDR_PAmat_8_AbMz_REFcut.txt MzPnAbNbOn_BELT_G_ATAC_TrueIDR_PAmat_8_AbNb_cut.txt MzPnAbNbOn_BELT_G_ATAC_TrueIDR_PAmat_8_AbOn_cut.txt > MzPnAbNbOn_BELT_G_ATAC_TrueIDR_PAmat_8_AbMzPnNbOn.txt
paste -d'\t' MzPnAbNbOn_BELT_G_ATAC_FalseIDR_PAmat_8_AbMz_cut.txt MzPnAbNbOn_BELT_G_ATAC_FalseIDR_PAmat_8_AbPn_cut.txt MzPnAbNbOn_BELT_G_ATAC_FalseIDR_PAmat_8_AbMz_REFcut.txt MzPnAbNbOn_BELT_G_ATAC_FalseIDR_PAmat_8_AbNb_cut.txt MzPnAbNbOn_BELT_G_ATAC_FalseIDR_PAmat_8_AbOn_cut.txt > MzPnAbNbOn_BELT_G_ATAC_FalseIDR_PAmat_8_AbMzPnNbOn.txt

paste -d'\t' MzPnAbNbOn_BELT_G_ATAC_TrueIDR_PAmat_8_NbMz_cut.txt MzPnAbNbOn_BELT_G_ATAC_TrueIDR_PAmat_8_NbPn_cut.txt MzPnAbNbOn_BELT_G_ATAC_TrueIDR_PAmat_8_NbAb_cut.txt MzPnAbNbOn_BELT_G_ATAC_TrueIDR_PAmat_8_NbMz_REFcut.txt MzPnAbNbOn_BELT_G_ATAC_TrueIDR_PAmat_8_NbOn_cut.txt > MzPnAbNbOn_BELT_G_ATAC_TrueIDR_PAmat_8_NbMzPnAbOn.txt
paste -d'\t' MzPnAbNbOn_BELT_G_ATAC_FalseIDR_PAmat_8_NbMz_cut.txt MzPnAbNbOn_BELT_G_ATAC_FalseIDR_PAmat_8_NbPn_cut.txt MzPnAbNbOn_BELT_G_ATAC_FalseIDR_PAmat_8_NbAb_cut.txt MzPnAbNbOn_BELT_G_ATAC_FalseIDR_PAmat_8_NbMz_REFcut.txt MzPnAbNbOn_BELT_G_ATAC_FalseIDR_PAmat_8_NbOn_cut.txt > MzPnAbNbOn_BELT_G_ATAC_FalseIDR_PAmat_8_NbMzPnAbOn.txt

paste -d'\t' MzPnAbNbOn_BELT_G_ATAC_TrueIDR_PAmat_8_OnMz_cut.txt MzPnAbNbOn_BELT_G_ATAC_TrueIDR_PAmat_8_OnPn_cut.txt MzPnAbNbOn_BELT_G_ATAC_TrueIDR_PAmat_8_OnAb_cut.txt MzPnAbNbOn_BELT_G_ATAC_TrueIDR_PAmat_8_OnNb_cut.txt MzPnAbNbOn_BELT_G_ATAC_TrueIDR_PAmat_8_OnMz_REFcut.txt > MzPnAbNbOn_BELT_G_ATAC_TrueIDR_PAmat_8_OnMzPnAbNb.txt
paste -d'\t' MzPnAbNbOn_BELT_G_ATAC_FalseIDR_PAmat_8_OnMz_cut.txt MzPnAbNbOn_BELT_G_ATAC_FalseIDR_PAmat_8_OnPn_cut.txt MzPnAbNbOn_BELT_G_ATAC_FalseIDR_PAmat_8_OnAb_cut.txt MzPnAbNbOn_BELT_G_ATAC_FalseIDR_PAmat_8_OnNb_cut.txt MzPnAbNbOn_BELT_G_ATAC_FalseIDR_PAmat_8_OnMz_REFcut.txt > MzPnAbNbOn_BELT_G_ATAC_FalseIDR_PAmat_8_OnMzPnAbNb.txt

# 3iii. cat all the single species files and sort -u
for i in True False; do
  cat MzPnAbNbOn_BELT_G_ATAC_${i}IDR_PAmat_8_MzPnAbNbOn.txt MzPnAbNbOn_BELT_G_ATAC_${i}IDR_PAmat_8_PnMzAbNbOn.txt MzPnAbNbOn_BELT_G_ATAC_${i}IDR_PAmat_8_AbMzPnNbOn.txt MzPnAbNbOn_BELT_G_ATAC_${i}IDR_PAmat_8_NbMzPnAbOn.txt MzPnAbNbOn_BELT_G_ATAC_${i}IDR_PAmat_8_OnMzPnAbNb.txt | sort -u | sort -V -k1,1 > MzPnAbNbOn_BELT_G_ATAC_${i}IDR_PAmat_8_MzPnAbNbOn_collated.txt
done
# cat MzPnAbNbOn_BELT_G_ATAC_TrueIDR_PAmat_8_MzPnAbNbOn.txt MzPnAbNbOn_BELT_G_ATAC_TrueIDR_PAmat_8_PnMzAbNbOn.txt MzPnAbNbOn_BELT_G_ATAC_TrueIDR_PAmat_8_AbMzPnNbOn.txt MzPnAbNbOn_BELT_G_ATAC_TrueIDR_PAmat_8_NbMzPnAbOn.txt MzPnAbNbOn_BELT_G_ATAC_TrueIDR_PAmat_8_OnMzPnAbNb.txt | wc -l # 2314941
# wc -l MzPnAbNbOn_BELT_G_ATAC_TrueIDR_PAmat_8_MzPnAbNbOn_collated.txt # 2170754/2314941


# this gives the following general header for EACH species
# orth_alignmentid, sp_chr, peak_start, peak_end, peak_closestorth, spID, peak_closestgene, ensemblID, peakID, peak_chr, peak_start, peak_end, MACS2_integer_score, MACS2_pval, MACS2_qval, IDR, Prom_start, Summit_to_TSS, sp_chr, MAFalign_start, MAFalign_end, sp_full, spID, MAF_alignment_id, MAF_chr, MAF_chr_length, MAF_align_start, MAF_align_end, MAF_align_length, MAF_align_strand, MAF_align_ntseq, bedtlsint_peak_MAFalign_overlap
#
# OMA00160_a5038274	Mz_LG12	23123717	23125143
# # orth_alignmentid, sp_chr, peak_start, peak_end
#
# OMA00160	Mz	dmxl1	ENSMZEG00005008659	Mz2_E_ATAC_peak_47010f	LG12	23123717	23125143	43	4.39883	2.81157	T	23127736	2726
# # orth, spID (short name), gene, ensemblID, peakID, chr, start, end, MACS2_integer_score, pval, qval,IDR,Prom_start,Summit_to_TSS
#
# Mz_LG12	23123667	23123854
# # sp_chr, MAFalign_start, MAFalign_end
#
# Metriaclima_zebra	Mz	a5038274	LG12	34086040	23123667	23123854	187	+	AAAACAGTATTTCACCTTTGTGTATTTGGCAGCGAAGTAAATTCAATACAAGGAGTCCATTAATCAAAAGGGTGCAGGGAATTTGTACGGAGGGTTAAATGGATCACCGGTGCAGGTTACACCTTACTGTAACCCTACGAGCCCGGTTAATCAACTTATCATACAATCAAGGGCTGAACAGTCT--GAA	137
# # 1. species full name
# # 2. species short name (Mz,Ac,Pn,Ab,Nb,On)
# # 3. alignment id e.g. a1, a2 ..aN - for each 'a' block, add a counting number
# # 4. chr
# # 5. chr length
# # 6. start
# # 7. end
# # 8. length of alignment
# # 9. strand
# # 10. nucleotide sequence
# # 11. bedtlsint_peak_MAFalign_overlap

# 4. add a header to the two (True and False IDR) files above, ensuring one is 'Orthogroup' for awk matching below - 'Orthogroup' is col5

# printf 'orth_alignmentid\tsp_chr\tpeak_start\tpeak_end\tOrthogroup\tspID\tpeak_closestgene\tensemblID\tpeakID\tpeak_chr\tpeak_start\tpeak_end\tMACS2_integer_score\tMACS2_pval\tMACS2_qval\tIDR\tProm_start\tSummit_to_TSS\tsp_chr\tMAFalign_start\tMAFalign_end\tsp_full\tspID\tMAF_alignment_id\tMAF_chr\tMAF_chr_length\tMAF_align_start\tMAF_align_end\tMAF_align_length\tMAF_align_strand\tMAF_align_ntseq\tbedtlsint_peak_MAFalign_overlap\torth_alignmentid\tsp_chr\tpeak_start\tpeak_end\tOrthogroup\tspID\tpeak_closestgene\tensemblID\tpeakID\tpeak_chr\tpeak_start\tpeak_end\tMACS2_integer_score\tMACS2_pval\tMACS2_qval\tIDR\tProm_start\tSummit_to_TSS\tsp_chr\tMAFalign_start\tMAFalign_end\tsp_full\tspID\tMAF_alignment_id\tMAF_chr\tMAF_chr_length\tMAF_align_start\tMAF_align_end\tMAF_align_length\tMAF_align_strand\tMAF_align_ntseq\tbedtlsint_peak_MAFalign_overlap\torth_alignmentid\tsp_chr\tpeak_start\tpeak_end\tpeak_closestorth\tspID\tpeak_closestgene\tensemblID\tpeakID\tpeak_chr\tpeak_start\tpeak_end\tMACS2_integer_score\tMACS2_pval\tMACS2_qval\tIDR\tProm_start\tSummit_to_TSS\tsp_chr\tMAFalign_start\tMAFalign_end\tsp_full\tspID\tMAF_alignment_id\tMAF_chr\tMAF_chr_length\tMAF_align_start\tMAF_align_end\tMAF_align_length\tMAF_align_strand\tMAF_align_ntseq\tbedtlsint_peak_MAFalign_overlap\torth_alignmentid\tsp_chr\tpeak_start\tpeak_end\tpeak_closestorth\tspID\tpeak_closestgene\tensemblID\tpeakID\tpeak_chr\tpeak_start\tpeak_end\tMACS2_integer_score\tMACS2_pval\tMACS2_qval\tIDR\tProm_start\tSummit_to_TSS\tsp_chr\tMAFalign_start\tMAFalign_end\tsp_full\tspID\tMAF_alignment_id\tMAF_chr\tMAF_chr_length\tMAF_align_start\tMAF_align_end\tMAF_align_length\tMAF_align_strand\tMAF_align_ntseq\tbedtlsint_peak_MAFalign_overlap\torth_alignmentid\tsp_chr\tpeak_start\tpeak_end\tpeak_closestorth\tspID\tpeak_closestgene\tensemblID\tpeakID\tpeak_chr\tpeak_start\tpeak_end\tMACS2_integer_score\tMACS2_pval\tMACS2_qval\tIDR\tProm_start\tSummit_to_TSS\tsp_chr\tMAFalign_start\tMAFalign_end\tsp_full\tspID\tMAF_alignment_id\tMAF_chr\tMAF_chr_length\tMAF_align_start\tMAF_align_end\tMAF_align_length\tMAF_align_strand\tMAF_align_ntseq\tbedtlsint_peak_MAFalign_overlap\n' > peak_MAF_header.txt

printf 'orth_alignmentid_Mz\tsp_chr_Mz\tpeak_start_Mz\tpeak_end_Mz\tOrthogroup\tspID_Mz\tpeak_closestgene_Mz\tensemblID_Mz\tpeakID_Mz\tpeak_chr_Mz\tpeak_start_Mz\tpeak_end_Mz\tMACS2_integer_score_Mz\tMACS2_pval_Mz\tMACS2_qval_Mz\tIDR_Mz\tProm_start_Mz\tSummit_to_TSS_Mz\tsp_chr_Mz\tMAFalign_start_Mz\tMAFalign_end_Mz\tsp_full_Mz\tspID_Mz\tMAF_alignment_id_Mz\tMAF_chr_Mz\tMAF_chr_length_Mz\tMAF_align_start_Mz\tMAF_align_end_Mz\tMAF_align_length_Mz\tMAF_align_strand_Mz\tMAF_align_ntseq_Mz\tbedtlsint_peak_MAFalign_overlap_Mz\torth_alignmentid_Pn\tsp_chr_Pn\tpeak_start_Pn\tpeak_end_Pn\tpeak_closestorth_Pn\tspID_Pn\tpeak_closestgene_Pn\tensemblID_Pn\tpeakID_Pn\tpeak_chr_Pn\tpeak_start_Pn\tpeak_end_Pn\tMACS2_integer_score_Pn\tMACS2_pval_Pn\tMACS2_qval_Pn\tIDR_Pn\tProm_start_Pn\tSummit_to_TSS_Pn\tsp_chr_Pn\tMAFalign_start_Pn\tMAFalign_end_Pn\tsp_full_Pn\tspID_Pn\tMAF_alignment_id_Pn\tMAF_chr_Pn\tMAF_chr_length_Pn\tMAF_align_start_Pn\tMAF_align_end_Pn\tMAF_align_length_Pn\tMAF_align_strand_Pn\tMAF_align_ntseq_Pn\tbedtlsint_peak_MAFalign_overlap_Pn\torth_alignmentid_Ab\tsp_chr_Ab\tpeak_start_Ab\tpeak_end_Ab\tpeak_closestorth_Ab\tspID_Ab\tpeak_closestgene_Ab\tensemblID_Ab\tpeakID_Ab\tpeak_chr_Ab\tpeak_start_Ab\tpeak_end_Ab\tMACS2_integer_score_Ab\tMACS2_pval_Ab\tMACS2_qval_Ab\tIDR_Ab\tProm_start_Ab\tSummit_to_TSS_Ab\tsp_chr_Ab\tMAFalign_start_Ab\tMAFalign_end_Ab\tsp_full_Ab\tspID_Ab\tMAF_alignment_id_Ab\tMAF_chr_Ab\tMAF_chr_length_Ab\tMAF_align_start_Ab\tMAF_align_end_Ab\tMAF_align_length_Ab\tMAF_align_strand_Ab\tMAF_align_ntseq_Ab\tbedtlsint_peak_MAFalign_overlap_Ab\torth_alignmentid_Nb\tsp_chr_Nb\tpeak_start_Nb\tpeak_end_Nb\tpeak_closestorth_Nb\tspID_Nb\tpeak_closestgene_Nb\tensemblID_Nb\tpeakID_Nb\tpeak_chr_Nb\tpeak_start_Nb\tpeak_end_Nb\tMACS2_integer_score_Nb\tMACS2_pval_Nb\tMACS2_qval_Nb\tIDR_Nb\tProm_start_Nb\tSummit_to_TSS_Nb\tsp_chr_Nb\tMAFalign_start_Nb\tMAFalign_end_Nb\tsp_full_Nb\tspID_Nb\tMAF_alignment_id_Nb\tMAF_chr_Nb\tMAF_chr_length_Nb\tMAF_align_start_Nb\tMAF_align_end_Nb\tMAF_align_length_Nb\tMAF_align_strand_Nb\tMAF_align_ntseq_Nb\tbedtlsint_peak_MAFalign_overlap_Nb\torth_alignmentid_On\tsp_chr_On\tpeak_start_On\tpeak_end_On\tpeak_closestorth_On\tspID_On\tpeak_closestgene_On\tensemblID_On\tpeakID_On\tpeak_chr_On\tpeak_start_On\tpeak_end_On\tMACS2_integer_score_On\tMACS2_pval_On\tMACS2_qval_On\tIDR_On\tProm_start_On\tSummit_to_TSS_On\tsp_chr_On\tMAFalign_start_On\tMAFalign_end_On\tsp_full_On\tspID_On\tMAF_alignment_id_On\tMAF_chr_On\tMAF_chr_length_On\tMAF_align_start_On\tMAF_align_end_On\tMAF_align_length_On\tMAF_align_strand_On\tMAF_align_ntseq_On\tbedtlsint_peak_MAFalign_overlap_On\n' > peak_MAF_header.txt

cat peak_MAF_header.txt MzPnAbNbOn_BELT_G_ATAC_TrueIDR_PAmat_8_MzPnAbNbOn_collated.txt > MzPnAbNbOn_BELT_G_ATAC_TrueIDR_PAmat_8_MzPnAbNbOn_collated.txt.tmp; rm MzPnAbNbOn_BELT_G_ATAC_TrueIDR_PAmat_8_MzPnAbNbOn_collated.txt; mv MzPnAbNbOn_BELT_G_ATAC_TrueIDR_PAmat_8_MzPnAbNbOn_collated.txt.tmp MzPnAbNbOn_BELT_G_ATAC_TrueIDR_PAmat_8_MzPnAbNbOn_collated.txt
cat peak_MAF_header.txt MzPnAbNbOn_BELT_G_ATAC_FalseIDR_PAmat_8_MzPnAbNbOn_collated.txt > MzPnAbNbOn_BELT_G_ATAC_FalseIDR_PAmat_8_MzPnAbNbOn_collated.txt.tmp; rm MzPnAbNbOn_BELT_G_ATAC_FalseIDR_PAmat_8_MzPnAbNbOn_collated.txt; mv MzPnAbNbOn_BELT_G_ATAC_FalseIDR_PAmat_8_MzPnAbNbOn_collated.txt.tmp MzPnAbNbOn_BELT_G_ATAC_FalseIDR_PAmat_8_MzPnAbNbOn_collated.txt


# 5. Check for coherence of the orthologous peak IDs e.g. Mz1_L_ATAC_peak_278484 in MzPnAbNbOn_BELT_G_ATAC_{True,False}IDR_PAmat_6.txt and those assigned to ortholgous alignment blocks in the file above
  # i. accordingly, flag as MAFalign_False (when matched to MzPnAbNbOn_BELT_G_ATAC_{True,False}IDR_PAmat_6.txt) if there is no hit
  # ii. NOTE: it is unlikely that every orthologous peak will have coherence (between orthologous peaks based on the orthogroup and MAF alignment), so showing the MAFalignment line even if one of the peaks is coherent e.g. Mz2_E_ATAC_peak_111182e and On1_T_ATAC_peak_117727g have MAF align but the line is: Mz1_L_ATAC_peak_171854d|Mz2_L_ATAC_peak_154357d Mz1_T_ATAC_peak_200603c|Mz2_T_ATAC_peak_185879d Pnm1_B_ATAC_peak_59845d|Pnm2_B_ATAC_peak_53189d|Pnm3_B_ATAC_peak_67241b|Pnm4_B_ATAC_peak_60789  Pnm1_L_ATAC_peak_119933d|Pnm2_L_ATAC_peak_65974b|Pnm4_L_ATAC_peak_88266a        Pnm1_T_ATAC_peak_75953d|Pnm2_T_ATAC_peak_91582b|Pnm3_T_ATAC_peak_94498d|Pnm4_T_ATAC_peak_59314d Pnm2_E_ATAC_peak_94126d|Pnm3_E_ATAC_peak_39712b|Pnm4_E_ATAC_peak_88812e Ab5_B_ATAC_peak_108174d|Ab6_B_ATAC_peak_30651c  NULL|Ab6_E_ATAC_peak_212023     Ab5_L_ATAC_peak_243325d|Ab6_L_ATAC_peak_148116d Ab5_T_ATAC_peak_202942c|Ab6_T_ATAC_peak_224267e NULL|NULL       NULL|NULL       NULL|NULL       NULL|NULL
       # On1_B_ATAC_peak_126898d|On2_B_ATAC_peak_124619e|On3_B_ATAC_peak_132366f On1_E_ATAC_peak_198937b|On2_E_ATAC_peak_153467b|On3_E_ATAC_peak_196430c On1_G_ATAC_peak_239020b|On2_G_ATAC_peak_288219d|On3_G_ATAC_peak_218333a On1_L_ATAC_peak_174856d|On2_L_ATAC_peak_161192e|On3_L_ATAC_peak_138846d On1_T_ATAC_peak_117727g|On2_T_ATAC_peak_151844d|On3_T_ATAC_peak_179992c
# 6. Output two final files (True and False IDR) of presence and absence, plus coherence with multiple alignments, ensuring you have headers

# awk 'BEGIN{OFS="\t"}NR==FNR{a[$5]=$0;next}{if(a[$1]){print $0,a[$1];}else{print $0,"MAFalign_False";}}' MzPnAbNbOn_BELT_G_ATAC_TrueIDR_PAmat_8_MzPnAbNbOn_collated.txt MzPnAbNbOn_BELT_G_ATAC_TrueIDR_PAmat_6.txt | grep -v 'MAFalign_False' | wc -l # 626/3006 orthologous peaks have MAF alignment (but need to check if peaks are coherent)
awk 'BEGIN{OFS="\t"}NR==FNR{a[$5]=$0;next}{if(a[$1]){print $0,a[$1];}else{print $0,"MAFalign_False","MAFalign_False","MAFalign_False","MAFalign_False","MAFalign_False","MAFalign_False","MAFalign_False","MAFalign_False","MAFalign_False","MAFalign_False","MAFalign_False","MAFalign_False","MAFalign_False","MAFalign_False","MAFalign_False","MAFalign_False","MAFalign_False","MAFalign_False","MAFalign_False","MAFalign_False","MAFalign_False","MAFalign_False","MAFalign_False","MAFalign_False","MAFalign_False","MAFalign_False","MAFalign_False","MAFalign_False","MAFalign_False","MAFalign_False","MAFalign_False","MAFalign_False","MAFalign_False","MAFalign_False","MAFalign_False","MAFalign_False","MAFalign_False","MAFalign_False","MAFalign_False","MAFalign_False","MAFalign_False","MAFalign_False","MAFalign_False","MAFalign_False","MAFalign_False","MAFalign_False","MAFalign_False","MAFalign_False","MAFalign_False","MAFalign_False","MAFalign_False","MAFalign_False","MAFalign_False","MAFalign_False","MAFalign_False","MAFalign_False","MAFalign_False","MAFalign_False","MAFalign_False","MAFalign_False","MAFalign_False","MAFalign_False","MAFalign_False","MAFalign_False","MAFalign_False","MAFalign_False","MAFalign_False","MAFalign_False","MAFalign_False","MAFalign_False","MAFalign_False","MAFalign_False","MAFalign_False","MAFalign_False","MAFalign_False","MAFalign_False","MAFalign_False","MAFalign_False","MAFalign_False","MAFalign_False","MAFalign_False","MAFalign_False","MAFalign_False","MAFalign_False","MAFalign_False","MAFalign_False","MAFalign_False","MAFalign_False","MAFalign_False","MAFalign_False","MAFalign_False","MAFalign_False","MAFalign_False","MAFalign_False","MAFalign_False","MAFalign_False","MAFalign_False","MAFalign_False","MAFalign_False","MAFalign_False","MAFalign_False","MAFalign_False","MAFalign_False","MAFalign_False","MAFalign_False","MAFalign_False","MAFalign_False","MAFalign_False","MAFalign_False","MAFalign_False","MAFalign_False","MAFalign_False","MAFalign_False","MAFalign_False","MAFalign_False","MAFalign_False","MAFalign_False","MAFalign_False","MAFalign_False","MAFalign_False","MAFalign_False","MAFalign_False","MAFalign_False","MAFalign_False","MAFalign_False","MAFalign_False","MAFalign_False","MAFalign_False","MAFalign_False","MAFalign_False","MAFalign_False","MAFalign_False","MAFalign_False","MAFalign_False","MAFalign_False","MAFalign_False","MAFalign_False","MAFalign_False","MAFalign_False","MAFalign_False","MAFalign_False","MAFalign_False","MAFalign_False","MAFalign_False","MAFalign_False","MAFalign_False","MAFalign_False","MAFalign_False","MAFalign_False","MAFalign_False","MAFalign_False","MAFalign_False","MAFalign_False","MAFalign_False","MAFalign_False","MAFalign_False","MAFalign_False","MAFalign_False","MAFalign_False","MAFalign_False";}}' MzPnAbNbOn_BELT_G_ATAC_TrueIDR_PAmat_8_MzPnAbNbOn_collated.txt MzPnAbNbOn_BELT_G_ATAC_TrueIDR_PAmat_6.txt > MzPnAbNbOn_BELT_G_ATAC_TrueIDR_PAmat_MAFalign.orthpeaksFINAL.txt
awk 'BEGIN{OFS="\t"}NR==FNR{a[$5]=$0;next}{if(a[$1]){print $0,a[$1];}else{print $0,"MAFalign_False","MAFalign_False","MAFalign_False","MAFalign_False","MAFalign_False","MAFalign_False","MAFalign_False","MAFalign_False","MAFalign_False","MAFalign_False","MAFalign_False","MAFalign_False","MAFalign_False","MAFalign_False","MAFalign_False","MAFalign_False","MAFalign_False","MAFalign_False","MAFalign_False","MAFalign_False","MAFalign_False","MAFalign_False","MAFalign_False","MAFalign_False","MAFalign_False","MAFalign_False","MAFalign_False","MAFalign_False","MAFalign_False","MAFalign_False","MAFalign_False","MAFalign_False","MAFalign_False","MAFalign_False","MAFalign_False","MAFalign_False","MAFalign_False","MAFalign_False","MAFalign_False","MAFalign_False","MAFalign_False","MAFalign_False","MAFalign_False","MAFalign_False","MAFalign_False","MAFalign_False","MAFalign_False","MAFalign_False","MAFalign_False","MAFalign_False","MAFalign_False","MAFalign_False","MAFalign_False","MAFalign_False","MAFalign_False","MAFalign_False","MAFalign_False","MAFalign_False","MAFalign_False","MAFalign_False","MAFalign_False","MAFalign_False","MAFalign_False","MAFalign_False","MAFalign_False","MAFalign_False","MAFalign_False","MAFalign_False","MAFalign_False","MAFalign_False","MAFalign_False","MAFalign_False","MAFalign_False","MAFalign_False","MAFalign_False","MAFalign_False","MAFalign_False","MAFalign_False","MAFalign_False","MAFalign_False","MAFalign_False","MAFalign_False","MAFalign_False","MAFalign_False","MAFalign_False","MAFalign_False","MAFalign_False","MAFalign_False","MAFalign_False","MAFalign_False","MAFalign_False","MAFalign_False","MAFalign_False","MAFalign_False","MAFalign_False","MAFalign_False","MAFalign_False","MAFalign_False","MAFalign_False","MAFalign_False","MAFalign_False","MAFalign_False","MAFalign_False","MAFalign_False","MAFalign_False","MAFalign_False","MAFalign_False","MAFalign_False","MAFalign_False","MAFalign_False","MAFalign_False","MAFalign_False","MAFalign_False","MAFalign_False","MAFalign_False","MAFalign_False","MAFalign_False","MAFalign_False","MAFalign_False","MAFalign_False","MAFalign_False","MAFalign_False","MAFalign_False","MAFalign_False","MAFalign_False","MAFalign_False","MAFalign_False","MAFalign_False","MAFalign_False","MAFalign_False","MAFalign_False","MAFalign_False","MAFalign_False","MAFalign_False","MAFalign_False","MAFalign_False","MAFalign_False","MAFalign_False","MAFalign_False","MAFalign_False","MAFalign_False","MAFalign_False","MAFalign_False","MAFalign_False","MAFalign_False","MAFalign_False","MAFalign_False","MAFalign_False","MAFalign_False","MAFalign_False","MAFalign_False","MAFalign_False","MAFalign_False","MAFalign_False","MAFalign_False","MAFalign_False","MAFalign_False","MAFalign_False","MAFalign_False","MAFalign_False";}}' MzPnAbNbOn_BELT_G_ATAC_FalseIDR_PAmat_8_MzPnAbNbOn_collated.txt MzPnAbNbOn_BELT_G_ATAC_FalseIDR_PAmat_6.txt > MzPnAbNbOn_BELT_G_ATAC_FalseIDR_PAmat_MAFalign.orthpeaksFINAL.txt

# getting max/min column numbers for each row in a file (to check all is uniform)
awk '{print NF}' MzPnAbNbOn_BELT_G_ATAC_TrueIDR_PAmat_MAFalign.orthpeaksFINAL.txt | sort -nu | head -n 1 # 225
awk '{print NF}' MzPnAbNbOn_BELT_G_ATAC_TrueIDR_PAmat_MAFalign.orthpeaksFINAL.txt | sort -nu | tail -n 1 # 225

awk '{print NF}' MzPnAbNbOn_BELT_G_ATAC_FalseIDR_PAmat_MAFalign.orthpeaksFINAL.txt | sort -nu | head -n 1 # 225
awk '{print NF}' MzPnAbNbOn_BELT_G_ATAC_FalseIDR_PAmat_MAFalign.orthpeaksFINAL.txt | sort -nu | tail -n 1 # 225

awk '{print NF}' MzPnAbNbOn_BELT_G_ATAC_TrueIDR_PAmat_8_MzPnAbNbOn_collated.txt | sort -nu | head -n 1 # 160
awk '{print NF}' MzPnAbNbOn_BELT_G_ATAC_TrueIDR_PAmat_8_MzPnAbNbOn_collated.txt | sort -nu | tail -n 1 # 160
awk '{print NF}' MzPnAbNbOn_BELT_G_ATAC_TrueIDR_PAmat_6.txt | sort -nu | head -n 1 # 65
awk '{print NF}' MzPnAbNbOn_BELT_G_ATAC_TrueIDR_PAmat_6.txt | sort -nu | tail -n 1 # 65
head -1 MzPnAbNbOn_BELT_G_ATAC_TrueIDR_PAmat_6.txt | awk '{print NF}' # 65 - there are 65 headers

awk '{print NF}' MzPnAbNbOn_BELT_G_ATAC_FalseIDR_PAmat_8_MzPnAbNbOn_collated.txt | sort -nu | head -n 1 # 160
awk '{print NF}' MzPnAbNbOn_BELT_G_ATAC_FalseIDR_PAmat_8_MzPnAbNbOn_collated.txt | sort -nu | tail -n 1 # 160
awk '{print NF}' MzPnAbNbOn_BELT_G_ATAC_FalseIDR_PAmat_6.txt | sort -nu | head -n 1 # 65
awk '{print NF}' MzPnAbNbOn_BELT_G_ATAC_FalseIDR_PAmat_6.txt | sort -nu | tail -n 1 # 65
head -1 MzPnAbNbOn_BELT_G_ATAC_FalseIDR_PAmat_6.txt | awk '{print NF}' # 65 - there are 65 headers

##### FINAL ORTHOLOGY FILES - ORTHOLOGOUS PEAKS ACCORDING TO GENE AND THEN THOSE WITH COHERENCE OF MAPPING IN MAF TOO
## TOTAL OF 225 COLUMNS
# /ei/projects/9/9e238063-c905-4076-a975-f7c7f85dbd56/scratch/ATACseq/3.run2/4.Peak_Orth/MzPnAbNbOn_BELT_G_ATAC_TrueIDR_PAmat_MAFalign.orthpeaksFINAL.txt
# /ei/projects/9/9e238063-c905-4076-a975-f7c7f85dbd56/scratch/ATACseq/3.run2/4.Peak_Orth/MzPnAbNbOn_BELT_G_ATAC_FalseIDR_PAmat_MAFalign.orthpeaksFINAL.txt

##### Run PhyloP #####
# phyloP scores measure evolutionary conservation at individual alignment sites. Interpretations of the scores are compared to the evolution that is expected under neutral drift.
# Positive scores — Measure conservation, which is slower evolution than expected, at sites that are predicted to be conserved.
# Negative scores — Measure acceleration, which is faster evolution than expected, at sites that are predicted to be fast-evolving.

# Da. Per base nt conservation score - run PhyloP
# this is ran in script '/Users/mehtat/github/ATAC_bioinformatics/Multiple_genome_alignments_Cactus.sh'
phylop=/ei/projects/9/9e238063-c905-4076-a975-f7c7f85dbd56/data/ATACseq/6sp_cactus_MGA/phylop/6sp_cactus_MGA_OnRef_phyloPscore.data # collated phylop scores, On ref - missing positions are non-aligned
# Note this is using the whole MAF (cactus ran on 6 species) and therefore a per base nt conservation score for all 6 species (On as reference)
# DONE Above (as of 25/11/20)

## BELOW HAS BEEN ADAPTED TO USE PEAKS AS SINGLE FEATURE INPUT FOR PHYLOP (TO OBTAIN ONE SCORE FOR EACH PEAK)

## Db. Running PhyloP on Onil peaks vs all other species:
# best approach is to use an array based on the peaks as features instead
# this will output:
  # chr
  # start
  # end
  # name
  # scale	- this is the altsubscale (we want more than 1 for deviation)
  # lnlratio - this is the likelihood-ratio-test (we want <0.05)
  # pval - this is the CONACC score: +ve is conserved and -ve is accelerated

mkdir -p $phylopdir
cd $phylopdir # /ei/projects/9/9e238063-c905-4076-a975-f7c7f85dbd56/scratch/ATACseq/3.run2/4b.peak_phylop


# A. create the Onil (and other species) peaks feature file (example format below)

# head /ei/projects/9/92817604-7d6f-42a9-b8c4-b9657c1fde33/scratch/FishCNEs/SixSpCNEs/3.phast/Rerun_all_240821/MKQE02000050.1.phylop_pseudoaCNEs.features.gff
# MKQE02000050	phastCons	pseudo_aCNE	5189	5571	0.622780104712042	+	.	MKQE02000050.1.1
# MKQE02000050	phastCons	pseudo_aCNE	7211	7432	0.687054298642534	+	.	MKQE02000050.1.2
# add a col for what feature the peak overlaps

# whilst you're at it, split all peaks (of all species) by annotation and create feature file - 5kb gene promoter, intergenic, intronic, 3’ UTR, and CNEs

# i. create new annotation files for each species, containing:
# intergenic
# CNEs
# 5kb gene promoter
# 5' UTR
# exon
# intron
# 3’ UTR

# Onil annot: below needs CNEs adding - might be worth doing afresh (since running for all species anyway)
# /ei/projects/9/92817604-7d6f-42a9-b8c4-b9657c1fde33/scratch/FishCNEs/SixSpCNEs/3.phast/bedtools/ONilo_gff_Corrected_PostWilfried_PostTarang_Intergenic_Regions.bed.30bp_filtered.sorted

refgenensemblcich=(/ei/projects/1/14165957-4403-4f46-94c5-dadb0ec866ec/data/ensembl/cichlids)

gtfmzeb=$refgenensemblcich/Mzebra/current_gtf/maylandia_zebra/Maylandia_zebra.M_zebra_UMD2a.100.gtf.gz
gtfpnye=$refgenensemblcich/Pnyererei_v1.0/current_gtf/pundamilia_nyererei/Pundamilia_nyererei.PunNye1.0.100.gtf.gz
gtfabur=$refgenensemblcich/Aburtoni/current_gtf/haplochromis_burtoni/Haplochromis_burtoni.AstBur1.0.100.gtf.gz
gtfnbri=$refgenensemblcich/Nbrichardi/current_gtf/neolamprologus_brichardi/Neolamprologus_brichardi.NeoBri1.0.100.gtf.gz
gtfacal=$refgenensemblcich/Acalliptera/current_gtf/astatotilapia_calliptera/Astatotilapia_calliptera.fAstCal1.2.100.gtf.gz
gtfonil=$refgenensemblcich/Oniloticus/current_gtf/oreochromis_niloticus/Oreochromis_niloticus.O_niloticus_UMD_NMBU.100.gtf.gz

promannotMz=/ei/projects/9/9e238063-c905-4076-a975-f7c7f85dbd56/data/ATACseq/3.run2/genomes/Mzebra/current_gtf/maylandia_zebra/Maylandia_zebra.M_zebra_UMD2a.101.5kb_promoters.bed
promannotPn=/ei/projects/9/9e238063-c905-4076-a975-f7c7f85dbd56/data/ATACseq/3.run2/genomes/Pnyererei/current_gtf/pundamilia_nyererei/Pundamilia_nyererei.PunNye1.0.101.5kb_promoters.bed
promannotAb=/ei/projects/9/9e238063-c905-4076-a975-f7c7f85dbd56/data/ATACseq/3.run2/genomes/Aburtoni/current_gtf/haplochromis_burtoni/Haplochromis_burtoni.AstBur1.0.101.5kb_promoters.bed
promannotNb=/ei/projects/9/9e238063-c905-4076-a975-f7c7f85dbd56/data/ATACseq/3.run2/genomes/Nbrichardi/current_gtf/neolamprologus_brichardi/Neolamprologus_brichardi.NeoBri1.0.101.5kb_promoters.bed
promannotAc=/ei/projects/9/9e238063-c905-4076-a975-f7c7f85dbd56/data/ATACseq/3.run2/genomes/Acalliptera/current_gtf/astatotilapia_calliptera/Astatotilapia_calliptera.fAstCal1.2.101.5kb_promoters.bed
promannotOn=/ei/projects/9/9e238063-c905-4076-a975-f7c7f85dbd56/data/ATACseq/3.run2/genomes/Oniloticus/current_gtf/oreochromis_niloticus/Oreochromis_niloticus.O_niloticus_UMD_NMBU.101.5kb_promoters.bed

zcat $gtfmzeb | grep -v "^#" | cut -f3 | sort | uniq -c | sort -k1rn
#  384819 exon
#  375438 CDS
#   39681 transcript
#   37664 stop_codon
#   32585 start_codon
#   28622 gene
#   25132 five_prime_utr
#   17712 three_prime_utr
# these contain - exon, CDS, transcript, stop_codon, start_codon, gene, five_prime_utr, three_prime_utr
# we want to retain exon, five_prime_utr, three_prime_utr (including info on gene_id, transcript_id, gene_name, exon_number)
# create a final bed file accordingly - ideally with gene_id and gene_name for intron and 5kb gene promoter

# need to add intergenic, intron, CNEs, 5kb gene promoter
# intergenic will be between CDS (so maybe retain in gtf at first), intron will be between exon.
# 5kb gene promoter will overlap intergenic (as it is still intergenic)
# CNE will overlap intergenic, intron and 5kb gene promoter (as that loci can be both)

# amended bed output format: chrom, start, end, feature, score (as '.'), strand, gene_id, transcript_id, exon_number, gene_name
# files to merge for each sp will be *.map.bed

# So the exonic regions are already defined; however, I would like to remove overlapping exons. The merge utility in BEDTools can accomplish this; however before merging make sure the coordinates are sorted. We can use sortBed to sort the BED file:

source bedtools-2.30.0

# zcat ${gtfmzeb} |
# awk 'BEGIN{OFS="\t"} $3=="exon" {print $1,$4-1,$5,$3,".",$7,$10,$14,$18,$20}' |
# sed 's|"||g' | sed 's|;||g'|
# sort -k1,1 -k2,2n | awk '{print $1"_"$2,$0}' OFS='\t' > $(basename "${gtfmzeb}" .gtf.gz)_exon_pre-merged.bed # since bedtools merge creates a three col output, we need to create a file to map back to (but only use chr_start since merging changes coordinates of end)
#
# zcat ${gtfmzeb} |
# awk 'BEGIN{OFS="\t"} $3=="exon" {print $1,$4-1,$5,$3,".",$7,$10,$14,$18,$20}' |
# sed 's|"||g' | sed 's|;||g'|
# sort -k1,1 -k2,2n |
# bedtools merge -i - | awk '{print $1"_"$2,$0}' OFS='\t' > $(basename "${gtfmzeb}" .gtf.gz)_exon_merged.bed
#
# awk 'BEGIN{OFS="\t"}NR==FNR{a[$1]=$0;next}{if(a[$1]){print $0,a[$1];}else{print $0,"NULL";}}' $(basename "${gtfmzeb}" .gtf.gz)_exon_pre-merged.bed $(basename "${gtfmzeb}" .gtf.gz)_exon_merged.bed | cut -f6-15 > $(basename "${gtfmzeb}" .gtf.gz)_exon_merged.map.bed # map the gene info back - this is the final exon file

for i in "${!gtf@}"; do
  zcat ${!i} |
  awk 'BEGIN{OFS="\t"} $3=="exon" {print $1,$4-1,$5,$3,".",$7,$10,$14,$18,$20}' |
  sed 's|"||g' | sed 's|;||g'|
  sort -k1,1 -k2,2n | awk '{print $1"_"$2,$0}' OFS='\t' > $(basename "${!i}" .gtf.gz)_exon_pre-merged.bed # since bedtools merge creates a three col output, we need to create a file to map back to (but only use chr_start since merging changes coordinates of end)
  zcat ${!i} |
  awk 'BEGIN{OFS="\t"} $3=="exon" {print $1,$4-1,$5,$3,".",$7,$10,$14,$18,$20}' |
  sed 's|"||g' | sed 's|;||g'|
  sort -k1,1 -k2,2n |
  bedtools merge -i - | awk '{print $1"_"$2,$0}' OFS='\t' > $(basename "${!i}" .gtf.gz)_exon_merged.bed
  awk 'BEGIN{OFS="\t"}NR==FNR{a[$1]=$0;next}{if(a[$1]){print $0,a[$1];}else{print $0,"NULL";}}' $(basename "${!i}" .gtf.gz)_exon_pre-merged.bed $(basename "${!i}" .gtf.gz)_exon_merged.bed | cut -f6-15 > $(basename "${!i}" .gtf.gz)_exon_merged.map.bed # map the gene info back - this is the final exon file
done


# iii. process introns
# To define intronic regions, we just need to subtract the exonic region from the genic region.
# bedtools subtract can do this

# zcat ${gtfmzeb} |
# awk 'BEGIN{OFS="\t";} $3=="gene" {print $1,$4-1,$5,$3,".",$7,$10,".",".",$14}' |
# sed 's|"||g' | sed 's|;||g'|
# sort -k1,1 -k2,2n |
# bedtools subtract -a stdin -b $(basename "${gtfmzeb}" .gtf.gz)_exon_merged.map.bed |
# sed 's|gene|intron|g' > $(basename "${gtfmzeb}" .gtf.gz)_intron.map.bed

for i in "${!gtf@}"; do
  zcat ${!i} |
  awk 'BEGIN{OFS="\t";} $3=="gene" {print $1,$4-1,$5,$3,".",$7,$10,".",".",$14}' |
  sed 's|"||g' | sed 's|;||g'|
  sort -k1,1 -k2,2n |
  bedtools subtract -a stdin -b $(basename "${!i}" .gtf.gz)_exon_merged.map.bed |
  sed 's|gene|intron|g' > $(basename "${!i}" .gtf.gz)_intron.map.bed
done

# iv. process intergenic
# define intergenic regions, we use complement to find regions not covered by genes.
# need chromosome sizes for this:
genomemzeb=$refgenensemblcich/Mzebra/dna/Maylandia_zebra.M_zebra_UMD2a.dna.primary_assembly.allLG.and.nonchromosomal.fa
genomepnye=$refgenensemblcich/Pnyererei_v1.0/dna/Pundamilia_nyererei.PunNye1.0.dna.nonchromosomal.fa
genomeabur=$refgenensemblcich/Aburtoni/dna/Haplochromis_burtoni.AstBur1.0.dna.nonchromosomal.fa
genomenbri=$refgenensemblcich/Nbrichardi/dna/Neolamprologus_brichardi.NeoBri1.0.dna.nonchromosomal.fa
genomeacal=$refgenensemblcich/Acalliptera/dna/Astatotilapia_calliptera.fAstCal1.2.dna.primary_assembly.allLG.and.nonchromosomal.fa
genomeonil=$refgenensemblcich/Oniloticus/dna/Oreochromis_niloticus.O_niloticus_UMD_NMBU.dna.primary_assembly.allLG.and.nonchromosomal.fa

source bioawk-1.0
for i in "${!genome@}"; do
  #echo "${!i}"
  bioawk -c fastx '{ print $name, length($seq) }' < "${!i}" | awk '{print $1,$2}' OFS="\t" | sort -V -k1,1 > "$(basename "${!i}").chrom.sizes"
done

mzchr=Maylandia_zebra.M_zebra_UMD2a.dna.primary_assembly.allLG.and.nonchromosomal.fa.chrom.sizes
pnchr=Pundamilia_nyererei.PunNye1.0.dna.nonchromosomal.fa.chrom.sizes
abchr=Haplochromis_burtoni.AstBur1.0.dna.nonchromosomal.fa.chrom.sizes
nbchr=Neolamprologus_brichardi.NeoBri1.0.dna.nonchromosomal.fa.chrom.sizes
acchr=Astatotilapia_calliptera.fAstCal1.2.dna.primary_assembly.allLG.and.nonchromosomal.fa.chrom.sizes
onchr=Oreochromis_niloticus.O_niloticus_UMD_NMBU.dna.primary_assembly.allLG.and.nonchromosomal.fa.chrom.sizes

zcat ${gtfmzeb} |
awk 'BEGIN{OFS="\t";} $3=="gene" {print $1,$4-1,$5,$3,".",$7,$10,".",".",$14}' |
sed 's|"||g' | sed 's|;||g'|
sort -V -k1,1 -k2,2n |
bedtools complement -i stdin -g ${mzchr} | awk '{print $1"_"$2,$1"_"$3,$0}' OFS='\t' > $(basename "${gtfmzeb}" .gtf.gz)_intergenic.bed

zcat ${gtfpnye} |
awk 'BEGIN{OFS="\t";} $3=="gene" {print $1,$4-1,$5,$3,".",$7,$10,".",".",$14}' |
sed 's|"||g' | sed 's|;||g'|
sort -V -k1,1 -k2,2n |
bedtools complement -i stdin -g ${pnchr} | awk '{print $1"_"$2,$1"_"$3,$0}' OFS='\t' > $(basename "${gtfpnye}" .gtf.gz)_intergenic.bed

zcat ${gtfabur} |
awk 'BEGIN{OFS="\t";} $3=="gene" {print $1,$4-1,$5,$3,".",$7,$10,".",".",$14}' |
sed 's|"||g' | sed 's|;||g'|
sort -V -k1,1 -k2,2n |
bedtools complement -i stdin -g ${abchr} | awk '{print $1"_"$2,$1"_"$3,$0}' OFS='\t' > $(basename "${gtfabur}" .gtf.gz)_intergenic.bed

zcat ${gtfnbri} |
awk 'BEGIN{OFS="\t";} $3=="gene" {print $1,$4-1,$5,$3,".",$7,$10,".",".",$14}' |
sed 's|"||g' | sed 's|;||g'|
sort -V -k1,1 -k2,2n |
bedtools complement -i stdin -g ${nbchr} | awk '{print $1"_"$2,$1"_"$3,$0}' OFS='\t' > $(basename "${gtfnbri}" .gtf.gz)_intergenic.bed

zcat ${gtfacal} |
awk 'BEGIN{OFS="\t";} $3=="gene" {print $1,$4-1,$5,$3,".",$7,$10,".",".",$14}' |
sed 's|"||g' | sed 's|;||g'|
sort -V -k1,1 -k2,2n |
bedtools complement -i stdin -g ${acchr} | awk '{print $1"_"$2,$1"_"$3,$0}' OFS='\t' > $(basename "${gtfacal}" .gtf.gz)_intergenic.bed

zcat ${gtfonil} |
awk 'BEGIN{OFS="\t";} $3=="gene" {print $1,$4-1,$5,$3,".",$7,$10,".",".",$14}' |
sed 's|"||g' | sed 's|;||g'|
sort -V -k1,1 -k2,2n |
bedtools complement -i stdin -g ${onchr} | awk '{print $1"_"$2,$1"_"$3,$0}' OFS='\t' > $(basename "${gtfonil}" .gtf.gz)_intergenic.bed

# then do double mappings to annotate the intergenic e.g. ENS_intergenic_ENS and genesymbol_intergenic_genesymbol
# # a. create a gene map to use
# zcat ${gtfmzeb} |
# awk 'BEGIN{OFS="\t";} $3=="gene" {print $1,$4-1,$5,$3,".",$7,$10,".",".",$14}' |
# sed 's|"||g' | sed 's|;||g'|
# sort -V -k1,1 -k2,2n | awk '{print $1"_"$2,$1"_"$3,$0}' OFS='\t' > $(basename "${gtfmzeb}" .gtf.gz)_gene.bed
# # b. double map both first two cols of intergenic file to corresponding in gene
# awk 'BEGIN{OFS="\t"}NR==FNR{a[$2]=$0;next}{if(a[$1]){print $0,a[$1];}else{print $0,"NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL";}}' $(basename "${gtfmzeb}" .gtf.gz)_gene.bed $(basename "${gtfmzeb}" .gtf.gz)_intergenic.bed | awk '{print $1,$2,$3,$4,$5,"intergenic",".",$13,$14"_intergenic_",$15,$16,$17"_intergenic_"}' OFS='\t' > $(basename "${gtfmzeb}" .gtf.gz)_intergenic.firstmap.bed # map col1 intergenic to col2 gene
# awk 'BEGIN{OFS="\t"}NR==FNR{a[$1]=$0;next}{if(a[$2]){print $0,a[$2];}else{print $0,"NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL";}}' $(basename "${gtfmzeb}" .gtf.gz)_gene.bed $(basename "${gtfmzeb}" .gtf.gz)_intergenic.firstmap.bed | awk '{print $3,$4,$5,$6,$7,$8,$9$21,$10,$11,$12$24}' OFS='\t' > $(basename "${gtfmzeb}" .gtf.gz)_intergenic.map.bed # map col2 above to col1 gene

for i in "${!gtf@}"; do
  # a. create a gene map to use
  zcat ${!i} |
  awk 'BEGIN{OFS="\t";} $3=="gene" {print $1,$4-1,$5,$3,".",$7,$10,".",".",$14}' |
  sed 's|"||g' | sed 's|;||g'|
  sort -V -k1,1 -k2,2n | awk '{print $1"_"$2,$1"_"$3,$0}' OFS='\t' > $(basename "${!i}" .gtf.gz)_gene.bed
  # b. double map both first two cols of intergenic file to corresponding in gene
  awk 'BEGIN{OFS="\t"}NR==FNR{a[$2]=$0;next}{if(a[$1]){print $0,a[$1];}else{print $0,"NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL";}}' $(basename "${!i}" .gtf.gz)_gene.bed $(basename "${!i}" .gtf.gz)_intergenic.bed | awk '{print $1,$2,$3,$4,$5,"intergenic",".",$13,$14"_intergenic_",$15,$16,$17"_intergenic_"}' OFS='\t' > $(basename "${!i}" .gtf.gz)_intergenic.firstmap.bed # map col1 intergenic to col2 gene
  awk 'BEGIN{OFS="\t"}NR==FNR{a[$1]=$0;next}{if(a[$2]){print $0,a[$2];}else{print $0,"NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL";}}' $(basename "${!i}" .gtf.gz)_gene.bed $(basename "${!i}" .gtf.gz)_intergenic.firstmap.bed | awk '{print $3,$4,$5,$6,$7,$8,$9$21,$10,$11,$12$24}' OFS='\t' > $(basename "${!i}" .gtf.gz)_intergenic.map.bed # map col2 above to col1 gene
done

rm *intergenic.firstmap.bed

# v. process 5kb promoters and add gene symbols

# create a complete promoter bed file with gene symbols (using those from gene mappings)
# awk 'BEGIN{OFS="\t"}NR==FNR{a[$9]=$0;next}{if(a[$4]){print $0,a[$4];}else{print $0,"NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL";}}' $(basename "${gtfmzeb}" .gtf.gz)_gene.bed ${promannotMz} | awk '{print $1,$2,$3,"5kb_gene_promoter",".",$6,$4,".",".",$18}' OFS='\t' > $(basename "${Mz5kbpromannot}" .bed).map.bed

awk 'BEGIN{OFS="\t"}NR==FNR{a[$9]=$0;next}{if(a[$4]){print $0,a[$4];}else{print $0,"NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL";}}' $(basename "${gtfmzeb}" .gtf.gz)_gene.bed ${promannotMz} | awk '{print $1,$2,$3,"5kb_gene_promoter",".",$6,$4,".",".",$18}' OFS='\t' > $(basename "${promannotMz}" .bed).map.bed
awk 'BEGIN{OFS="\t"}NR==FNR{a[$9]=$0;next}{if(a[$4]){print $0,a[$4];}else{print $0,"NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL";}}' $(basename "${gtfpnye}" .gtf.gz)_gene.bed ${promannotPn} | awk '{print $1,$2,$3,"5kb_gene_promoter",".",$6,$4,".",".",$18}' OFS='\t' > $(basename "${promannotPn}" .bed).map.bed
awk 'BEGIN{OFS="\t"}NR==FNR{a[$9]=$0;next}{if(a[$4]){print $0,a[$4];}else{print $0,"NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL";}}' $(basename "${gtfabur}" .gtf.gz)_gene.bed ${promannotAb} | awk '{print $1,$2,$3,"5kb_gene_promoter",".",$6,$4,".",".",$18}' OFS='\t' > $(basename "${promannotAb}" .bed).map.bed
awk 'BEGIN{OFS="\t"}NR==FNR{a[$9]=$0;next}{if(a[$4]){print $0,a[$4];}else{print $0,"NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL";}}' $(basename "${gtfnbri}" .gtf.gz)_gene.bed ${promannotNb} | awk '{print $1,$2,$3,"5kb_gene_promoter",".",$6,$4,".",".",$18}' OFS='\t' > $(basename "${promannotNb}" .bed).map.bed
awk 'BEGIN{OFS="\t"}NR==FNR{a[$9]=$0;next}{if(a[$4]){print $0,a[$4];}else{print $0,"NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL";}}' $(basename "${gtfacal}" .gtf.gz)_gene.bed ${promannotAc} | awk '{print $1,$2,$3,"5kb_gene_promoter",".",$6,$4,".",".",$18}' OFS='\t' > $(basename "${promannotAc}" .bed).map.bed
awk 'BEGIN{OFS="\t"}NR==FNR{a[$9]=$0;next}{if(a[$4]){print $0,a[$4];}else{print $0,"NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL";}}' $(basename "${gtfonil}" .gtf.gz)_gene.bed ${promannotOn} | awk '{print $1,$2,$3,"5kb_gene_promoter",".",$6,$4,".",".",$18}' OFS='\t' > $(basename "${promannotOn}" .bed).map.bed

# vi. process five_prime_utr and three_prime_utr (including info on gene_id, transcript_id, gene_name, exon_number)
# zcat ${gtfmzeb} |
# awk 'BEGIN{OFS="\t";} $3=="five_prime_utr" {print $1,$4-1,$5,$3,".",$7,$10,$14,".",$18}' |
# sed 's|"||g' | sed 's|;||g'|
# sort -V -k1,1 -k2,2n > $(basename "${gtfmzeb}" .gtf.gz)_5UTR.map.bed

for i in "${!gtf@}"; do
  zcat ${!i} |
  awk 'BEGIN{OFS="\t";} $3=="five_prime_utr" {print $1,$4-1,$5,$3,".",$7,$10,$14,".",$18}' |
  sed 's|"||g' | sed 's|;||g'|
  sort -V -k1,1 -k2,2n > $(basename "${!i}" .gtf.gz)_5UTR.map.bed
done

# zcat ${gtfmzeb} |
# awk 'BEGIN{OFS="\t";} $3=="three_prime_utr" {print $1,$4-1,$5,$3,".",$7,$10,$14,".",$18}' |
# sed 's|"||g' | sed 's|;||g'|
# sort -V -k1,1 -k2,2n > $(basename "${gtfmzeb}" .gtf.gz)_3UTR.map.bed

for i in "${!gtf@}"; do
  zcat ${!i} |
  awk 'BEGIN{OFS="\t";} $3=="three_prime_utr" {print $1,$4-1,$5,$3,".",$7,$10,$14,".",$18}' |
  sed 's|"||g' | sed 's|;||g'|
  sort -V -k1,1 -k2,2n > $(basename "${!i}" .gtf.gz)_3UTR.map.bed
done


# vii. process CNEs and add
# CNEs - however, coordinates are On only - need to liftover from MAF for each species!!!!
# this will be for three sets of files (in each species)
  # 1. hCNEs - avg conservation of >=0.9
  # cat /ei/projects/9/92817604-7d6f-42a9-b8c4-b9657c1fde33/scratch/FishCNEs/SixSpCNEs/3.phast/Rerun_all_240821/*.6sp_CNEs.mostcons.avgcons.bed | awk '$10=="hCNE"' # hCNEs - however, coordinates are On only - need to liftover from MAF for each species!!!!

  # 2. pseudo_aCNE - avg conservation of <0.9
  #cat /ei/projects/9/92817604-7d6f-42a9-b8c4-b9657c1fde33/scratch/FishCNEs/SixSpCNEs/3.phast/Rerun_all_240821/*.6sp_CNEs.mostcons.avgcons.bed | awk '$10=="pseudo_aCNE"'

  # 3. aCNE - CNEs deviating from the neutral model, and so have a negative CONACC score, lnl ratio <0.05, and significant divergence (altsubscale >1).
  #/ei/projects/9/92817604-7d6f-42a9-b8c4-b9657c1fde33/scratch/FishCNEs/SixSpCNEs/3.phast/Rerun_all_240821/BedTool_Intersect/aCNEfeatures_TOTAL_NonCODING_PostFilter_* # aCNEs - however, coordinates are On only - need to liftover from MAF for each species!!!!

# On pairwise alignment MAFs for this: /ei/projects/9/92817604-7d6f-42a9-b8c4-b9657c1fde33/scratch/FishCNEs/SixSpCNEs/3.phast/MAFSplitting/mafsplit2b_Oreochromis_niloticus-${SPECIES}/*.maf

mkdir -p /ei/projects/9/9e238063-c905-4076-a975-f7c7f85dbd56/scratch/ATACseq/3.run2/4b.peak_phylop/CNE
cd /ei/projects/9/9e238063-c905-4076-a975-f7c7f85dbd56/scratch/ATACseq/3.run2/4b.peak_phylop/CNE


# 0. Create a main bed file
# output structures:
# Oreochromis_niloticus.LG10	15132	15262	LG10.1	0	+	108.493	130	0.834561538461538	pseudo_aCNE



# i. For each ref (On) chr, create hCNEs + pseudo_aCNE files - this is JUST for On and will be used on each species pairwise MAFs to get corresponding coords in those sp
mkdir -p /ei/projects/9/9e238063-c905-4076-a975-f7c7f85dbd56/scratch/ATACseq/3.run2/4b.peak_phylop/CNE/On_hCNEs_pseudoaCNEs
cd /ei/projects/9/9e238063-c905-4076-a975-f7c7f85dbd56/scratch/ATACseq/3.run2/4b.peak_phylop/CNE/On_hCNEs_pseudoaCNEs

for i in /ei/projects/9/92817604-7d6f-42a9-b8c4-b9657c1fde33/scratch/FishCNEs/SixSpCNEs/3.phast/Rerun_all_240821/*.6sp_CNEs.mostcons.avgcons.bed; do
  awk '{print "Oreochromis_niloticus."$1,$2,$3,$4,$5,$6,$7,$8,$9,$10}' OFS='\t' ${i} > $(basename "${i}" _CNEs.mostcons.avgcons.bed)_hCNEs_pseudoaCNEs.bed
done

# ii. For the aCNEs
# A. collate just the On coords for ALL species (removing redundancy)
# B. add to the relevant chr hCNEs and pseudo_aCNE file above, removing redundant pseudo_aCNEs (that are aCNEs)


for i in /ei/projects/9/92817604-7d6f-42a9-b8c4-b9657c1fde33/scratch/FishCNEs/SixSpCNEs/3.phast/Rerun_all_240821/BedTool_Intersect/aCNEfeatures_TOTAL_NonCODING_PostFilter_*; do
  awk '{print "Oreochromis_niloticus."$1,$2,$3,$4,"0",$6,$7,$8,$9,"aCNE"}' OFS='\t' ${i} >> On_aCNEs.collated.bed
done

sort -V -k1,1 -k2,2n On_aCNEs.collated.bed > On_aCNEs.collated.bed.tmp1

# split by same first col (chr) - name as chr.6sp_aCNEs.bed
mkdir -p /ei/projects/9/9e238063-c905-4076-a975-f7c7f85dbd56/scratch/ATACseq/3.run2/4b.peak_phylop/CNE/On_hCNEs_pseudoaCNEs/split
cd /ei/projects/9/9e238063-c905-4076-a975-f7c7f85dbd56/scratch/ATACseq/3.run2/4b.peak_phylop/CNE/On_hCNEs_pseudoaCNEs/split
awk -F'\t' '{print>$1}' /ei/projects/9/9e238063-c905-4076-a975-f7c7f85dbd56/scratch/ATACseq/3.run2/4b.peak_phylop/CNE/On_hCNEs_pseudoaCNEs/On_aCNEs.collated.bed.tmp1
for i in *; do
  name=$(echo ${i} | sed 's|Oreochromis_niloticus.||g')
  mv ${i} ${name}.6sp_aCNEs.bed
done
mv * ../
cd /ei/projects/9/9e238063-c905-4076-a975-f7c7f85dbd56/scratch/ATACseq/3.run2/4b.peak_phylop/CNE/On_hCNEs_pseudoaCNEs/
rm -r split
rm On_aCNEs.collated.bed On_aCNEs.collated.bed.tmp1

for i in *; do
  chr=$(echo $i | sed 's|.6sp.*||g')
  cat ${chr}.6sp_hCNEs_pseudoaCNEs.bed ${chr}.6sp_aCNEs.bed | # then cat chr.6sp_aCNEs.bed and chr.6sp_hCNEs_pseudoaCNEs.bed
  sort -V -k1,1 -k2,2n | # then sort -V -k1,1 -k2,2n
  sed 's|Oreochromis_niloticus.||g' |
  sort -u -k4,4 | sort -V -k1,1 -k2,2n > ${chr}.On.6sp.CNEs.bed # then remove redundant CNEs - retain aCNE, pseuodo_aCNE and hCNE in that order - since every aCNE is first, you can delete the second entry
done

rm *.6sp_hCNEs_pseudoaCNEs.bed
rm *.6sp_aCNEs.bed

# Also create a bed file of ALL CNEs in On as the main map file for that species > Oreochromis_niloticus_CNEs.map.bed
mkdir -p /ei/projects/9/9e238063-c905-4076-a975-f7c7f85dbd56/scratch/ATACseq/3.run2/4b.peak_phylop/CNE/mapfiles
cd /ei/projects/9/9e238063-c905-4076-a975-f7c7f85dbd56/scratch/ATACseq/3.run2/4b.peak_phylop/CNE/mapfiles

cat /ei/projects/9/9e238063-c905-4076-a975-f7c7f85dbd56/scratch/ATACseq/3.run2/4b.peak_phylop/CNE/On_hCNEs_pseudoaCNEs/* | sed 's|Oreochromis_niloticus.||g' | sort -V -k1,1 -k2,2n > Oreochromis_niloticus_CNEs.map.tmp1

# map to genes - this needs to find the closest gene
ongeneannot=/ei/projects/9/9e238063-c905-4076-a975-f7c7f85dbd56/scratch/ATACseq/3.run2/4b.peak_phylop/Oreochromis_niloticus.O_niloticus_UMD_NMBU.100_gene.bed
cut -f3-12 $ongeneannot | sort -V -k1,1 -k2,2n > Oreochromis_niloticus.O_niloticus_UMD_NMBU.100_gene.bed
source bedtools-2.30.0
bedtools closest -a Oreochromis_niloticus_CNEs.map.tmp1 -b Oreochromis_niloticus.O_niloticus_UMD_NMBU.100_gene.bed -d > Oreochromis_niloticus_CNEs.map.tmp2
awk '{print $1,$2,$3,$10,".",$6,$17,".",$7";"$8";"$9";"$21,$20}' OFS='\t' Oreochromis_niloticus_CNEs.map.tmp2 > Oreochromis_niloticus_CNEs.map.bed

# CNE map cols ARE:
# 1. chr
# 2. start
# 3. end
# 4. CNE type: Average_Conservation Score <0.9 = pseudo_aCNE; Average_Conservation Score >=0.9 = hCNE; aCNE = deviating from the neutral model, and so have a negative CONACC score, lnl ratio <0.05, and significant divergence (altsubscale >1)
# 5. score = .
# 6. CNE strand
# 7. closest Ensembl Gene ID
# 8. Ensembl Transcript ID = .
# 9. CNE details - Total conservation score; length of CNE; Average_Conservation Score; Gene distance from CNE
# 10. closest gene symbol

# NOTE: /ei/projects/9/9e238063-c905-4076-a975-f7c7f85dbd56/scratch/ATACseq/3.run2/4b.peak_phylop/CNE/mapfiles/Oreochromis_niloticus_CNEs.map.tmp2 has the complete bedtools closest output and therefore MORE details on gene annotation

# create some final files that DO NOT include pseudo_aCNE (since they are pseudo they are very unreliable)

# CNE map cols ARE:
# 1. chr
# 2. start
# 3. end
# 4. CNE type: Average_Conservation Score >=0.9 = hCNE; aCNE = Average_Conservation Score <0.9, deviating from the neutral model, and so have a negative CONACC score, lnl ratio <0.05, and significant divergence (altsubscale >1)
# 5. score = .
# 6. CNE strand
# 7. closest Ensembl Gene ID
# 8. Ensembl Transcript ID = .
# 9. CNE details - Total conservation score; length of CNE; Average_Conservation Score; Gene distance from CNE
# 10. closest gene symbol

grep -v 'pseudo_aCNE' Oreochromis_niloticus_CNEs.map.tmp1 > Oreochromis_niloticus.6sp_hCNEs_aCNEs.bed
grep -v 'pseudo_aCNE' Oreochromis_niloticus_CNEs.map.bed > Oreochromis_niloticus.6sp_hCNEs_aCNEs.map.bed


## Now, use the above (per chr) On CNE files to obtain CNE coordinates in other species
# On CNE files (split by chr) to use below (to obtain coordinates in other species) are here: /ei/projects/9/9e238063-c905-4076-a975-f7c7f85dbd56/scratch/ATACseq/3.run2/4b.peak_phylop/CNE/On_hCNEs_pseudoaCNEs/${chr}.On.6sp.CNEs.bed


mkdir -p /ei/projects/9/9e238063-c905-4076-a975-f7c7f85dbd56/scratch/ATACseq/3.run2/4b.peak_phylop/CNE/sp_mapping/{Astatotilapia_burtoni,Astatotilapia_calliptera,Metriaclima_zebra,Neolamprologus_brichardi,Pundamilia_nyererei}
cd /ei/projects/9/9e238063-c905-4076-a975-f7c7f85dbd56/scratch/ATACseq/3.run2/4b.peak_phylop/CNE/sp_mapping

nano map_sp_CNEs.sh

#!/bin/bash -e
#SBATCH -p ei-medium # partition (queue)
#SBATCH -N 1 # number of nodes
#SBATCH -n 1 # number of tasks
#SBATCH --mem 22000 # memory pool for all cores
#SBATCH -t 1-23:59 # time (D-HH:MM)
#SBATCH -o slurm.%N.%j.out # STDOUT
#SBATCH -e slurm.%N.%j.err # STDERR
#SBATCH --mail-type=ALL # notifications for job done & fail
#SBATCH --mail-user=Tarang.Mehta@earlham.ac.uk # send-to address

# 1. You can output the MAF (from all pairwise) based on CNEs as features - this way you obtain the comp sp associated coords
# 2. Then output the coordinates of both ref (On) and other sp on a single line (add the length to create an 'end' coordinate)

wd=/ei/projects/9/9e238063-c905-4076-a975-f7c7f85dbd56/scratch/ATACseq/3.run2/4b.peak_phylop/CNE/sp_mapping
cnedir=/ei/projects/9/9e238063-c905-4076-a975-f7c7f85dbd56/scratch/ATACseq/3.run2/4b.peak_phylop/CNE/On_hCNEs_pseudoaCNEs
mafdir=/ei/projects/9/92817604-7d6f-42a9-b8c4-b9657c1fde33/scratch/FishCNEs/SixSpCNEs/3.phast/MAFSplitting

source ucsc_utils-v333

for i in Astatotilapia_burtoni Astatotilapia_calliptera Metriaclima_zebra Neolamprologus_brichardi Pundamilia_nyererei; do
  cd ${wd}/${i}
  ls -1 ${cnedir}/*.On.6sp.CNEs.bed > cnefiles
  while read -r c; do
    chr=$(echo ${c} | sed 's|/ei/projects/9/9e238063-c905-4076-a975-f7c7f85dbd56/scratch/ATACseq/3.run2/4b.peak_phylop/CNE/On_hCNEs_pseudoaCNEs/||g' | sed 's|.On.6sp.CNEs.bed||g')
    out=$(echo $(basename "${c}" .bed).maf)
    # 1. You can output the MAF (from all pairwise) based on CNEs as features - this way you obtain the comp sp associated coords
    mafsInRegion ${c} ${out} ${mafdir}/mafsplit2b_Oreochromis_niloticus-${i}/${chr}.maf
    # 2. Then output the coordinates of both ref (On) and other sp on a single line (add the length to create an 'end' coordinate)
    grep -v 'version' ${out} | # remove first few lines
    sed '/^$/d' | # remove blank lines
    awk '{print $1,$2,$3,$3+$4,$5}' OFS='\t' | # get the relevant cols and input an end coordinate
    sed 's/.*score=0.000000.*/;;;;/' | # replace the whole alignment line with something that can be used as a line delimiter e.g. ';;;;'
    awk 'BEGIN{RS="\n?\\;;;;\n"; FS="\n"; OFS="\t"} {$1=$1} NR>1' | # use the new line delimiter to join all lines inbetween the delimiter
    cut -f2-5,7-10,12-15 > $(basename "${out}" .maf).tmp1 # keep only the necessary columns
    # check the min and max number of cols
    awk '{print NF}' $(basename "${out}" .maf).tmp1 | sort -nu | head -n 1 >> minmaxcol # 4
    awk '{print NF}' $(basename "${out}" .maf).tmp1 | sort -nu | tail -n 1 >> minmaxcol # 12 - this means there are no more than two hits
    # if there are MORE than 12 cols then you need amend below (cutting the extra mapped cols)
  done < cnefiles
done

for i in Astatotilapia_burtoni Astatotilapia_calliptera Metriaclima_zebra Neolamprologus_brichardi Pundamilia_nyererei; do
  echo "======="${i}"======="
  sort -u ${wd}/${i}/minmaxcol # we want no more than 12 otherwise the cutting of columns needs to be amended below
done

source bedtools-2.30.0

refsp=Oreochromis_niloticus # insert the reference species for awk removal of lines below

for species in Astatotilapia_burtoni Astatotilapia_calliptera Metriaclima_zebra Neolamprologus_brichardi Pundamilia_nyererei; do
  cd ${wd}/${species}
  while read -r file; do
    chr=$(echo ${file} | sed 's|/ei/projects/9/9e238063-c905-4076-a975-f7c7f85dbd56/scratch/ATACseq/3.run2/4b.peak_phylop/CNE/On_hCNEs_pseudoaCNEs/||g' | sed 's|.On.6sp.CNEs.bed||g')
    out=$(echo $(basename "${file}" .bed).maf)
    # A. create a file with all lines, retaining those where the ref has a hit and also any multiple hits
    cut -f1-8 $(basename "${out}" .maf).tmp1 | awk -F'\t' 'NF==8 {print}' > $(basename "${out}" .maf).tmp2a
    cut -f1-4,9-12 $(basename "${out}" .maf).tmp1 | awk -F'\t' 'NF==8 {print}' > $(basename "${out}" .maf).tmp2b
    cat $(basename "${out}" .maf).tmp2a $(basename "${out}" .maf).tmp2b | sort -V -k1,1 -k2,2n | awk '{print $1,$2,$3,".",".",$4,$5,$6,$7,$8}' OFS='\t' > $(basename "${out}" .maf).tmp3
    # B. at this stage you can concatenate adjoining regions in the ref
    bedtools merge -i $(basename "${out}" .maf).tmp3 -s > $(basename "${out}" .maf).tmp4
    # C. now need to map back to a pre-merge file to get the comp sp columns - use intersect then process
    bedtools intersect -a $(basename "${out}" .maf).tmp4 -b $(basename "${out}" .maf).tmp3 -wao | sort -V -k10,10 -k11,11n | sort -V -k1,1 -k2,2n | awk '{print $1"_"$2"_"$3,$0}' OFS='\t' | awk -v refsp="$refsp" '$11!~refsp' | awk '{print $11,$12,$13,".",".",$14,$1,$2,$3,$4,$5,$6,$7,$8,$9,$10}' OFS='\t' | sort -V -k1,1 -k2,2n > $(basename "${out}" .maf).tmp5
    bedtools merge -i $(basename "${out}" .maf).tmp5 -d 5 -c 4,5,6,7,8,9,10,11,12,13,14,15,16 -o collapse > $(basename "${out}" .maf).tmp5a # using a max 5bp distance to join
    while read -r a b c d e f g h i j k l m n o p; do
      # echo ${g} | tr ',' '\n' | sort -u | tr '\n' ','
      newf=$(echo ${f} | tr ',' '\n' | sort -u | tr '\n' ',' | sed 's|,$||')
      newg=$(echo ${g} | tr ',' '\n' | sort -u | tr '\n' ',' | sed 's|,$||')
      newh=$(echo ${h} | tr ',' '\n' | sort -u | tr '\n' ',' | sed 's|,$||')
      newi=$(echo ${i} | tr ',' '\n' | sort -u | tr '\n' ',' | sed 's|,$||')
      newj=$(echo ${j} | tr ',' '\n' | sort -u | tr '\n' ',' | sed 's|,$||')
      newp=$(echo ${p} | tr ',' '\n' | sort -u | tr '\n' ',' | sed 's|,$||')
      echo -e ${newg}'\t'${newh}'\t'${newi}'\t'${newj}'\t'${newp}'\t'${a}'\t'${b}'\t'${c}'\t'${newf} >> $(basename "${out}" .maf).tmp5c
    done < $(basename "${out}" .maf).tmp5a # output format to be (ref chr_ref_start_ref_end,ref chr,ref_start,ref_end,ref_strand,sp_chr,sp_start,sp_end,sp_strand)
    while read -r a b c d e f g h i; do
      newa=$(echo ${a} | sed 's|,.*||')
      newb=$(echo ${b} | sed 's|,.*||')
      newc=$(echo ${c} | sed 's|,.*||')
      newd=$(echo ${d} | sed 's|,.*||')
      newe=$(echo ${e} | sed 's|,.*||')
      newf=$(echo ${f} | sed 's|,.*||')
      newg=$(echo ${g} | sed 's|,.*||')
      newh=$(echo ${h} | sed 's|,.*||')
      newi=$(echo ${i} | sed 's|,.*||')
      echo -e ${newa}'\t'${newb}'\t'${newc}'\t'${newd}'\t'${newe}'\t'${newf}'\t'${newg}'\t'${newh}'\t'${newi} >> $(basename "${out}" .maf).tmp5d
    done < $(basename "${out}" .maf).tmp5c # output format to be (ref chr_ref_start_ref_end,ref chr,ref_start,ref_end,ref_strand,sp_chr,sp_start,sp_end,sp_strand)
    sort -V -k2,2 -k3,3n $(basename "${out}" .maf).tmp5d | awk '$8-$7>=30' > $(basename "${out}" .maf).tmp6 # sort and remove instances where comp sp CNE is <30bp
    # awk '{print $1"_"$2,$1"_"$3,$1,$2,$3,$4,$5,$6,$7,$8,$9,$10}' OFS='\t' $(basename "${out}" .maf).tmp3 > $(basename "${out}" .maf).tmp3a
    # awk '{print $1"_"$2,$1"_"$3,$1,$2,$3}' OFS='\t' $(basename "${out}" .maf).tmp4 > $(basename "${out}" .maf).tmp4a
    # awk 'BEGIN{OFS="\t"}NR==FNR{a[$1]=$0;next}{if(a[$1]){print $0,a[$1];}else{print $0,"NULL";}}' $(basename "${out}" .maf).tmp3a $(basename "${out}" .maf).tmp4a > $(basename "${out}" .maf).tmp5a
    # awk 'BEGIN{OFS="\t"}NR==FNR{a[$2]=$0;next}{if(a[$2]){print $0,a[$2];}else{print $0,"NULL";}}' $(basename "${out}" .maf).tmp3a $(basename "${out}" .maf).tmp5a > $(basename "${out}" .maf).tmp5b
    # cut -f3-5,13-15,28-29 $(basename "${out}" .maf).tmp5b | awk '{print $1"_"$2"_"$3,$1,$2,$3,$4,$5,$6,$7,$8}' OFS='\t' > $(basename "${out}" .maf).tmp6
    # D. now map to the CNEs main input bed file - check if direct matches work (have you recovered all CNEs of ref coordinates from the MAF and concatenated correctly?)
    # E. some CNEs will go missing as no alignment - to be expected for those that have diverged or CNE called based on conservation with another species
    awk '{print "Oreochromis_niloticus."$1"_"$2"_"$3,"Oreochromis_niloticus."$1,$2,$3,$4,$5,$6,$7,$8,$9,$10}' OFS='\t' ${file} > $(basename "${file}" .bed).amend.bed
    # F. this creates a FINALISED CNE bed file with all the phast details for each species
    awk 'BEGIN{OFS="\t"}NR==FNR{a[$1]=$0;next}{if(a[$1]){print $0,a[$1];}else{print $0,"NOMATCH";}}' $(basename "${out}" .maf).tmp6 $(basename "${file}" .bed).amend.bed | grep -v 'NOMATCH' | awk '{print $17,$18,$19,$5,$6,$20,$8,$9,$10,$11}' OFS='\t' >> ${species}.6sp_CNEs.bed.tmp1
  done < cnefiles
done

# G. Now create the finalised and collated CNE file for each comparison species (Onil created above)
for i in Astatotilapia_burtoni Astatotilapia_calliptera Metriaclima_zebra Neolamprologus_brichardi Pundamilia_nyererei; do
  cd ${wd}/${i}
  sed 's/^[^.]*.//g' ${i}.6sp_CNEs.bed.tmp1 | sort -V -k1,1 -k2,2n > ${i}.6sp_CNEs.bed
  rm ${i}.6sp_CNEs.bed.tmp1  ### TO RUN ONCE COMPLETED - DONE
done

cd ${wd}
rm */*.tmp*  ### TO RUN ONCE COMPLETED - DONE
rm */*.amend.bed  ### TO RUN ONCE COMPLETED - DONE

# For Part B above: used bedtools merge to combine overlapping or “book-ended” or distance < 5bp features in an interval file into a single feature which spans all of the combined features.
# for example:
# Oreochromis_niloticus.LG10      20241   20320   +       Astatotilapia_calliptera.10     73546   73625   +
# Oreochromis_niloticus.LG10      20320   20352   +       Astatotilapia_calliptera.10     73653   73685   +
# Oreochromis_niloticus.LG10      20352   20383   +       Astatotilapia_calliptera.10     73685   73716   +
# will turn into:
# Oreochromis_niloticus.LG10      20241   20383   +       Astatotilapia_calliptera.10     73546   73716   +

# For Part C Above: for any multiple matches, the first hit is taken since that will invariably be the correct match; as an example:
# Oreochromis_niloticus.MKQE02000170.1_185448_185579,Oreochromis_niloticus.MKQE02000170.1_185585_185674	Oreochromis_niloticus.MKQE02000170.1	185448,185585	185579,185674	+	Metriaclima_zebra.AGTA05000053.1	74635	74772	+
# goes to:
# Oreochromis_niloticus.MKQE02000170.1_185448_185579	Oreochromis_niloticus.MKQE02000170.1	185448	185579	+	Metriaclima_zebra.AGTA05000053.1	74635	74772	+


# 3. now create a mapped bed file for the annotation (using bedtools closest - Onil created above)

cd /ei/projects/9/9e238063-c905-4076-a975-f7c7f85dbd56/scratch/ATACseq/3.run2/4b.peak_phylop/CNE/mapfiles

accne=/ei/projects/9/9e238063-c905-4076-a975-f7c7f85dbd56/scratch/ATACseq/3.run2/4b.peak_phylop/CNE/sp_mapping/Astatotilapia_calliptera/Astatotilapia_calliptera.6sp_CNEs.bed
abcne=/ei/projects/9/9e238063-c905-4076-a975-f7c7f85dbd56/scratch/ATACseq/3.run2/4b.peak_phylop/CNE/sp_mapping/Astatotilapia_burtoni/Astatotilapia_burtoni.6sp_CNEs.bed
mzcne=/ei/projects/9/9e238063-c905-4076-a975-f7c7f85dbd56/scratch/ATACseq/3.run2/4b.peak_phylop/CNE/sp_mapping/Metriaclima_zebra/Metriaclima_zebra.6sp_CNEs.bed
nbcne=/ei/projects/9/9e238063-c905-4076-a975-f7c7f85dbd56/scratch/ATACseq/3.run2/4b.peak_phylop/CNE/sp_mapping/Neolamprologus_brichardi/Neolamprologus_brichardi.6sp_CNEs.bed
pncne=/ei/projects/9/9e238063-c905-4076-a975-f7c7f85dbd56/scratch/ATACseq/3.run2/4b.peak_phylop/CNE/sp_mapping/Pundamilia_nyererei/Pundamilia_nyererei.6sp_CNEs.bed

acgeneannot=/ei/projects/9/9e238063-c905-4076-a975-f7c7f85dbd56/scratch/ATACseq/3.run2/4b.peak_phylop/Astatotilapia_calliptera.fAstCal1.2.100_gene.bed
abgeneannot=/ei/projects/9/9e238063-c905-4076-a975-f7c7f85dbd56/scratch/ATACseq/3.run2/4b.peak_phylop/Haplochromis_burtoni.AstBur1.0.100_gene.bed
mzgeneannot=/ei/projects/9/9e238063-c905-4076-a975-f7c7f85dbd56/scratch/ATACseq/3.run2/4b.peak_phylop/Maylandia_zebra.M_zebra_UMD2a.100_gene.bed
nbgeneannot=/ei/projects/9/9e238063-c905-4076-a975-f7c7f85dbd56/scratch/ATACseq/3.run2/4b.peak_phylop/Neolamprologus_brichardi.NeoBri1.0.100_gene.bed
pngeneannot=/ei/projects/9/9e238063-c905-4076-a975-f7c7f85dbd56/scratch/ATACseq/3.run2/4b.peak_phylop/Pundamilia_nyererei.PunNye1.0.100_gene.bed

cut -f3-12 $acgeneannot | sort -V -k1,1 -k2,2n > Astatotilapia_calliptera.fAstCal1.2.100_gene.bed
cut -f3-12 $abgeneannot | sort -V -k1,1 -k2,2n > Astatotilapia_burtoni.AstBur1.0.100_gene.bed
cut -f3-12 $mzgeneannot | sort -V -k1,1 -k2,2n > Metriaclima_zebra.M_zebra_UMD2a.100_gene.bed
cut -f3-12 $nbgeneannot | sort -V -k1,1 -k2,2n > Neolamprologus_brichardi.NeoBri1.0.100_gene.bed
cut -f3-12 $pngeneannot | sort -V -k1,1 -k2,2n > Pundamilia_nyererei.PunNye1.0.100_gene.bed

source bedtools-2.30.0

spcnedir=/ei/projects/9/9e238063-c905-4076-a975-f7c7f85dbd56/scratch/ATACseq/3.run2/4b.peak_phylop/CNE/sp_mapping

for i in Astatotilapia_calliptera.fAstCal1.2.100_gene.bed Astatotilapia_burtoni.AstBur1.0.100_gene.bed Metriaclima_zebra.M_zebra_UMD2a.100_gene.bed Neolamprologus_brichardi.NeoBri1.0.100_gene.bed Pundamilia_nyererei.PunNye1.0.100_gene.bed; do
  sp=$(echo ${i} | awk -F'.' '{print $1}')
  grep -v 'pseudo_aCNE' ${spcnedir}/${sp}/${sp}.6sp_CNEs.bed > ${sp}.6sp_hCNEs_aCNEs.bed
  bedtools closest -a ${sp}.6sp_hCNEs_aCNEs.bed -b ${i} -d > ${sp}.6sp_hCNEs_aCNEs.map.tmp2
  awk '{print $1,$2,$3,$10,".",$6,$17,".",$7";"$8";"$9";"$21,$20}' OFS='\t' ${sp}.6sp_hCNEs_aCNEs.map.tmp2 > ${sp}.6sp_hCNEs_aCNEs.map.bed
done

rm *.6sp_hCNEs_aCNEs.map.tmp2 ### TO RUN ONCE COMPLETED - DONE

# run the above
sbatch map_sp_CNEs.sh ## DONE (but created individual species files to run instead - took around one day each)


# 4. copy FINAL CNE files (and the code to the CNE pipeline script):
mkdir -p /ei/projects/9/92817604-7d6f-42a9-b8c4-b9657c1fde33/scratch/FishCNEs/SixSpCNEs/3.phast/Rerun_all_240821/FINALfiles # DONE

cp *_CNEs.map.bed /ei/projects/9/92817604-7d6f-42a9-b8c4-b9657c1fde33/scratch/FishCNEs/SixSpCNEs/3.phast/Rerun_all_240821/FINALfiles # DONE
cp *.6sp_hCNEs_aCNEs.map.bed /ei/projects/9/92817604-7d6f-42a9-b8c4-b9657c1fde33/scratch/FishCNEs/SixSpCNEs/3.phast/Rerun_all_240821/FINALfiles # DONE
cp ${wd}/*.sh /ei/projects/9/92817604-7d6f-42a9-b8c4-b9657c1fde33/scratch/FishCNEs/SixSpCNEs/3.phast/Rerun_all_240821/FINALfiles # DONE
cp *.6sp_hCNEs_aCNEs.map.bed /ei/projects/9/9e238063-c905-4076-a975-f7c7f85dbd56/scratch/ATACseq/3.run2/4b.peak_phylop # DONE



# viii. add all the annotations to create a final annotation file in gff format for each species (add to ref locations too, and CNE stuff to CNE pipeline)
# intergenic, CNEs, 5kb gene promoter, 5' UTR, exon, intron, 3’ UTR

mkdir -p /ei/projects/9/9e238063-c905-4076-a975-f7c7f85dbd56/scratch/ATACseq/3.run2/4b.peak_phylop/final_annot
cd /ei/projects/9/9e238063-c905-4076-a975-f7c7f85dbd56/scratch/ATACseq/3.run2/4b.peak_phylop/final_annot

dir=/ei/projects/9/9e238063-c905-4076-a975-f7c7f85dbd56/scratch/ATACseq/3.run2/4b.peak_phylop

source bedtools-2.30.0

# since 5kb promoters are still overlapping intergenic, subtract them to create a NEW intergenic file for each species
bedtools subtract -a ${dir}/Astatotilapia_calliptera.fAstCal1.2.100_intergenic.map.bed -b ${dir}/Astatotilapia_calliptera.fAstCal1.2.101.5kb_promoters.map.bed > ${dir}/Astatotilapia_calliptera.fAstCal1.2.100_intergenic.NEWminus5kbProm.map.bed
bedtools subtract -a ${dir}/Haplochromis_burtoni.AstBur1.0.100_intergenic.map.bed -b ${dir}/Haplochromis_burtoni.AstBur1.0.101.5kb_promoters.map.bed > ${dir}/Haplochromis_burtoni.AstBur1.0.100_intergenic.NEWminus5kbProm.map.bed
bedtools subtract -a ${dir}/Maylandia_zebra.M_zebra_UMD2a.100_intergenic.map.bed -b ${dir}/Maylandia_zebra.M_zebra_UMD2a.101.5kb_promoters.map.bed > ${dir}/Maylandia_zebra.M_zebra_UMD2a.100_intergenic.NEWminus5kbProm.map.bed
bedtools subtract -a ${dir}/Neolamprologus_brichardi.NeoBri1.0.100_intergenic.map.bed -b ${dir}/Neolamprologus_brichardi.NeoBri1.0.101.5kb_promoters.map.bed > ${dir}/Neolamprologus_brichardi.NeoBri1.0.100_intergenic.NEWminus5kbProm.map.bed
bedtools subtract -a ${dir}/Oreochromis_niloticus.O_niloticus_UMD_NMBU.100_intergenic.map.bed -b ${dir}/Oreochromis_niloticus.O_niloticus_UMD_NMBU.101.5kb_promoters.map.bed > ${dir}/Oreochromis_niloticus.O_niloticus_UMD_NMBU.100_intergenic.NEWminus5kbProm.map.bed
bedtools subtract -a ${dir}/Pundamilia_nyererei.PunNye1.0.100_intergenic.map.bed -b ${dir}/Pundamilia_nyererei.PunNye1.0.101.5kb_promoters.map.bed > ${dir}/Pundamilia_nyererei.PunNye1.0.100_intergenic.NEWminus5kbProm.map.bed

mv /ei/projects/9/9e238063-c905-4076-a975-f7c7f85dbd56/scratch/ATACseq/3.run2/4b.peak_phylop/Astatotilapia_burtoni.6sp_hCNEs_aCNEs.map.bed /ei/projects/9/9e238063-c905-4076-a975-f7c7f85dbd56/scratch/ATACseq/3.run2/4b.peak_phylop/Astatotilapia_burtoni.AstBur1.0.6sp_hCNEs_aCNEs.map.bed
mv /ei/projects/9/9e238063-c905-4076-a975-f7c7f85dbd56/scratch/ATACseq/3.run2/4b.peak_phylop/Astatotilapia_calliptera.6sp_hCNEs_aCNEs.map.bed /ei/projects/9/9e238063-c905-4076-a975-f7c7f85dbd56/scratch/ATACseq/3.run2/4b.peak_phylop/Astatotilapia_calliptera.fAstCal1.2.6sp_hCNEs_aCNEs.map.bed
mv /ei/projects/9/9e238063-c905-4076-a975-f7c7f85dbd56/scratch/ATACseq/3.run2/4b.peak_phylop/Metriaclima_zebra.6sp_hCNEs_aCNEs.map.bed /ei/projects/9/9e238063-c905-4076-a975-f7c7f85dbd56/scratch/ATACseq/3.run2/4b.peak_phylop/Metriaclima_zebra.M_zebra_UMD2a.6sp_hCNEs_aCNEs.map.bed
mv /ei/projects/9/9e238063-c905-4076-a975-f7c7f85dbd56/scratch/ATACseq/3.run2/4b.peak_phylop/Neolamprologus_brichardi.6sp_hCNEs_aCNEs.map.bed /ei/projects/9/9e238063-c905-4076-a975-f7c7f85dbd56/scratch/ATACseq/3.run2/4b.peak_phylop/Neolamprologus_brichardi.NeoBri1.0.6sp_hCNEs_aCNEs.map.bed
mv /ei/projects/9/9e238063-c905-4076-a975-f7c7f85dbd56/scratch/ATACseq/3.run2/4b.peak_phylop/Oreochromis_niloticus.6sp_hCNEs_aCNEs.map.bed /ei/projects/9/9e238063-c905-4076-a975-f7c7f85dbd56/scratch/ATACseq/3.run2/4b.peak_phylop/Oreochromis_niloticus.O_niloticus_UMD_NMBU.6sp_hCNEs_aCNEs.map.bed
mv /ei/projects/9/9e238063-c905-4076-a975-f7c7f85dbd56/scratch/ATACseq/3.run2/4b.peak_phylop/Pundamilia_nyererei.6sp_hCNEs_aCNEs.map.bed /ei/projects/9/9e238063-c905-4076-a975-f7c7f85dbd56/scratch/ATACseq/3.run2/4b.peak_phylop/Pundamilia_nyererei.PunNye1.0.6sp_hCNEs_aCNEs.map.bed


for i in ${dir}/*_intergenic.NEWminus5kbProm.map.bed ${dir}/*.6sp_hCNEs_aCNEs.map.bed ${dir}/*.5kb_promoters.map.bed ${dir}/*_5UTR.map.bed ${dir}/*_exon_merged.map.bed ${dir}/*_intron.map.bed ${dir}/*_3UTR.map.bed; do
  sp=$(echo $(basename "$i") | awk -F'.' '{print $1}' | sed 's|Haplochromis_burtoni|Astatotilapia_burtoni|g' | sed 's|Maylandia_zebra|Metriaclima_zebra|g')
  vers=$(echo $(basename "$i") | awk -F'.' '{print $2"."$3}' | sed 's|_intergenic||g' | sed 's|_5UTR||g' | sed 's|_exon_merged||g' | sed 's|_intron||g' | sed 's|_3UTR||g' | sed 's|.101||g' | sed 's|.100||g' | sed 's|.6sp_hCNEs_aCNEs||g')
  # echo $sp
  # echo $vers
  cat ${i} >> ${sp}.${vers}.annot.tmp1
done


for i in *.annot.tmp1; do
  sort -V -k1,1 -k2,2n ${i} > $(basename "${i}" .tmp1).bed
done

rm *.tmp*

# # THIS IS FOR THE OLD APPROACH, NOT NEEDED - at this stage, also remove intergenic that are also 5kb gene promoter e.g.
# # AFNZ01062483.1  0       877     5kb_gene_promoter       .       +       ENSHBUG00000021375      .       .       ensembl
# # AFNZ01062483.1  0       877     intergenic      .       NULL    NULL_intergenic_ENSHBUG00000021375      NULL    NULL    NULL_intergenic_ensembl
#
# for i in *.annot.tmp1; do
#   sort -V -k1,1 -k2,2n ${i} | awk '!visited[$0]++' > $(basename "${i}" .tmp1).tmp2
#   awk 'NR==FNR{s[$1,$2,$3]++;next} (s[$1,$2,$3]>1)' $(basename "${i}" .tmp1).tmp2 $(basename "${i}" .tmp1).tmp2 | # this identifies and prints out all duplicated lines (based on chr,start,end)
#   grep 'intergenic' | awk '{print $1"_"$2"_"$3"_"$4}' > $(basename "${i}" .tmp1).tmp3 # from the above you could extract just the intergenic and then remove them from main file (using a created key)
#   awk '{print $1"_"$2"_"$3"_"$4,$0}' OFS='\t' $(basename "${i}" .tmp1).tmp2 > $(basename "${i}" .tmp1).tmp4 # create a new main file for mapping the key
#   awk 'BEGIN{OFS="\t"}NR==FNR{a[$1]=$0;next}{if(a[$1]){print $0,a[$1];}else{print $0,"KEEPME";}}' $(basename "${i}" .tmp1).tmp3 $(basename "${i}" .tmp1).tmp4 | grep 'KEEPME' | cut -f2-11 > $(basename "${i}" .tmp1).bed # do the map and remove matched lines
# done
#
# rm *.tmp*

# output gff format - example:
# LG1	NULL_intergenic_ctsd	intergenic	0	43173	.	NULL	NULL	NULL_intergenic_ENSONIG00000015575;NULL
# LG1	ctsd	5kb_gene_promoter	38173	43173	.	+	.	ENSONIG00000015575;.
# LG1	ctsd	five_prime_utr	43173	43266	.	+	.	ENSONIG00000015575;ENSONIT00000065129

### For GFF, need to change to 1-BASED, so not book-ended e.g.
# 1       0       19686   intergenic      .       NULL    NULL_intergenic_ENSACLG00000000002      NULL    NULL    NULL_intergenic_lto1    1
# 1       19686   19741   exon    .       -       ENSACLG00000000002      ENSACLT00000000002      5       lto1    1
# 1       19741   20214   intron  .       -       ENSACLG00000000002      .       .       lto1    1
#
# turns to:
#
# 1       1       19686   intergenic      .       NULL    NULL_intergenic_ENSACLG00000000002      NULL    NULL    NULL_intergenic_lto1    1
# 1       19687   19741   exon    .       -       ENSACLG00000000002      ENSACLT00000000002      5       lto1    1
# 1       19742   20214   intron  .       -       ENSACLG00000000002      .       .       lto1    1

for i in *.bed; do
  awk '{print $1,$10,$4,$2+1,$3,$5,$6,$9,$7";"$8}' OFS='\t' ${i} > $(basename "${i}" .bed).gff
done

# ix. create the peaks feature files for each species (example below)

# head /ei/projects/9/92817604-7d6f-42a9-b8c4-b9657c1fde33/scratch/FishCNEs/SixSpCNEs/3.phast/Rerun_all_240821/MKQE02000050.1.phylop_pseudoaCNEs.features.gff
# MKQE02000050	phastCons	pseudo_aCNE	5189	5571	0.622780104712042	+	.	MKQE02000050.1.1
# MKQE02000050	phastCons	pseudo_aCNE	7211	7432	0.687054298642534	+	.	MKQE02000050.1.2
# create a gff of the peaks, adding the annotated feature they overlap (and all the info), and then split by chromosome

# amend the name col in peaks file and run an intersect with the corresponding species annotations

mkdir -p /ei/projects/9/9e238063-c905-4076-a975-f7c7f85dbd56/scratch/ATACseq/3.run2/4b.peak_phylop/0.phylop_run
cd /ei/projects/9/9e238063-c905-4076-a975-f7c7f85dbd56/scratch/ATACseq/3.run2/4b.peak_phylop/0.phylop_run

# peak files here - ${idrdir}/*_ATAC_peaks.final.narrowPeak

nano mappeaksfeatures.sh

#!/bin/bash -e
#SBATCH -p ei-medium # partition (queue)
#SBATCH -N 1 # number of nodes
#SBATCH -n 1 # number of tasks
#SBATCH --mem 12000 # memory pool for all cores
#SBATCH -t 0-03:59 # time (D-HH:MM)
#SBATCH -o slurm.%N.%j.out # STDOUT
#SBATCH -e slurm.%N.%j.err # STDERR
#SBATCH --mail-type=ALL # notifications for job done & fail
#SBATCH --mail-user=Tarang.Mehta@earlham.ac.uk # send-to address

idrdir=/ei/projects/9/9e238063-c905-4076-a975-f7c7f85dbd56/scratch/ATACseq/3.run2/1.IDR
phylodir=/ei/projects/9/9e238063-c905-4076-a975-f7c7f85dbd56/scratch/ATACseq/3.run2/4b.peak_phylop/0.phylop_run
annotdir=/ei/projects/9/9e238063-c905-4076-a975-f7c7f85dbd56/scratch/ATACseq/3.run2/4b.peak_phylop/final_annot

mkdir -p ${phylodir}/{Astatotilapia_calliptera,Astatotilapia_burtoni,Metriaclima_zebra,Neolamprologus_brichardi,Oreochromis_niloticus,Pundamilia_nyererei}

source bedtools-2.30.0

# ix-a. amend and store peaks file in species specific folders to run species specific code later
for i in ${idrdir}/*_ATAC_peaks.final.narrowPeak; do
  id=$(echo $(basename "${i}" ) | awk -F'_' '{print $1}')
  file=$(echo $(basename "${i}" ))
  if [[ ${id} =~ "Ac" ]]; then
    # echo -e ${id}'\t'"True"
    awk '{gsub(/.*\//,"",$4);print}' OFS='\t' ${i} | sort -V -k1,1 -k2,2n > ${phylodir}/Astatotilapia_calliptera/${file} # amend the name col in peaks file and sort
    bedtools intersect -a $annotdir/Astatotilapia_calliptera.fAstCal1.2.annot.bed -b ${phylodir}/Astatotilapia_calliptera/${file} -wb |
    awk '{print $11,$14,$4,$12,$13,$15,$6,".",$17";"$18";"$19";"$20";"$21";"$7";"$10}' OFS='\t' > ${phylodir}/Astatotilapia_calliptera/${file}.features.gff
  fi
  if [[ ${id} =~ "Ab" ]]; then
    # echo -e ${id}'\t'"True"
    awk '{gsub(/.*\//,"",$4);print}' OFS='\t' ${i} | sort -V -k1,1 -k2,2n > ${phylodir}/Astatotilapia_burtoni/${file} # amend the name col in peaks file and sort
    bedtools intersect -a $annotdir/Astatotilapia_burtoni.AstBur1.0.annot.bed -b ${phylodir}/Astatotilapia_burtoni/${file} -wb |
    awk '{print $11,$14,$4,$12,$13,$15,$6,".",$17";"$18";"$19";"$20";"$21";"$7";"$10}' OFS='\t' > ${phylodir}/Astatotilapia_burtoni/${file}.features.gff
  fi
  if [[ ${id} =~ "Mz" ]]; then
    # echo -e ${id}'\t'"True"
    awk '{gsub(/.*\//,"",$4);print}' OFS='\t' ${i} | sort -V -k1,1 -k2,2n > ${phylodir}/Metriaclima_zebra/${file} # amend the name col in peaks file and sort
    bedtools intersect -a $annotdir/Metriaclima_zebra.M_zebra_UMD2a.annot.bed -b ${phylodir}/Metriaclima_zebra/${file} -wb |
    awk '{print $11,$14,$4,$12,$13,$15,$6,".",$17";"$18";"$19";"$20";"$21";"$7";"$10}' OFS='\t' > ${phylodir}/Metriaclima_zebra/${file}.features.gff
  fi
  if [[ ${id} =~ "Nb" ]]; then
    # echo -e ${id}'\t'"True"
    awk '{gsub(/.*\//,"",$4);print}' OFS='\t' ${i} | sort -V -k1,1 -k2,2n > ${phylodir}/Neolamprologus_brichardi/${file} # amend the name col in peaks file and sort
    bedtools intersect -a $annotdir/Neolamprologus_brichardi.NeoBri1.0.annot.bed -b ${phylodir}/Neolamprologus_brichardi/${file} -wb |
    awk '{print $11,$14,$4,$12,$13,$15,$6,".",$17";"$18";"$19";"$20";"$21";"$7";"$10}' OFS='\t' > ${phylodir}/Neolamprologus_brichardi/${file}.features.gff
  fi
  if [[ ${id} =~ "On" ]]; then
    # echo -e ${id}'\t'"True"
    awk '{gsub(/.*\//,"",$4);print}' OFS='\t' ${i} | sort -V -k1,1 -k2,2n > ${phylodir}/Oreochromis_niloticus/${file} # amend the name col in peaks file and sort
    bedtools intersect -a $annotdir/Oreochromis_niloticus.O_niloticus_UMD_NMBU.annot.bed -b ${phylodir}/Oreochromis_niloticus/${file} -wb |
    awk '{print $11,$14,$4,$12,$13,$15,$6,".",$17";"$18";"$19";"$20";"$21";"$7";"$10}' OFS='\t' > ${phylodir}/Oreochromis_niloticus/${file}.features.gff
  fi
  if [[ ${id} =~ "Pn" ]]; then
    # echo -e ${id}'\t'"True"
    awk '{gsub(/.*\//,"",$4);print}' OFS='\t' ${i} | sort -V -k1,1 -k2,2n > ${phylodir}/Pundamilia_nyererei/${file} # amend the name col in peaks file and sort
    bedtools intersect -a $annotdir/Pundamilia_nyererei.PunNye1.0.annot.bed -b ${phylodir}/Pundamilia_nyererei/${file} -wb |
    awk '{print $11,$14,$4,$12,$13,$15,$6,".",$17";"$18";"$19";"$20";"$21";"$7";"$10}' OFS='\t' > ${phylodir}/Pundamilia_nyererei/${file}.features.gff
  fi
done

# ix-b. split all the files by chromosome - will need to join all species files first, then split by first col
for i in Astatotilapia_calliptera Astatotilapia_burtoni Metriaclima_zebra Neolamprologus_brichardi Oreochromis_niloticus Pundamilia_nyererei; do
  cd ${phylodir}/${i}
  cat *.features.gff > ${i}_ATAC_peaks.final.narrowPeak.features.gff.tmp1
done

for i in Astatotilapia_calliptera Astatotilapia_burtoni Metriaclima_zebra Neolamprologus_brichardi Oreochromis_niloticus Pundamilia_nyererei; do
  cd ${phylodir}/${i}
  sort -V -k1,1 -k4,4n ${i}_ATAC_peaks.final.narrowPeak.features.gff.tmp1 | awk '{OFS="\t"} {if ($7=="NULL") $7="."; print $0}' | awk '{OFS="\t"} {if ($8=="NULL") $8="."; print $0}' > ${i}_ATAC_peaks.final.narrowPeak.features.gff
  rm ${i}_ATAC_peaks.final.narrowPeak.features.gff.tmp1
  mkdir -p ${phylodir}/${i}/split
  cd ${phylodir}/${i}/split
  awk -F'\t' '{print>$1}' ${phylodir}/${i}/${i}_ATAC_peaks.final.narrowPeak.features.gff
done # Note: will only be using the On split files but running anyway for all species

# for i in Astatotilapia_calliptera Astatotilapia_burtoni Metriaclima_zebra Neolamprologus_brichardi Oreochromis_niloticus Pundamilia_nyererei; do
#   cd ${phylodir}/${i}
#   awk '{OFS="\t"} {if ($7=="NULL") $7="."; print $0}' ${i}_ATAC_peaks.final.narrowPeak.features.gff > ${i}_ATAC_peaks.final.narrowPeak.features.gff.tmp1
#   # awk '{print $1,$3,$2,$4,$5,$6,$8,$7,$9}' OFS='\t' ${i}_ATAC_peaks.final.narrowPeak.features.gff > ${i}_ATAC_peaks.final.narrowPeak.features.gff.tmp1
#   rm ${i}_ATAC_peaks.final.narrowPeak.features.gff
#   mv ${i}_ATAC_peaks.final.narrowPeak.features.gff.tmp1 ${i}_ATAC_peaks.final.narrowPeak.features.gff
#   mkdir -p ${phylodir}/${i}/split
#   cd ${phylodir}/${i}/split
#   awk -F'\t' '{print>$1}' ${phylodir}/${i}/${i}_ATAC_peaks.final.narrowPeak.features.gff
# done

# run the above
sbatch mappeaksfeatures.sh

###################################################################################################################################################################################################################################
###################################################################################################################################################################################################################################
###### FINAL features-peak mapped files here for each species - NOTE: These are ALL peaks (so IDR True and False - DO NOT USE THESE AND INSTEAD USE THE IDR TRUE PEAK FILES BELOW)
# /ei/projects/9/9e238063-c905-4076-a975-f7c7f85dbd56/scratch/ATACseq/3.run2/4b.peak_phylop/0.phylop_run/Astatotilapia_calliptera/Astatotilapia_calliptera_ATAC_peaks.final.narrowPeak.features.gff
# /ei/projects/9/9e238063-c905-4076-a975-f7c7f85dbd56/scratch/ATACseq/3.run2/4b.peak_phylop/0.phylop_run/Astatotilapia_burtoni/Astatotilapia_burtoni_ATAC_peaks.final.narrowPeak.features.gff
# /ei/projects/9/9e238063-c905-4076-a975-f7c7f85dbd56/scratch/ATACseq/3.run2/4b.peak_phylop/0.phylop_run/Metriaclima_zebra/Metriaclima_zebra_ATAC_peaks.final.narrowPeak.features.gff
# /ei/projects/9/9e238063-c905-4076-a975-f7c7f85dbd56/scratch/ATACseq/3.run2/4b.peak_phylop/0.phylop_run/Neolamprologus_brichardi/Neolamprologus_brichardi_ATAC_peaks.final.narrowPeak.features.gff
# /ei/projects/9/9e238063-c905-4076-a975-f7c7f85dbd56/scratch/ATACseq/3.run2/4b.peak_phylop/0.phylop_run/Oreochromis_niloticus/Oreochromis_niloticus_ATAC_peaks.final.narrowPeak.features.gff
# /ei/projects/9/9e238063-c905-4076-a975-f7c7f85dbd56/scratch/ATACseq/3.run2/4b.peak_phylop/0.phylop_run/Pundamilia_nyererei/Pundamilia_nyererei_ATAC_peaks.final.narrowPeak.features.gff

## Cols are:

# 1. chr/scaff
# 2. peak ID - as generated and assigned by MACS
# 3. annotation - intergenic, CNEs, 5kb gene promoter, 5' UTR, exon, intron, 3’ UTR
# 4. start - The starting position of the feature in the sequence. The first base is numbered 1.
# 5. end - The ending position of the feature (inclusive).
# 6. score - Contains the scaled IDR value, min(int(log2(-125IDR), 1000). e.g. peaks with an IDR of 0 have a score of 1000, idr 0.05 have a score of int(-125log2(0.05)) = 540, and idr 1.0 has a score of 0.
# 7. strand - Valid entries include "+", "-", or "." (for don't know/don't care).
# 8. frame - all entries will be '.'
# 9. grouped (separated by ; -  7 values in total)
  # MACS2 peak IDR output- signalValue float - fold-change at peak summit: Measurement of enrichment for the region for merged peaks. When a peak list is provided this is the value from the peak list.
  # MACS2 peak IDR output- p-value float: Merged peak p-value. When a peak list is provided this is the value from the peak list.
  # MACS2 peak IDR output- q-value float: Merged peak q-value. When a peak list is provided this is the value from the peak list.
  # MACS2 peak IDR output- summit int: Merged peak summit
  # MACS2 peak IDR output- IDR True (T) or False (F) of peaks passing IDR threshold of 10%
  # Ensembl Gene ID
  # Ensembl Gene Symbol


# Create a FINAL set of A) collated (by tissue) IDR true narrow peaks, and B) collated (by tissue) IDR true narrow peaks according to feature
peakannotdir=/ei/projects/9/9e238063-c905-4076-a975-f7c7f85dbd56/scratch/ATACseq/3.run2/4b.peak_phylop/0.phylop_run

cd $peakannotdir/Astatotilapia_calliptera
cat 1aAc_3dpf_ATAC_peaks.final.narrowPeak 1bAc_3dpf_ATAC_peaks.final.narrowPeak | awk '$11=="T"' | sort -k1,1 -k2,2n > Ac_3dpf_ATAC_peaks.final.IDRtrueCollated.narrowPeak
cat 1aAc_3dpf_ATAC_peaks.final.narrowPeak.features.gff 1bAc_3dpf_ATAC_peaks.final.narrowPeak.features.gff | grep ';T;' | sort -k1,1 -k2,2n > Ac_3dpf_ATAC_peaks.final.IDRtrueCollated.narrowPeak.features.gff
cat 2aAc_7dpf_ATAC_peaks.final.narrowPeak 2bAc_7dpf_ATAC_peaks.final.narrowPeak | awk '$11=="T"' | sort -k1,1 -k2,2n > Ac_7dpf_ATAC_peaks.final.IDRtrueCollated.narrowPeak
cat 2aAc_7dpf_ATAC_peaks.final.narrowPeak.features.gff 2bAc_7dpf_ATAC_peaks.final.narrowPeak.features.gff | grep ';T;' | sort -k1,1 -k2,2n > Ac_7dpf_ATAC_peaks.final.IDRtrueCollated.narrowPeak.features.gff
cat 3aAc_12dpf_ATAC_peaks.final.narrowPeak 3bAc_12dpf_ATAC_peaks.final.narrowPeak | awk '$11=="T"' | sort -k1,1 -k2,2n > Ac_12dpf_ATAC_peaks.final.IDRtrueCollated.narrowPeak
cat 3aAc_12dpf_ATAC_peaks.final.narrowPeak.features.gff 3bAc_12dpf_ATAC_peaks.final.narrowPeak.features.gff | grep ';T;' | sort -k1,1 -k2,2n > Ac_12dpf_ATAC_peaks.final.IDRtrueCollated.narrowPeak.features.gff

cd $peakannotdir/Astatotilapia_burtoni
for i in B E L T; do
  cat Ab5_${i}_ATAC_peaks.final.narrowPeak Ab6_${i}_ATAC_peaks.final.narrowPeak | awk '$11=="T"' | sort -k1,1 -k2,2n > Ab_${i}_ATAC_peaks.final.IDRtrueCollated.narrowPeak
  cat Ab5_${i}_ATAC_peaks.final.narrowPeak.features.gff Ab6_${i}_ATAC_peaks.final.narrowPeak.features.gff | grep ';T;' | sort -k1,1 -k2,2n > Ab_${i}_ATAC_peaks.final.IDRtrueCollated.narrowPeak.features.gff
done

cd $peakannotdir/Metriaclima_zebra
for i in B E L T; do
  cat Mz1_${i}_ATAC_peaks.final.narrowPeak Mz2_${i}_ATAC_peaks.final.narrowPeak | awk '$11=="T"' | sort -k1,1 -k2,2n > Mz_${i}_ATAC_peaks.final.IDRtrueCollated.narrowPeak
  cat Mz1_${i}_ATAC_peaks.final.narrowPeak.features.gff Mz2_${i}_ATAC_peaks.final.narrowPeak.features.gff | grep ';T;' | sort -k1,1 -k2,2n > Mz_${i}_ATAC_peaks.final.IDRtrueCollated.narrowPeak.features.gff
done

cd $peakannotdir/Neolamprologus_brichardi
for i in B E L T; do
  cat Nb4_${i}_ATAC_peaks.final.narrowPeak Nb5_${i}_ATAC_peaks.final.narrowPeak | awk '$11=="T"' | sort -k1,1 -k2,2n > Nb_${i}_ATAC_peaks.final.IDRtrueCollated.narrowPeak
  cat Nb4_${i}_ATAC_peaks.final.narrowPeak.features.gff Nb5_${i}_ATAC_peaks.final.narrowPeak.features.gff | grep ';T;' | sort -k1,1 -k2,2n > Nb_${i}_ATAC_peaks.final.IDRtrueCollated.narrowPeak.features.gff
done

cd $peakannotdir/Pundamilia_nyererei
for i in B L T; do
  cat Pnm1_${i}_ATAC_peaks.final.narrowPeak Pnm2_${i}_ATAC_peaks.final.narrowPeak Pnm3_${i}_ATAC_peaks.final.narrowPeak Pnm4_${i}_ATAC_peaks.final.narrowPeak | awk '$11=="T"' | sort -k1,1 -k2,2n > Pn_${i}_ATAC_peaks.final.IDRtrueCollated.narrowPeak
  cat Pnm1_${i}_ATAC_peaks.final.narrowPeak.features.gff Pnm2_${i}_ATAC_peaks.final.narrowPeak.features.gff Pnm3_${i}_ATAC_peaks.final.narrowPeak.features.gff Pnm4_${i}_ATAC_peaks.final.narrowPeak.features.gff | grep ';T;' | sort -k1,1 -k2,2n > Pn_${i}_ATAC_peaks.final.IDRtrueCollated.narrowPeak.features.gff
done

cat Pnm2_E_ATAC_peaks.final.narrowPeak Pnm3_E_ATAC_peaks.final.narrowPeak Pnm4_E_ATAC_peaks.final.narrowPeak | awk '$11=="T"' | sort -k1,1 -k2,2n > Pn_E_ATAC_peaks.final.IDRtrueCollated.narrowPeak
cat Pnm2_E_ATAC_peaks.final.narrowPeak.features.gff Pnm3_E_ATAC_peaks.final.narrowPeak.features.gff Pnm4_E_ATAC_peaks.final.narrowPeak.features.gff | grep ';T;' | sort -k1,1 -k2,2n > Pn_E_ATAC_peaks.final.IDRtrueCollated.narrowPeak.features.gff

cd $peakannotdir/Oreochromis_niloticus
for i in B E L T; do
  cat On1_${i}_ATAC_peaks.final.narrowPeak On2_${i}_ATAC_peaks.final.narrowPeak On3_${i}_ATAC_peaks.final.narrowPeak | awk '$11=="T"' | sort -k1,1 -k2,2n > On_${i}_ATAC_peaks.final.IDRtrueCollated.narrowPeak
  cat On1_${i}_ATAC_peaks.final.narrowPeak.features.gff On2_${i}_ATAC_peaks.final.narrowPeak.features.gff On3_${i}_ATAC_peaks.final.narrowPeak.features.gff | grep ';T;' | sort -k1,1 -k2,2n > On_${i}_ATAC_peaks.final.IDRtrueCollated.narrowPeak.features.gff
done


### FINAL IDR true peak and peaks overlapping features files are:
## /ei/projects/9/9e238063-c905-4076-a975-f7c7f85dbd56/scratch/ATACseq/3.run2/4b.peak_phylop/0.phylop_run/*/*_*_ATAC_peaks.final.IDRtrueCollated.narrowPeak
## /ei/projects/9/9e238063-c905-4076-a975-f7c7f85dbd56/scratch/ATACseq/3.run2/4b.peak_phylop/0.phylop_run/*/*_*_ATAC_peaks.final.IDRtrueCollated.narrowPeak.features.gff

###################################################################################################################################################################################################################################
###################################################################################################################################################################################################################################


## x. Calculate phyloP score of O. niloticus peaks only, as ref pairwise vs all other species
# here, we are then able to identify ref On peaks that have likely fast evolved in the other comparison species.
# using this method we want to obtain one score for each peak feature:
  # phyloP scores measure evolutionary conservation at individual alignment sites. Interpretations of the scores are compared to the evolution that is expected under neutral drift.
  # Positive scores — Measure conservation, which is slower evolution than expected, at sites that are predicted to be conserved.
  # Negative scores — Measure acceleration, which is faster evolution than expected, at sites that are predicted to be fast-evolving.

# scripts to create and split the pairwise MAFs and MOD file creation will be in here: /ei/projects/9/92817604-7d6f-42a9-b8c4-b9657c1fde33/scratch/FishCNEs/SixSpCNEs/3.phast/MAFSplitting

# x-i. below will prep the script for each species to then run phylop

cd /ei/projects/9/9e238063-c905-4076-a975-f7c7f85dbd56/scratch/ATACseq/3.run2/4b.peak_phylop/0.phylop_run/Oreochromis_niloticus
mkdir -p /ei/projects/9/9e238063-c905-4076-a975-f7c7f85dbd56/scratch/ATACseq/3.run2/4b.peak_phylop/0.phylop_run/Oreochromis_niloticus/slurmout

for i in Astatotilapia_calliptera Metriaclima_zebra Pundamilia_nyererei Astatotilapia_burtoni Neolamprologus_brichardi; do
  ls -1 /ei/projects/9/9e238063-c905-4076-a975-f7c7f85dbd56/scratch/ATACseq/3.run2/4b.peak_phylop/0.phylop_run/Oreochromis_niloticus/split/* > ${i}_gff
  awk '{gsub(/.*\//,"");print}' ${i}_gff > ${i}_gff2
done

arraystrt=0
arrayend=$(ls -1 /ei/projects/9/9e238063-c905-4076-a975-f7c7f85dbd56/scratch/ATACseq/3.run2/4b.peak_phylop/0.phylop_run/Oreochromis_niloticus/split/* | wc -l | awk '{print $1-1}') # get the array end - this wont change since we always use the same On features

for i in Astatotilapia_calliptera Metriaclima_zebra Pundamilia_nyererei Astatotilapia_burtoni Neolamprologus_brichardi; do
  echo '#!/bin/bash -e' > 1.phyloprun_${i}.sh
  echo '#SBATCH -p ei-short # partition (queue)' >> 1.phyloprun_${i}.sh
  echo '#SBATCH -N 1 # number of nodes' >> 1.phyloprun_${i}.sh
  echo '#SBATCH -n 1 # number of tasks' >> 1.phyloprun_${i}.sh
  echo '#SBATCH --array='${arraystrt}'-'${arrayend} >> 1.phyloprun_${i}.sh
  echo '#SBATCH --mem-per-cpu 28000' >> 1.phyloprun_${i}.sh
  echo '#SBATCH -t 0-00:45' >> 1.phyloprun_${i}.sh
  echo '#SBATCH --mail-type=ALL # notifications for job done & fail' >> 1.phyloprun_${i}.sh
  echo '#SBATCH --mail-user=Tarang.Mehta@earlham.ac.uk # send-to address' >> 1.phyloprun_${i}.sh
  echo '#SBATCH -o slurmout/slurm.%A.%a.out # STDOUT' >> 1.phyloprun_${i}.sh
  echo '#SBATCH -e slurmout/slurm.%A.%a.err # STDERR' >> 1.phyloprun_${i}.sh
  printf '\n' >> 1.phyloprun_${i}.sh
  echo '### SOURCE SOFTWARE' >> 1.phyloprun_${i}.sh
  echo 'source phast-1.3' >> 1.phyloprun_${i}.sh
  printf '\n' >> 1.phyloprun_${i}.sh
  echo '# MAKE VARIABLES' >> 1.phyloprun_${i}.sh
  echo 'SPECIES='${i} >> 1.phyloprun_${i}.sh
  echo 'MOD=/ei/projects/9/92817604-7d6f-42a9-b8c4-b9657c1fde33/scratch/FishCNEs/SixSpCNEs/3.phast/MAFSplitting/Cichlid_6sp.Oreochromis_niloticus-${SPECIES}.V2.PariWiseSplit.maf.mod' >> 1.phyloprun_${i}.sh
  echo 'MAFSPLIT=/ei/projects/9/92817604-7d6f-42a9-b8c4-b9657c1fde33/scratch/FishCNEs/SixSpCNEs/3.phast/MAFSplitting/mafsplit2b_Oreochromis_niloticus-${SPECIES}' >> 1.phyloprun_${i}.sh
  echo 'mkdir -p /ei/projects/9/9e238063-c905-4076-a975-f7c7f85dbd56/scratch/ATACseq/3.run2/4b.peak_phylop/0.phylop_run/Oreochromis_niloticus/Onil_${SPECIES}_PhyloPScores' >> 1.phyloprun_${i}.sh
  echo 'OUT=/ei/projects/9/9e238063-c905-4076-a975-f7c7f85dbd56/scratch/ATACseq/3.run2/4b.peak_phylop/0.phylop_run/Oreochromis_niloticus/Onil_${SPECIES}_PhyloPScores' >> 1.phyloprun_${i}.sh
  printf '\n' >> 1.phyloprun_${i}.sh
  echo '# MAKE ELEMENTS' >> 1.phyloprun_${i}.sh
  echo 'mapfile -t chr2 < ${SPECIES}_gff # assign as elements to $chr2 variable' >> 1.phyloprun_${i}.sh
  echo 'mapfile -t chr3 < ${SPECIES}_gff2 # assign as elements to $chr3 variable' >> 1.phyloprun_${i}.sh
  printf '\n' >> 1.phyloprun_${i}.sh
  echo '# RUN PHYLOP' >> 1.phyloprun_${i}.sh
  echo 'echo -e "Running PhyloP for ${chr2[${SLURM_ARRAY_TASK_ID}]} To Generate Conservation Scores for each peak"' >> 1.phyloprun_${i}.sh
  echo 'phyloP --features ${chr2[${SLURM_ARRAY_TASK_ID}]} --mode CONACC --method LRT ${MOD} ${MAFSPLIT}/${chr3[${SLURM_ARRAY_TASK_ID}]}.maf > ${OUT}/${chr3[${SLURM_ARRAY_TASK_ID}]}.ATAC_peaks.final.narrowPeak.features.out' >> 1.phyloprun_${i}.sh
  echo 'echo -e "Running of PhyloP ${chr2[${SLURM_ARRAY_TASK_ID}]} Complete"' >> 1.phyloprun_${i}.sh
done

# run for all ref species comps
for i in 1.phyloprun_*.sh; do
  sbatch ${i}
done

sbatch 1.phyloprun_Astatotilapia_burtoni.sh
sbatch 1.phyloprun_Astatotilapia_calliptera.sh
sbatch 1.phyloprun_Metriaclima_zebra.sh
sbatch 1.phyloprun_Neolamprologus_brichardi.sh
sbatch 1.phyloprun_Pundamilia_nyererei.sh

## all the LG ones have timed out - need to reamend and run for longer
for i in slurm.44520082.199.err slurm.44520082.300.err slurm.44520082.478.err slurm.44520979.209.err slurm.44520979.199.err slurm.44520980.49.err slurm.44520980.478.err slurm.44520082.19.err slurm.44521045.31.err slurm.44520980.19.err; do
  head slurmout/${i}
done

for i in *_gff *_gff2; do
  grep LG ${i} > ${i}.LG # create a new file just containing list of the LG scaffs for the array
done

arraystrt=0
arrayend=$(wc -l Astatotilapia_burtoni_gff.LG | awk '{print $1-1}') # get the array end - this wont change since we always use the same On features

for i in Astatotilapia_calliptera Metriaclima_zebra Pundamilia_nyererei Astatotilapia_burtoni Neolamprologus_brichardi; do
  echo '#!/bin/bash -e' > 1.phyloprun_${i}_LGonly.sh
  echo '#SBATCH -p ei-medium # partition (queue)' >> 1.phyloprun_${i}_LGonly.sh
  echo '#SBATCH -N 1 # number of nodes' >> 1.phyloprun_${i}_LGonly.sh
  echo '#SBATCH -n 1 # number of tasks' >> 1.phyloprun_${i}_LGonly.sh
  echo '#SBATCH --array='${arraystrt}'-'${arrayend} >> 1.phyloprun_${i}_LGonly.sh
  echo '#SBATCH --mem-per-cpu 28000' >> 1.phyloprun_${i}_LGonly.sh
  echo '#SBATCH -t 0-05:59' >> 1.phyloprun_${i}_LGonly.sh
  echo '#SBATCH --mail-type=ALL # notifications for job done & fail' >> 1.phyloprun_${i}_LGonly.sh
  echo '#SBATCH --mail-user=Tarang.Mehta@earlham.ac.uk # send-to address' >> 1.phyloprun_${i}_LGonly.sh
  echo '#SBATCH -o slurmout/slurm.%A.%a.out # STDOUT' >> 1.phyloprun_${i}_LGonly.sh
  echo '#SBATCH -e slurmout/slurm.%A.%a.err # STDERR' >> 1.phyloprun_${i}_LGonly.sh
  printf '\n' >> 1.phyloprun_${i}_LGonly.sh
  echo '### SOURCE SOFTWARE' >> 1.phyloprun_${i}_LGonly.sh
  echo 'source phast-1.3' >> 1.phyloprun_${i}_LGonly.sh
  printf '\n' >> 1.phyloprun_${i}_LGonly.sh
  echo '# MAKE VARIABLES' >> 1.phyloprun_${i}_LGonly.sh
  echo 'SPECIES='${i} >> 1.phyloprun_${i}_LGonly.sh
  echo 'MOD=/ei/projects/9/92817604-7d6f-42a9-b8c4-b9657c1fde33/scratch/FishCNEs/SixSpCNEs/3.phast/MAFSplitting/Cichlid_6sp.Oreochromis_niloticus-${SPECIES}.V2.PariWiseSplit.maf.mod' >> 1.phyloprun_${i}_LGonly.sh
  echo 'MAFSPLIT=/ei/projects/9/92817604-7d6f-42a9-b8c4-b9657c1fde33/scratch/FishCNEs/SixSpCNEs/3.phast/MAFSplitting/mafsplit2b_Oreochromis_niloticus-${SPECIES}' >> 1.phyloprun_${i}_LGonly.sh
  echo 'mkdir -p /ei/projects/9/9e238063-c905-4076-a975-f7c7f85dbd56/scratch/ATACseq/3.run2/4b.peak_phylop/0.phylop_run/Oreochromis_niloticus/Onil_${SPECIES}_PhyloPScores' >> 1.phyloprun_${i}_LGonly.sh
  echo 'OUT=/ei/projects/9/9e238063-c905-4076-a975-f7c7f85dbd56/scratch/ATACseq/3.run2/4b.peak_phylop/0.phylop_run/Oreochromis_niloticus/Onil_${SPECIES}_PhyloPScores' >> 1.phyloprun_${i}_LGonly.sh
  printf '\n' >> 1.phyloprun_${i}_LGonly.sh
  echo '# MAKE ELEMENTS' >> 1.phyloprun_${i}_LGonly.sh
  echo 'mapfile -t chr2 < ${SPECIES}_gff.LG # assign as elements to $chr2 variable' >> 1.phyloprun_${i}_LGonly.sh
  echo 'mapfile -t chr3 < ${SPECIES}_gff2.LG # assign as elements to $chr3 variable' >> 1.phyloprun_${i}_LGonly.sh
  printf '\n' >> 1.phyloprun_${i}_LGonly.sh
  echo '# RUN PHYLOP' >> 1.phyloprun_${i}_LGonly.sh
  echo 'echo -e "Running PhyloP for ${chr2[${SLURM_ARRAY_TASK_ID}]} To Generate Conservation Scores for each peak"' >> 1.phyloprun_${i}_LGonly.sh
  echo 'phyloP --features ${chr2[${SLURM_ARRAY_TASK_ID}]} --mode CONACC --method LRT ${MOD} ${MAFSPLIT}/${chr3[${SLURM_ARRAY_TASK_ID}]}.maf > ${OUT}/${chr3[${SLURM_ARRAY_TASK_ID}]}.ATAC_peaks.final.narrowPeak.features.out' >> 1.phyloprun_${i}_LGonly.sh
  echo 'echo -e "Running of PhyloP ${chr2[${SLURM_ARRAY_TASK_ID}]} Complete"' >> 1.phyloprun_${i}_LGonly.sh
done

# run for all ref species comps
for i in 1.phyloprun_*_LGonly.sh; do
  sbatch ${i}
done


## xi. Process the PhyloP outputs to map peak features and create final PhyloP files (for Onil only - can run for other species aadaping code below)

mkdir -p /ei/projects/9/9e238063-c905-4076-a975-f7c7f85dbd56/scratch/ATACseq/3.run2/4b.peak_phylop/0.phylop_run/Oreochromis_niloticus/collated_phylop_peaksfeatures
cd /ei/projects/9/9e238063-c905-4076-a975-f7c7f85dbd56/scratch/ATACseq/3.run2/4b.peak_phylop/0.phylop_run/Oreochromis_niloticus/collated_phylop_peaksfeatures

# a) Map outputs to peak feature files

# i) NOTE: phylop output is 0 base and gff is 1 base so, when mapping, change the mapping ID in features file to 0 base e.g MKQE02000710_16012_16210 > MKQE02000710_16011_16210
# ii) create a mapping ID column in the gff peak features file (as last col, col10, changing to 0 base e.g MKQE02000710_16012_16210 > MKQE02000710_16011_16210)
onilpeakfeatgff=/ei/projects/9/9e238063-c905-4076-a975-f7c7f85dbd56/scratch/ATACseq/3.run2/4b.peak_phylop/0.phylop_run/Oreochromis_niloticus/Oreochromis_niloticus_ATAC_peaks.final.narrowPeak.features.gff
awk '{print $0,$1"_"$4-1"_"$5}' OFS='\t' ${onilpeakfeatgff} > Oreochromis_niloticus_ATAC_peaks.final.narrowPeak.features.amend.gff
# iii) cat all the phylop outputs for each species into one file (remember to remove headers), remove duplicates, remove header lines, create a mapping ID column (as last col), and sort by coordinates
for i in Astatotilapia_calliptera_PhyloPScores Metriaclima_zebra_PhyloPScores Pundamilia_nyererei_PhyloPScores Astatotilapia_burtoni_PhyloPScores Neolamprologus_brichardi_PhyloPScores; do
  sp=$(echo ${i} | sed 's|_PhyloPScores||g')
  cat /ei/projects/9/9e238063-c905-4076-a975-f7c7f85dbd56/scratch/ATACseq/3.run2/4b.peak_phylop/0.phylop_run/Oreochromis_niloticus/Onil_${i}/*.out | awk '!visited[$0]++' | grep -v 'lnlratio' | awk '{print $0,$1"_"$2"_"$3}' OFS='\t' | sort -V -k1,1 -k2,2n > Onil-${sp}.ATAC_peaks.final.narrowPeak.out
done

wc -l *.out
# 4607906 Onil-Astatotilapia_burtoni.ATAC_peaks.final.narrowPeak.out
# 4607855 Onil-Astatotilapia_calliptera.ATAC_peaks.final.narrowPeak.out
# 4607906 Onil-Metriaclima_zebra.ATAC_peaks.final.narrowPeak.out
# 4607883 Onil-Neolamprologus_brichardi.ATAC_peaks.final.narrowPeak.out
# 4607906 Onil-Pundamilia_nyererei.ATAC_peaks.final.narrowPeak.out


# iv) do the map (col10 in features and col8 in phylop scores) - NOTE: THIS IS FOR IDR TRUE AND FALSE
for i in Astatotilapia_calliptera Metriaclima_zebra Pundamilia_nyererei Astatotilapia_burtoni Neolamprologus_brichardi; do
  awk 'BEGIN{OFS="\t"}NR==FNR{a[$10]=$0;next}{if(a[$8]){print $0,a[$8];}else{print $0,"REMOVEME";}}' Oreochromis_niloticus_ATAC_peaks.final.narrowPeak.features.amend.gff Onil-${i}.ATAC_peaks.final.narrowPeak.out | grep -v 'REMOVEME' | awk '{print $1,$10,$11,$12,$13,$14,$15,$16,$17,$5,$6,$7}' OFS='\t' > Onil-${i}.ATAC_peaks.final.narrowPeak.mapfeatures.out
done

# iv) do the map (col10 in features and col8 in phylop scores) - NOTE: THIS IS FOR IDR TRUE ONLY SO JUST USE THESE!!!
cat /ei/projects/9/9e238063-c905-4076-a975-f7c7f85dbd56/scratch/ATACseq/3.run2/4b.peak_phylop/0.phylop_run/Oreochromis_niloticus/On_*_ATAC_peaks.final.IDRtrueCollated.narrowPeak.features.gff | sort -V -k1,1 -k4,4n > /ei/projects/9/9e238063-c905-4076-a975-f7c7f85dbd56/scratch/ATACseq/3.run2/4b.peak_phylop/0.phylop_run/Oreochromis_niloticus/On_CollatedTissueATAC_peaks.final.IDRtrueCollated.narrowPeak.features.gff
awk '{print $0,$1"_"$4-1"_"$5}' OFS='\t' /ei/projects/9/9e238063-c905-4076-a975-f7c7f85dbd56/scratch/ATACseq/3.run2/4b.peak_phylop/0.phylop_run/Oreochromis_niloticus/On_CollatedTissueATAC_peaks.final.IDRtrueCollated.narrowPeak.features.gff > On_CollatedTissueATAC_peaks.final.IDRtrueCollated.narrowPeak.features.amend.gff

for i in Astatotilapia_calliptera Metriaclima_zebra Pundamilia_nyererei Astatotilapia_burtoni Neolamprologus_brichardi; do
  awk 'BEGIN{OFS="\t"}NR==FNR{a[$10]=$0;next}{if(a[$8]){print $0,a[$8];}else{print $0,"REMOVEME";}}' On_CollatedTissueATAC_peaks.final.IDRtrueCollated.narrowPeak.features.amend.gff Onil-${i}.ATAC_peaks.final.narrowPeak.out | grep -v 'REMOVEME' | awk '{print $1,$10,$11,$12,$13,$14,$15,$16,$17,$5,$6,$7}' OFS='\t' > Onil-${i}.ATAC_peaks.final.IDRtrueCollated.narrowPeak.mapfeatures.out
done

################################################################################################################################################
######## THESE ARE THE FINAL PHYLOP FILES OF PEAKS MAPPED TO FEATURES IN O. niloticus only, INCLUDING IDR STATS -
## have ran for the other species pairwise but haven't collated - just need to run the code above with species-specific gff amend too

# for IDR true only
finalphyloppeakdir=/ei/projects/9/9e238063-c905-4076-a975-f7c7f85dbd56/scratch/ATACseq/3.run2/4b.peak_phylop/0.phylop_run/Oreochromis_niloticus/collated_phylop_peaksfeatures
wc -l ${finalphyloppeakdir}/*.IDRtrueCollated.narrowPeak.mapfeatures.out

# 1517775 /ei/projects/9/9e238063-c905-4076-a975-f7c7f85dbd56/scratch/ATACseq/3.run2/4b.peak_phylop/0.phylop_run/Oreochromis_niloticus/collated_phylop_peaksfeatures/Onil-Astatotilapia_burtoni.ATAC_peaks.final.IDRtrueCollated.narrowPeak.mapfeatures.out
# 1517738 /ei/projects/9/9e238063-c905-4076-a975-f7c7f85dbd56/scratch/ATACseq/3.run2/4b.peak_phylop/0.phylop_run/Oreochromis_niloticus/collated_phylop_peaksfeatures/Onil-Astatotilapia_calliptera.ATAC_peaks.final.IDRtrueCollated.narrowPeak.mapfeatures.out
# 1517775 /ei/projects/9/9e238063-c905-4076-a975-f7c7f85dbd56/scratch/ATACseq/3.run2/4b.peak_phylop/0.phylop_run/Oreochromis_niloticus/collated_phylop_peaksfeatures/Onil-Metriaclima_zebra.ATAC_peaks.final.IDRtrueCollated.narrowPeak.mapfeatures.out
# 1517771 /ei/projects/9/9e238063-c905-4076-a975-f7c7f85dbd56/scratch/ATACseq/3.run2/4b.peak_phylop/0.phylop_run/Oreochromis_niloticus/collated_phylop_peaksfeatures/Onil-Neolamprologus_brichardi.ATAC_peaks.final.IDRtrueCollated.narrowPeak.mapfeatures.out
# 1517775 /ei/projects/9/9e238063-c905-4076-a975-f7c7f85dbd56/scratch/ATACseq/3.run2/4b.peak_phylop/0.phylop_run/Oreochromis_niloticus/collated_phylop_peaksfeatures/Onil-Pundamilia_nyererei.ATAC_peaks.final.IDRtrueCollated.narrowPeak.mapfeatures.out

# for both IDR true and false
finalphyloppeakdir=/ei/projects/9/9e238063-c905-4076-a975-f7c7f85dbd56/scratch/ATACseq/3.run2/4b.peak_phylop/0.phylop_run/Oreochromis_niloticus/collated_phylop_peaksfeatures
wc -l ${finalphyloppeakdir}/*.mapfeatures.out

# 4607895 /ei/projects/9/9e238063-c905-4076-a975-f7c7f85dbd56/scratch/ATACseq/3.run2/4b.peak_phylop/0.phylop_run/Oreochromis_niloticus/collated_phylop_peaksfeatures/Onil-Astatotilapia_burtoni.ATAC_peaks.final.narrowPeak.mapfeatures.out
# 4607844 /ei/projects/9/9e238063-c905-4076-a975-f7c7f85dbd56/scratch/ATACseq/3.run2/4b.peak_phylop/0.phylop_run/Oreochromis_niloticus/collated_phylop_peaksfeatures/Onil-Astatotilapia_calliptera.ATAC_peaks.final.narrowPeak.mapfeatures.out
# 4607895 /ei/projects/9/9e238063-c905-4076-a975-f7c7f85dbd56/scratch/ATACseq/3.run2/4b.peak_phylop/0.phylop_run/Oreochromis_niloticus/collated_phylop_peaksfeatures/Onil-Metriaclima_zebra.ATAC_peaks.final.narrowPeak.mapfeatures.out
# 4607878 /ei/projects/9/9e238063-c905-4076-a975-f7c7f85dbd56/scratch/ATACseq/3.run2/4b.peak_phylop/0.phylop_run/Oreochromis_niloticus/collated_phylop_peaksfeatures/Onil-Neolamprologus_brichardi.ATAC_peaks.final.narrowPeak.mapfeatures.out
# 4607895 /ei/projects/9/9e238063-c905-4076-a975-f7c7f85dbd56/scratch/ATACseq/3.run2/4b.peak_phylop/0.phylop_run/Oreochromis_niloticus/collated_phylop_peaksfeatures/Onil-Pundamilia_nyererei.ATAC_peaks.final.narrowPeak.mapfeatures.out

## Output is gff format (1-based) - cols are:
## NOTE: the above files contain Gill peaks too, which we will remove for this paper

# 1. chr/scaff
# 2. peak ID - as generated and assigned by MACS
# 3. annotation - intergenic, CNEs, 5kb gene promoter, 5' UTR, exon, intron, 3’ UTR
# 4. start - The starting position of the feature in the sequence. The first base is numbered 1.
# 5. end - The ending position of the feature (inclusive).
# 6. score - Contains the scaled IDR value, min(int(log2(-125IDR), 1000). e.g. peaks with an IDR of 0 have a score of 1000, idr 0.05 have a score of int(-125log2(0.05)) = 540, and idr 1.0 has a score of 0.
# 7. strand - Valid entries include "+", "-", or "." (for don't know/don't care).
# 8. frame - all entries will be '.'
# 9. grouped (separated by ; -  7 values in total)
  # MACS2 peak IDR output- signalValue float - fold-change at peak summit: Measurement of enrichment for the region for merged peaks. When a peak list is provided this is the value from the peak list.
  # MACS2 peak IDR output- p-value float: Merged peak p-value. When a peak list is provided this is the value from the peak list.
  # MACS2 peak IDR output- q-value float: Merged peak q-value. When a peak list is provided this is the value from the peak list.
  # MACS2 peak IDR output- summit int: Merged peak summit
  # MACS2 peak IDR output- IDR True (T) or False (F) of peaks passing IDR threshold of 10%
  # Ensembl Gene ID
  # Ensembl Gene Symbol
# 10. phylop scale	- this is the altsubscale (we want more than 1 for deviation)
# 11. phylop lnlratio - this is the likelihood-ratio-test (we want <0.05)
# 12. phylop pval - this is the CONACC score: +ve is conserved and -ve is accelerated


################################################################################################################################################


################################################################################################################

### 5. Differential analysis of peaks

### NOTE: be careful when considering differential peaks as some may be only offset by a few bases. In this scenario, consider the average number of mapped reads over a window.

## This article details different methods with scripts for differential accessibility analysis: https://epigeneticsandchromatin.biomedcentral.com/articles/10.1186/s13072-020-00342-y
## Best to analyse the narrow peaks only - narrow peaks are generally analysed for TF-binding and broad peaks for histone modifications

## DiffBind:
# The core functionality of DiffBind is the differential binding affinity analysis, which enables binding sites to be identified that are statistically significantly differentially bound between sample groups.
# The core analysis routines are executed, by default using DESeq2.
# This will assign a p-value and FDR to each candidate binding site indicating confidence that they are differentially bound.

## Use DiffBind to:
  # A. Determine tissue-specific peaks in each species
    # Tissue-specificity of ATAC-seq peaks was determined using DiffBind (https://www.bioconductor.org/packages/release/bioc/ html/DiffBind.html),
    # This provided the peak coordinates for each of the biological replicates of all tissues profiled as input, plus the mapped and shifted sequencing reads (parameters ‘method = DBA_EDGER, bFullLibrarySize = FALSE, bSubControl = FALSE, bTagwise = FALSE’).
    # All peaks identified with a log2 fold change equal or greater than 1 in one tissue compared to all others were selected as tissue-specific.
  # B. Determine tissue-specific peaks between species same tissues e.g. Ab5_L vs Nb5_L
    # you need to find a way to compare different species - use association to orthologous genes and/or multiple genome alignment

################# NOTE: USE ALL SAMPLES EXCEPT FOR Pnm3_L_ATAC #################

## ~ INSERT CODE HERE ~ ##

echo '# -- 3b. TF footprinting and creation of signal tracks has completed -- #'

echo '# -- 4. Differential analysis of peaks has started -- #'

JOBID32=$( sbatch -W --dependency=afterok:${JOBID31} XX.sh | awk '{print $4}' ) # JOB32 depends on JOB31 completing successfully

################################################################################################################

echo '# -- 5. Differential analysis of peaks has completed -- #'

### Finish the script
echo -e '# --------------------\nEXITING SCRIPT - all completed\n# --------------------'

exit 0
